{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n}); // @flow\n\n/*:: import type {\n  CombinatorTokenType,\n  SelectorTokenType\n} from './types';*/\n\nvar escapeValue = function escapeValue(value\n/*: string*/\n)\n/*: string*/\n{\n  return JSON.stringify(value);\n};\n\nvar renderSelector = function renderSelector(selectorToken\n/*: SelectorTokenType*/\n) {\n  var tokens = selectorToken.body;\n  var parts = [];\n  var _iteratorNormalCompletion = true;\n  var _didIteratorError = false;\n  var _iteratorError = undefined;\n\n  try {\n    for (var _iterator = tokens[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n      var token = _step.value;\n      var part = void 0;\n\n      if (token.type === 'universalSelector') {\n        part = '*';\n      } else if (token.type === 'typeSelector') {\n        part = token.name;\n      } else if (token.type === 'idSelector') {\n        part = '#' + token.name;\n      } else if (token.type === 'classSelector') {\n        part = '.' + token.name;\n      } else if (token.type === 'attributePresenceSelector') {\n        part = '[' + token.name + ']';\n      } else if (token.type === 'attributeValueSelector') {\n        part = '[' + token.name + token.operator + escapeValue(token.value) + ']';\n      } else if (token.type === 'pseudoClassSelector') {\n        part = ':' + token.name;\n\n        if (token.parameters.length) {\n          part += '(' + token.parameters.map(escapeValue).join(', ') + ')';\n        }\n      } else if (token.type === 'pseudoElementSelector') {\n        part = '::' + token.name;\n      } else {\n        throw new Error('Unknown token.');\n      }\n\n      parts.push(part);\n    }\n  } catch (err) {\n    _didIteratorError = true;\n    _iteratorError = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion && _iterator.return) {\n        _iterator.return();\n      }\n    } finally {\n      if (_didIteratorError) {\n        throw _iteratorError;\n      }\n    }\n  }\n\n  return parts.join('');\n};\n\nexports.default = function () {\n  var generate = function generate(tokens\n  /*: Array<SelectorTokenType | CombinatorTokenType>*/\n  )\n  /*: string*/\n  {\n    /**\n     * @todo Think of a better name. This array contains selectors or combinators.\n     */\n    var sequences\n    /*: Array<string>*/\n    = [];\n    var _iteratorNormalCompletion2 = true;\n    var _didIteratorError2 = false;\n    var _iteratorError2 = undefined;\n\n    try {\n      for (var _iterator2 = tokens[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n        var token = _step2.value;\n\n        if (token.type === 'selector') {\n          sequences.push(renderSelector(token));\n        } else if (token.type === 'descendantCombinator') {\n          sequences.push(' ');\n        } else if (token.type === 'childCombinator') {\n          sequences.push(' > ');\n        } else if (token.type === 'adjacentSiblingCombinator') {\n          sequences.push(' + ');\n        } else if (token.type === 'generalSiblingCombinator') {\n          sequences.push(' ~ ');\n        } else {\n          throw new Error('Unknown token.');\n        }\n      }\n    } catch (err) {\n      _didIteratorError2 = true;\n      _iteratorError2 = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion2 && _iterator2.return) {\n          _iterator2.return();\n        }\n      } finally {\n        if (_didIteratorError2) {\n          throw _iteratorError2;\n        }\n      }\n    }\n\n    return sequences.join('');\n  };\n\n  return {\n    generate: generate\n  };\n};","map":{"version":3,"mappings":"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","names":["escapeValue","value","JSON","stringify","renderSelector","selectorToken","tokens","body","parts","token","part","type","name","operator","parameters","length","map","join","Error","push","_didIteratorError","_iteratorError","_iterator","generate","sequences","_didIteratorError2","_iteratorError2","_iterator2"],"sources":["/Users/sebas/Desktop/robofriends-testing/node_modules/rst-selector-parser/src/createGenerator.js"],"sourcesContent":["// @flow\n\nimport type {\n  CombinatorTokenType,\n  SelectorTokenType\n} from './types';\n\nconst escapeValue = (value: string): string => {\n  return JSON.stringify(value);\n};\n\nconst renderSelector = (selectorToken: SelectorTokenType) => {\n  const tokens = selectorToken.body;\n  const parts = [];\n\n  for (const token of tokens) {\n    let part;\n\n    if (token.type === 'universalSelector') {\n      part = '*';\n    } else if (token.type === 'typeSelector') {\n      part = token.name;\n    } else if (token.type === 'idSelector') {\n      part = '#' + token.name;\n    } else if (token.type === 'classSelector') {\n      part = '.' + token.name;\n    } else if (token.type === 'attributePresenceSelector') {\n      part = '[' + token.name + ']';\n    } else if (token.type === 'attributeValueSelector') {\n      part = '[' + token.name + token.operator + escapeValue(token.value) + ']';\n    } else if (token.type === 'pseudoClassSelector') {\n      part = ':' + token.name;\n\n      if (token.parameters.length) {\n        part += '(' + token.parameters.map(escapeValue).join(', ') + ')';\n      }\n    } else if (token.type === 'pseudoElementSelector') {\n      part = '::' + token.name;\n    } else {\n      throw new Error('Unknown token.');\n    }\n\n    parts.push(part);\n  }\n\n  return parts.join('');\n};\n\nexport default () => {\n  const generate = (tokens: Array<SelectorTokenType | CombinatorTokenType>): string => {\n    /**\n     * @todo Think of a better name. This array contains selectors or combinators.\n     */\n    const sequences: Array<string> = [];\n\n    for (const token of tokens) {\n      if (token.type === 'selector') {\n        sequences.push(renderSelector(token));\n      } else if (token.type === 'descendantCombinator') {\n        sequences.push(' ');\n      } else if (token.type === 'childCombinator') {\n        sequences.push(' > ');\n      } else if (token.type === 'adjacentSiblingCombinator') {\n        sequences.push(' + ');\n      } else if (token.type === 'generalSiblingCombinator') {\n        sequences.push(' ~ ');\n      } else {\n        throw new Error('Unknown token.');\n      }\n    }\n\n    return sequences.join('');\n  };\n\n  return {\n    generate\n  };\n};\n"]},"metadata":{},"sourceType":"script"}