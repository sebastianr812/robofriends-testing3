{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) {\n  return typeof obj;\n} : function (obj) {\n  return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n};\n\nvar _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\nvar _object = require('object.assign');\n\nvar _object2 = _interopRequireDefault(_object);\n\nvar _arrayPrototype = require('array.prototype.flat');\n\nvar _arrayPrototype2 = _interopRequireDefault(_arrayPrototype);\n\nvar _has = require('has');\n\nvar _has2 = _interopRequireDefault(_has);\n\nvar _Utils = require('./Utils');\n\nvar _getAdapter = require('./getAdapter');\n\nvar _getAdapter2 = _interopRequireDefault(_getAdapter);\n\nvar _Debug = require('./Debug');\n\nvar _RSTTraversal = require('./RSTTraversal');\n\nvar _selectors = require('./selectors');\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nvar NODE = (0, _Utils.sym)('__node__');\nvar NODES = (0, _Utils.sym)('__nodes__');\nvar RENDERER = (0, _Utils.sym)('__renderer__');\nvar UNRENDERED = (0, _Utils.sym)('__unrendered__');\nvar ROOT = (0, _Utils.sym)('__root__');\nvar OPTIONS = (0, _Utils.sym)('__options__');\nvar ROOT_NODES = (0, _Utils.sym)('__rootNodes__');\nvar WRAPPING_COMPONENT = (0, _Utils.sym)('__wrappingComponent__');\nvar LINKED_ROOTS = (0, _Utils.sym)('__linkedRoots__');\nvar UPDATED_BY = (0, _Utils.sym)('__updatedBy__');\n/**\n * Finds all nodes in the current wrapper nodes' render trees that match the provided predicate\n * function.\n *\n * @param {ReactWrapper} wrapper\n * @param {Function} predicate\n * @param {Function} filter\n * @returns {ReactWrapper}\n */\n\nfunction findWhereUnwrapped(wrapper, predicate) {\n  var filter = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : _RSTTraversal.treeFilter;\n  return wrapper.flatMap(function (n) {\n    return filter(n.getNodeInternal(), predicate);\n  });\n}\n/**\n * Returns a new wrapper instance with only the nodes of the current wrapper instance that match\n * the provided predicate function.\n *\n * @param {ReactWrapper} wrapper\n * @param {Function} predicate\n * @returns {ReactWrapper}\n */\n\n\nfunction filterWhereUnwrapped(wrapper, predicate) {\n  return wrapper.wrap(wrapper.getNodesInternal().filter(predicate).filter(Boolean));\n}\n\nfunction getRootNodeInternal(wrapper) {\n  if (wrapper[ROOT].length !== 1) {\n    throw new Error('getRootNodeInternal(wrapper) can only be called when wrapper wraps one node');\n  }\n\n  if (wrapper[ROOT] !== wrapper) {\n    return wrapper[ROOT_NODES][0];\n  }\n\n  return wrapper[ROOT][NODE];\n}\n\nfunction nodeParents(wrapper, node) {\n  return (0, _RSTTraversal.parentsOfNode)(node, getRootNodeInternal(wrapper));\n}\n\nfunction privateSetNodes(wrapper, nodes) {\n  if (!nodes) {\n    (0, _Utils.privateSet)(wrapper, NODE, null);\n    (0, _Utils.privateSet)(wrapper, NODES, []);\n  } else if (!Array.isArray(nodes)) {\n    (0, _Utils.privateSet)(wrapper, NODE, nodes);\n    (0, _Utils.privateSet)(wrapper, NODES, [nodes]);\n  } else {\n    (0, _Utils.privateSet)(wrapper, NODE, nodes[0]);\n    (0, _Utils.privateSet)(wrapper, NODES, nodes);\n  }\n\n  (0, _Utils.privateSet)(wrapper, 'length', wrapper[NODES].length);\n}\n/**\n * @class ReactWrapper\n */\n\n\nvar ReactWrapper = function () {\n  function ReactWrapper(nodes, root) {\n    var passedOptions = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n    _classCallCheck(this, ReactWrapper);\n\n    if (!global.window && !global.document) {\n      throw new Error('It looks like you called `mount()` without a global document being loaded.');\n    }\n\n    var options = (0, _Utils.makeOptions)(passedOptions);\n\n    if (!root) {\n      var adapter = (0, _getAdapter2['default'])(options);\n\n      if (!adapter.isValidElement(nodes)) {\n        throw new TypeError('ReactWrapper can only wrap valid elements');\n      }\n\n      var renderer = adapter.createRenderer((0, _object2['default'])({\n        mode: 'mount'\n      }, options));\n      (0, _Utils.privateSet)(this, RENDERER, renderer);\n      renderer.render(nodes, options.context);\n      (0, _Utils.privateSet)(this, ROOT, this);\n      privateSetNodes(this, this[RENDERER].getNode());\n      (0, _Utils.privateSet)(this, OPTIONS, options);\n      (0, _Utils.privateSet)(this, LINKED_ROOTS, []);\n\n      if ((0, _Utils.isCustomComponent)(options.wrappingComponent, adapter)) {\n        if (typeof this[RENDERER].getWrappingComponentRenderer !== 'function') {\n          throw new TypeError('your adapter does not support `wrappingComponent`. Try upgrading it!');\n        } // eslint-disable-next-line no-use-before-define\n\n\n        (0, _Utils.privateSet)(this, WRAPPING_COMPONENT, new WrappingComponentWrapper(this, this[RENDERER].getWrappingComponentRenderer()));\n        this[LINKED_ROOTS].push(this[WRAPPING_COMPONENT]);\n      }\n    } else {\n      (0, _Utils.privateSet)(this, RENDERER, root[RENDERER]);\n      (0, _Utils.privateSet)(this, ROOT, root);\n      privateSetNodes(this, nodes);\n      (0, _Utils.privateSet)(this, ROOT_NODES, root[NODES]);\n      (0, _Utils.privateSet)(this, OPTIONS, root[OPTIONS]);\n      (0, _Utils.privateSet)(this, LINKED_ROOTS, []);\n    }\n\n    (0, _Utils.privateSet)(this, UNRENDERED, nodes);\n    (0, _Utils.privateSet)(this, UPDATED_BY, null);\n  }\n  /**\n   * Returns the root wrapper\n   *\n   * @return {ReactWrapper}\n   */\n\n\n  _createClass(ReactWrapper, [{\n    key: 'root',\n    value: function () {\n      function root() {\n        return this[ROOT];\n      }\n\n      return root;\n    }()\n    /**\n     * Returns the wrapped component.\n     *\n     * @return {ReactComponent}\n     */\n\n  }, {\n    key: 'getNodeInternal',\n    value: function () {\n      function getNodeInternal() {\n        if (this.length !== 1) {\n          throw new Error('ReactWrapper::getNode() can only be called when wrapping one node');\n        }\n\n        return this[NODES][0];\n      }\n\n      return getNodeInternal;\n    }()\n    /**\n     * Returns the the wrapped components.\n     *\n     * @return {Array<ReactComponent>}\n     */\n\n  }, {\n    key: 'getNodesInternal',\n    value: function () {\n      function getNodesInternal() {\n        return this[NODES];\n      }\n\n      return getNodesInternal;\n    }()\n    /**\n     * Returns the wrapped ReactElement.\n     *\n     * @return {ReactElement}\n     */\n\n  }, {\n    key: 'getElement',\n    value: function () {\n      function getElement() {\n        var _this = this;\n\n        return this.single('getElement', function () {\n          return (0, _getAdapter2['default'])(_this[OPTIONS]).nodeToElement(_this[NODE]);\n        });\n      }\n\n      return getElement;\n    }()\n    /**\n     * Returns the wrapped ReactElements.\n     *\n     * @return {Array<ReactElement>}\n     */\n\n  }, {\n    key: 'getElements',\n    value: function () {\n      function getElements() {\n        var _this2 = this;\n\n        return this[NODES].map(function (n) {\n          return (0, _getAdapter2['default'])(_this2[OPTIONS]).nodeToElement(n);\n        });\n      }\n\n      return getElements;\n    }() // eslint-disable-next-line class-methods-use-this\n\n  }, {\n    key: 'getNode',\n    value: function () {\n      function getNode() {\n        throw new Error('ReactWrapper::getNode() is no longer supported. Use ReactWrapper::instance() instead');\n      }\n\n      return getNode;\n    }() // eslint-disable-next-line class-methods-use-this\n\n  }, {\n    key: 'getNodes',\n    value: function () {\n      function getNodes() {\n        throw new Error('ReactWrapper::getNodes() is no longer supported.');\n      }\n\n      return getNodes;\n    }()\n    /**\n     * Returns the outer most DOMComponent of the current wrapper.\n     *\n     * NOTE: can only be called on a wrapper of a single node.\n     *\n     * @returns {DOMComponent}\n     */\n\n  }, {\n    key: 'getDOMNode',\n    value: function () {\n      function getDOMNode() {\n        var adapter = (0, _getAdapter2['default'])(this[OPTIONS]);\n        return this.single('getDOMNode', function (n) {\n          return adapter.nodeToHostNode(n, true);\n        });\n      }\n\n      return getDOMNode;\n    }()\n    /**\n     * If the root component contained a ref, you can access it here and get the relevant\n     * react component instance or HTML element instance.\n     *\n     * NOTE: can only be called on a wrapper instance that is also the root instance.\n     *\n     * @param {String} refname\n     * @returns {ReactComponent | HTMLElement}\n     */\n\n  }, {\n    key: 'ref',\n    value: function () {\n      function ref(refname) {\n        if (this[ROOT] !== this) {\n          throw new Error('ReactWrapper::ref(refname) can only be called on the root');\n        }\n\n        return this.instance().refs[refname];\n      }\n\n      return ref;\n    }()\n    /**\n     * Returns the wrapper's underlying instance.\n     *\n     * Example:\n     * ```\n     * const wrapper = mount(<MyComponent />);\n     * const inst = wrapper.instance();\n     * expect(inst).to.be.instanceOf(MyComponent);\n     * ```\n     * @returns {ReactComponent|DOMComponent}\n     */\n\n  }, {\n    key: 'instance',\n    value: function () {\n      function instance() {\n        var _this3 = this;\n\n        return this.single('instance', function () {\n          return _this3[NODE].instance;\n        });\n      }\n\n      return instance;\n    }()\n    /**\n     * If a `wrappingComponent` was passed in `options`, this methods returns a `ReactWrapper` around\n     * the rendered `wrappingComponent`. This `ReactWrapper` can be used to update the\n     * `wrappingComponent`'s props, state, etc.\n     *\n     * @returns ReactWrapper\n     */\n\n  }, {\n    key: 'getWrappingComponent',\n    value: function () {\n      function getWrappingComponent() {\n        if (this[ROOT] !== this) {\n          throw new Error('ReactWrapper::getWrappingComponent() can only be called on the root');\n        }\n\n        if (!this[OPTIONS].wrappingComponent) {\n          throw new Error('ReactWrapper::getWrappingComponent() can only be called on a wrapper that was originally passed a `wrappingComponent` option');\n        }\n\n        return this[WRAPPING_COMPONENT];\n      }\n\n      return getWrappingComponent;\n    }()\n    /**\n     * Forces a re-render. Useful to run before checking the render output if something external\n     * may be updating the state of the component somewhere.\n     *\n     * NOTE: no matter what instance this is called on, it will always update the root.\n     *\n     * @returns {ReactWrapper}\n     */\n\n  }, {\n    key: 'update',\n    value: function () {\n      function update() {\n        var _this4 = this;\n\n        var root = this[ROOT];\n\n        if (this !== root) {\n          return root.update();\n        }\n\n        privateSetNodes(this, this[RENDERER].getNode());\n        this[LINKED_ROOTS].forEach(function (linkedRoot) {\n          if (linkedRoot !== _this4[UPDATED_BY]) {\n            /* eslint-disable no-param-reassign */\n            // Only update a linked it root if it is not the originator of our update().\n            // This is needed to prevent infinite recursion when there is a bi-directional\n            // link between two roots.\n            linkedRoot[UPDATED_BY] = _this4;\n\n            try {\n              linkedRoot.update();\n            } finally {\n              linkedRoot[UPDATED_BY] = null;\n            }\n          }\n        });\n        return this;\n      }\n\n      return update;\n    }()\n    /**\n     * A method that unmounts the component. This can be used to simulate a component going through\n     * and unmount/mount lifecycle.\n     *\n     * @returns {ReactWrapper}\n     */\n\n  }, {\n    key: 'unmount',\n    value: function () {\n      function unmount() {\n        var _this5 = this;\n\n        if (this[ROOT] !== this) {\n          throw new Error('ReactWrapper::unmount() can only be called on the root');\n        }\n\n        this.single('unmount', function () {\n          _this5[RENDERER].unmount();\n\n          _this5.update();\n        });\n        return this;\n      }\n\n      return unmount;\n    }()\n    /**\n     * A method that re-mounts the component, if it is not currently mounted.\n     * This can be used to simulate a component going through\n     * an unmount/mount lifecycle.\n     *\n     * @returns {ReactWrapper}\n     */\n\n  }, {\n    key: 'mount',\n    value: function () {\n      function mount() {\n        var _this6 = this;\n\n        if (this[ROOT] !== this) {\n          throw new Error('ReactWrapper::mount() can only be called on the root');\n        }\n\n        this[RENDERER].render(this[UNRENDERED], this[OPTIONS].context, function () {\n          return _this6.update();\n        });\n        return this;\n      }\n\n      return mount;\n    }()\n    /**\n     * A method that sets the props of the root component, and re-renders. Useful for when you are\n     * wanting to test how the component behaves over time with changing props. Calling this, for\n     * instance, will call the `componentWillReceiveProps` lifecycle method.\n     *\n     * Similar to `setState`, this method accepts a props object and will merge it in with the already\n     * existing props.\n     *\n     * NOTE: can only be called on a wrapper instance that is also the root instance.\n     *\n     * @param {Object} props object\n     * @param {Function} cb - callback function\n     * @returns {ReactWrapper}\n     */\n\n  }, {\n    key: 'setProps',\n    value: function () {\n      function setProps(props) {\n        var _this7 = this;\n\n        var callback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;\n\n        if (this[ROOT] !== this) {\n          throw new Error('ReactWrapper::setProps() can only be called on the root');\n        }\n\n        if (arguments.length > 1 && typeof callback !== 'function') {\n          throw new TypeError('ReactWrapper::setProps() expects a function as its second argument');\n        }\n\n        var adapter = (0, _getAdapter2['default'])(this[OPTIONS]);\n        this[UNRENDERED] = (0, _Utils.cloneElement)(adapter, this[UNRENDERED], props);\n        this[RENDERER].render(this[UNRENDERED], null, function () {\n          _this7.update();\n\n          if (callback) {\n            callback();\n          }\n        });\n        return this;\n      }\n\n      return setProps;\n    }()\n    /**\n     * A method to invoke `setState` on the root component instance similar to how you might in the\n     * definition of the component, and re-renders.  This method is useful for testing your component\n     * in hard to achieve states, however should be used sparingly. If possible, you should utilize\n     * your component's external API in order to get it into whatever state you want to test, in order\n     * to be as accurate of a test as possible. This is not always practical, however.\n     *\n     * NOTE: can only be called on a wrapper instance that is also the root instance.\n     *\n     * @param {Object} state to merge\n     * @param {Function} cb - callback function\n     * @returns {ReactWrapper}\n     */\n\n  }, {\n    key: 'setState',\n    value: function () {\n      function setState(state) {\n        var _this8 = this;\n\n        var callback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;\n\n        if (this.instance() === null || this.getNodeInternal().nodeType !== 'class') {\n          throw new Error('ReactWrapper::setState() can only be called on class components');\n        }\n\n        if (arguments.length > 1 && typeof callback !== 'function') {\n          throw new TypeError('ReactWrapper::setState() expects a function as its second argument');\n        }\n\n        this.instance().setState(state, function () {\n          _this8.update();\n\n          if (callback) {\n            var adapter = (0, _getAdapter2['default'])(_this8[OPTIONS]);\n\n            var instance = _this8.instance();\n\n            if (adapter.invokeSetStateCallback) {\n              adapter.invokeSetStateCallback(instance, callback);\n            } else {\n              callback.call(instance);\n            }\n          }\n        });\n        return this;\n      }\n\n      return setState;\n    }()\n    /**\n     * A method that sets the context of the root component, and re-renders. Useful for when you are\n     * wanting to test how the component behaves over time with changing contexts.\n     *\n     * NOTE: can only be called on a wrapper instance that is also the root instance.\n     *\n     * @param {Object} context object\n     * @returns {ReactWrapper}\n     */\n\n  }, {\n    key: 'setContext',\n    value: function () {\n      function setContext(context) {\n        var _this9 = this;\n\n        if (this[ROOT] !== this) {\n          throw new Error('ReactWrapper::setContext() can only be called on the root');\n        }\n\n        if (!this[OPTIONS].context) {\n          throw new Error('ReactWrapper::setContext() can only be called on a wrapper that was originally passed a context option');\n        }\n\n        this[RENDERER].render(this[UNRENDERED], context, function () {\n          return _this9.update();\n        });\n        return this;\n      }\n\n      return setContext;\n    }()\n    /**\n     * Whether or not a given react element exists in the mount render tree.\n     *\n     * Example:\n     * ```\n     * const wrapper = mount(<MyComponent />);\n     * expect(wrapper.contains(<div className=\"foo bar\" />)).to.equal(true);\n     * ```\n     *\n     * @param {ReactElement|Array<ReactElement>} nodeOrNodes\n     * @returns {Boolean}\n     */\n\n  }, {\n    key: 'contains',\n    value: function () {\n      function contains(nodeOrNodes) {\n        var adapter = (0, _getAdapter2['default'])(this[OPTIONS]);\n        var predicate = Array.isArray(nodeOrNodes) ? function (other) {\n          return (0, _Utils.containsChildrenSubArray)(_Utils.nodeEqual, other, nodeOrNodes.map(function (node) {\n            return adapter.elementToNode(node);\n          }));\n        } : function (other) {\n          return (0, _Utils.nodeEqual)(adapter.elementToNode(nodeOrNodes), other);\n        };\n        return findWhereUnwrapped(this, predicate).length > 0;\n      }\n\n      return contains;\n    }()\n    /**\n     * Whether or not a given react element exists in the current render tree.\n     * It will determine if one of the wrappers element \"looks like\" the expected\n     * element by checking if all props of the expected element are present\n     * on the wrappers element and equals to each other.\n     *\n     * Example:\n     * ```\n     * // MyComponent outputs <div><div class=\"foo\">Hello</div></div>\n     * const wrapper = mount(<MyComponent />);\n     * expect(wrapper.containsMatchingElement(<div>Hello</div>)).to.equal(true);\n     * ```\n     *\n     * @param {ReactElement} node\n     * @returns {Boolean}\n     */\n\n  }, {\n    key: 'containsMatchingElement',\n    value: function () {\n      function containsMatchingElement(node) {\n        var rstNode = (0, _getAdapter2['default'])(this[OPTIONS]).elementToNode(node);\n\n        var predicate = function () {\n          function predicate(other) {\n            return (0, _Utils.nodeMatches)(rstNode, other, function (a, b) {\n              return a <= b;\n            });\n          }\n\n          return predicate;\n        }();\n\n        return findWhereUnwrapped(this, predicate).length > 0;\n      }\n\n      return containsMatchingElement;\n    }()\n    /**\n     * Whether or not all the given react elements exist in the current render tree.\n     * It will determine if one of the wrappers element \"looks like\" the expected\n     * element by checking if all props of the expected element are present\n     * on the wrappers element and equals to each other.\n     *\n     * Example:\n     * ```\n     * const wrapper = mount(<MyComponent />);\n     * expect(wrapper.containsAllMatchingElements([\n     *   <div>Hello</div>,\n     *   <div>Goodbye</div>,\n     * ])).to.equal(true);\n     * ```\n     *\n     * @param {Array<ReactElement>} nodes\n     * @returns {Boolean}\n     */\n\n  }, {\n    key: 'containsAllMatchingElements',\n    value: function () {\n      function containsAllMatchingElements(nodes) {\n        var _this10 = this;\n\n        if (!Array.isArray(nodes)) {\n          throw new TypeError('nodes should be an Array');\n        }\n\n        return nodes.every(function (node) {\n          return _this10.containsMatchingElement(node);\n        });\n      }\n\n      return containsAllMatchingElements;\n    }()\n    /**\n     * Whether or not one of the given react elements exists in the current render tree.\n     * It will determine if one of the wrappers element \"looks like\" the expected\n     * element by checking if all props of the expected element are present\n     * on the wrappers element and equals to each other.\n     *\n     * Example:\n     * ```\n     * const wrapper = mount(<MyComponent />);\n     * expect(wrapper.containsAnyMatchingElements([\n     *   <div>Hello</div>,\n     *   <div>Goodbye</div>,\n     * ])).to.equal(true);\n     * ```\n     *\n     * @param {Array<ReactElement>} nodes\n     * @returns {Boolean}\n     */\n\n  }, {\n    key: 'containsAnyMatchingElements',\n    value: function () {\n      function containsAnyMatchingElements(nodes) {\n        var _this11 = this;\n\n        return Array.isArray(nodes) && nodes.some(function (node) {\n          return _this11.containsMatchingElement(node);\n        });\n      }\n\n      return containsAnyMatchingElements;\n    }()\n    /**\n     * Whether or not a given react element exists in the render tree.\n     *\n     * Example:\n     * ```\n     * const wrapper = mount(<MyComponent />);\n     * expect(wrapper.contains(<div className=\"foo bar\" />)).to.equal(true);\n     * ```\n     *\n     * @param {ReactElement} node\n     * @returns {Boolean}\n     */\n\n  }, {\n    key: 'equals',\n    value: function () {\n      function equals(node) {\n        var _this12 = this;\n\n        return this.single('equals', function () {\n          return (0, _Utils.nodeEqual)(_this12.getNodeInternal(), node);\n        });\n      }\n\n      return equals;\n    }()\n    /**\n     * Whether or not a given react element matches the render tree.\n     * Match is based on the expected element and not on wrapper root node.\n     * It will determine if the wrapper root node \"looks like\" the expected\n     * element by checking if all props of the expected element are present\n     * on the wrapper root node and equals to each other.\n     *\n     * Example:\n     * ```\n     * // MyComponent outputs <div class=\"foo\">Hello</div>\n     * const wrapper = mount(<MyComponent />);\n     * expect(wrapper.matchesElement(<div>Hello</div>)).to.equal(true);\n     * ```\n     *\n     * @param {ReactElement} node\n     * @returns {Boolean}\n     */\n\n  }, {\n    key: 'matchesElement',\n    value: function () {\n      function matchesElement(node) {\n        var _this13 = this;\n\n        return this.single('matchesElement', function () {\n          var adapter = (0, _getAdapter2['default'])(_this13[OPTIONS]);\n          var rstNode = adapter.elementToNode(node);\n          return (0, _Utils.nodeMatches)(rstNode, _this13.getNodeInternal(), function (a, b) {\n            return a <= b;\n          });\n        });\n      }\n\n      return matchesElement;\n    }()\n    /**\n     * Finds every node in the render tree of the current wrapper that matches the provided selector.\n     *\n     * @param {EnzymeSelector} selector\n     * @returns {ReactWrapper}\n     */\n\n  }, {\n    key: 'find',\n    value: function () {\n      function find(selector) {\n        return this.wrap((0, _selectors.reduceTreesBySelector)(selector, this.getNodesInternal()));\n      }\n\n      return find;\n    }()\n    /**\n     * Returns whether or not current node matches a provided selector.\n     *\n     * NOTE: can only be called on a wrapper of a single node.\n     *\n     * @param {EnzymeSelector} selector\n     * @returns {boolean}\n     */\n\n  }, {\n    key: 'is',\n    value: function () {\n      function is(selector) {\n        var predicate = (0, _selectors.buildPredicate)(selector);\n        return this.single('is', function (n) {\n          return predicate(n);\n        });\n      }\n\n      return is;\n    }()\n    /**\n     * Returns true if the component rendered nothing, i.e., null or false.\n     *\n     * @returns {boolean}\n     */\n\n  }, {\n    key: 'isEmptyRender',\n    value: function () {\n      function isEmptyRender() {\n        var nodes = this.getNodeInternal();\n        return (0, _Utils.renderedDive)(nodes);\n      }\n\n      return isEmptyRender;\n    }()\n    /**\n     * Returns a new wrapper instance with only the nodes of the current wrapper instance that match\n     * the provided predicate function.\n     *\n     * @param {Function} predicate\n     * @returns {ReactWrapper}\n     */\n\n  }, {\n    key: 'filterWhere',\n    value: function () {\n      function filterWhere(predicate) {\n        var _this14 = this;\n\n        return filterWhereUnwrapped(this, function (n) {\n          return predicate(_this14.wrap(n));\n        });\n      }\n\n      return filterWhere;\n    }()\n    /**\n     * Returns a new wrapper instance with only the nodes of the current wrapper instance that match\n     * the provided selector.\n     *\n     * @param {EnzymeSelector} selector\n     * @returns {ReactWrapper}\n     */\n\n  }, {\n    key: 'filter',\n    value: function () {\n      function filter(selector) {\n        var predicate = (0, _selectors.buildPredicate)(selector);\n        return filterWhereUnwrapped(this, predicate);\n      }\n\n      return filter;\n    }()\n    /**\n     * Returns a new wrapper instance with only the nodes of the current wrapper that did not match\n     * the provided selector. Essentially the inverse of `filter`.\n     *\n     * @param {EnzymeSelector} selector\n     * @returns {ReactWrapper}\n     */\n\n  }, {\n    key: 'not',\n    value: function () {\n      function not(selector) {\n        var predicate = (0, _selectors.buildPredicate)(selector);\n        return filterWhereUnwrapped(this, function (n) {\n          return !predicate(n);\n        });\n      }\n\n      return not;\n    }()\n    /**\n     * Returns a string of the rendered text of the current render tree.  This function should be\n     * looked at with skepticism if being used to test what the actual HTML output of the component\n     * will be. If that is what you would like to test, use enzyme's `render` function instead.\n     *\n     * NOTE: can only be called on a wrapper of a single node.\n     *\n     * @returns {String}\n     */\n\n  }, {\n    key: 'text',\n    value: function () {\n      function text() {\n        var adapter = (0, _getAdapter2['default'])(this[OPTIONS]);\n        return this.single('text', function (n) {\n          return (0, _RSTTraversal.getTextFromHostNodes)(n, adapter);\n        });\n      }\n\n      return text;\n    }()\n    /**\n     * Returns the HTML of the node.\n     *\n     * NOTE: can only be called on a wrapper of a single node.\n     *\n     * @returns {String}\n     */\n\n  }, {\n    key: 'html',\n    value: function () {\n      function html() {\n        var adapter = (0, _getAdapter2['default'])(this[OPTIONS]);\n        return this.single('html', function (n) {\n          return (0, _RSTTraversal.getHTMLFromHostNodes)(n, adapter);\n        });\n      }\n\n      return html;\n    }()\n    /**\n     * Returns the current node rendered to HTML and wrapped in a CheerioWrapper.\n     *\n     * NOTE: can only be called on a wrapper of a single node.\n     *\n     * @returns {CheerioWrapper}\n     */\n\n  }, {\n    key: 'render',\n    value: function () {\n      function render() {\n        var html = this.html();\n        return (0, _Utils.loadCheerioRoot)(html);\n      }\n\n      return render;\n    }()\n    /**\n     * Used to simulate events. Pass an eventname and (optionally) event arguments. This method of\n     * testing events should be met with some skepticism.\n     *\n     * @param {String} event\n     * @param {Object} mock (optional)\n     * @returns {ReactWrapper}\n     */\n\n  }, {\n    key: 'simulate',\n    value: function () {\n      function simulate(event) {\n        var _this15 = this;\n\n        var mock = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        return this.single('simulate', function (n) {\n          _this15[RENDERER].simulateEvent(n, event, mock);\n\n          _this15[ROOT].update();\n\n          return _this15;\n        });\n      }\n\n      return simulate;\n    }()\n    /**\n     * Used to simulate throwing a rendering error. Pass an error to throw.\n     *\n     * @param {String} error\n     * @returns {ReactWrapper}\n     */\n\n  }, {\n    key: 'simulateError',\n    value: function () {\n      function simulateError(error) {\n        var _this16 = this;\n\n        if (this[ROOT] === this) {\n          throw new Error('ReactWrapper::simulateError() may not be called on the root');\n        }\n\n        return this.single('simulateError', function (thisNode) {\n          if (thisNode.nodeType === 'host') {\n            throw new Error('ReactWrapper::simulateError() can only be called on custom components');\n          }\n\n          var renderer = _this16[RENDERER];\n\n          if (typeof renderer.simulateError !== 'function') {\n            throw new TypeError('your adapter does not support `simulateError`. Try upgrading it!');\n          }\n\n          var rootNode = getRootNodeInternal(_this16);\n          var nodeHierarchy = [thisNode].concat(nodeParents(_this16, thisNode));\n          renderer.simulateError(nodeHierarchy, rootNode, error);\n\n          _this16[ROOT].update();\n\n          return _this16;\n        });\n      }\n\n      return simulateError;\n    }()\n    /**\n     * Returns the props hash for the root node of the wrapper.\n     *\n     * NOTE: can only be called on a wrapper of a single node.\n     *\n     * @returns {Object}\n     */\n\n  }, {\n    key: 'props',\n    value: function () {\n      function props() {\n        return this.single('props', _RSTTraversal.propsOfNode);\n      }\n\n      return props;\n    }()\n    /**\n     * Returns the state hash for the root node of the wrapper. Optionally pass in a prop name and it\n     * will return just that value.\n     *\n     * NOTE: can only be called on a wrapper of a single node.\n     *\n     * @param {String} name (optional)\n     * @returns {*}\n     */\n\n  }, {\n    key: 'state',\n    value: function () {\n      function state(name) {\n        var _this17 = this;\n\n        var thisNode = this[ROOT] === this ? this[RENDERER].getNode() : this.getNodeInternal();\n\n        if (this.instance() === null || thisNode.nodeType !== 'class') {\n          throw new Error('ReactWrapper::state() can only be called on class components');\n        }\n\n        var _state = this.single('state', function () {\n          return _this17.instance().state;\n        });\n\n        if (typeof name !== 'undefined') {\n          if (_state == null) {\n            throw new TypeError('ReactWrapper::state(\"' + String(name) + '\") requires that `state` not be `null` or `undefined`');\n          }\n\n          return _state[name];\n        }\n\n        return _state;\n      }\n\n      return state;\n    }()\n    /**\n     * Returns the context hash for the root node of the wrapper.\n     * Optionally pass in a prop name and it will return just that value.\n     *\n     * NOTE: can only be called on a wrapper of a single node.\n     *\n     * @param {String} name (optional)\n     * @returns {*}\n     */\n\n  }, {\n    key: 'context',\n    value: function () {\n      function context(name) {\n        var _this18 = this;\n\n        if (this[ROOT] !== this) {\n          throw new Error('ReactWrapper::context() can only be called on the root');\n        }\n\n        var instance = this.single('context', function () {\n          return _this18.instance();\n        });\n\n        if (instance === null) {\n          throw new Error('ReactWrapper::context() can only be called on components with instances');\n        }\n\n        var _context = instance.context;\n\n        if (typeof name !== 'undefined') {\n          return _context[name];\n        }\n\n        return _context;\n      }\n\n      return context;\n    }()\n    /**\n     * Returns a new wrapper with all of the children of the current wrapper.\n     *\n     * @param {EnzymeSelector} [selector]\n     * @returns {ReactWrapper}\n     */\n\n  }, {\n    key: 'children',\n    value: function () {\n      function children(selector) {\n        var allChildren = this.flatMap(function (n) {\n          return (0, _RSTTraversal.childrenOfNode)(n.getNodeInternal());\n        });\n        return selector ? allChildren.filter(selector) : allChildren;\n      }\n\n      return children;\n    }()\n    /**\n     * Returns a new wrapper with a specific child\n     *\n     * @param {Number} [index]\n     * @returns {ReactWrapper}\n     */\n\n  }, {\n    key: 'childAt',\n    value: function () {\n      function childAt(index) {\n        var _this19 = this;\n\n        return this.single('childAt', function () {\n          return _this19.children().at(index);\n        });\n      }\n\n      return childAt;\n    }()\n    /**\n     * Returns a wrapper around all of the parents/ancestors of the wrapper. Does not include the node\n     * in the current wrapper.\n     *\n     * NOTE: can only be called on a wrapper of a single node.\n     *\n     * @param {EnzymeSelector} [selector]\n     * @returns {ReactWrapper}\n     */\n\n  }, {\n    key: 'parents',\n    value: function () {\n      function parents(selector) {\n        var _this20 = this;\n\n        return this.single('parents', function (n) {\n          var allParents = _this20.wrap(nodeParents(_this20, n));\n\n          return selector ? allParents.filter(selector) : allParents;\n        });\n      }\n\n      return parents;\n    }()\n    /**\n     * Returns a wrapper around the immediate parent of the current node.\n     *\n     * @returns {ReactWrapper}\n     */\n\n  }, {\n    key: 'parent',\n    value: function () {\n      function parent() {\n        return this.flatMap(function (n) {\n          return [n.parents().get(0)];\n        });\n      }\n\n      return parent;\n    }()\n    /**\n     *\n     * @param {EnzymeSelector} selector\n     * @returns {ReactWrapper}\n     */\n\n  }, {\n    key: 'closest',\n    value: function () {\n      function closest(selector) {\n        if (this.is(selector)) {\n          return this;\n        }\n\n        var matchingAncestors = this.parents().filter(selector);\n        return matchingAncestors.length > 0 ? matchingAncestors.first() : this.findWhere(function () {\n          return false;\n        });\n      }\n\n      return closest;\n    }()\n    /**\n     * Returns the value of  prop with the given name of the root node.\n     *\n     * @param {String} propName\n     * @returns {*}\n     */\n\n  }, {\n    key: 'prop',\n    value: function () {\n      function prop(propName) {\n        return this.props()[propName];\n      }\n\n      return prop;\n    }()\n    /**\n     * Used to invoke a function prop.\n     * Will invoke an function prop and return its value.\n     *\n     * @param {String} propName\n     * @returns {Any}\n     */\n\n  }, {\n    key: 'invoke',\n    value: function () {\n      function invoke(propName) {\n        var _this21 = this;\n\n        return this.single('invoke', function () {\n          var handler = _this21.prop(propName);\n\n          if (typeof handler !== 'function') {\n            throw new TypeError('ReactWrapper::invoke() requires the name of a prop whose value is a function');\n          }\n\n          return function () {\n            for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n              args[_key] = arguments[_key];\n            }\n\n            var response = typeof _this21[RENDERER].wrapInvoke === 'function' ? _this21[RENDERER].wrapInvoke(function () {\n              return handler.apply(undefined, args);\n            }) : handler.apply(undefined, args);\n\n            _this21[ROOT].update();\n\n            return response;\n          };\n        });\n      }\n\n      return invoke;\n    }()\n    /**\n     * Returns a wrapper of the node rendered by the provided render prop.\n     *\n     * @param {String} propName\n     * @returns {Function}\n     */\n\n  }, {\n    key: 'renderProp',\n    value: function () {\n      function renderProp(propName) {\n        var _this22 = this;\n\n        var adapter = (0, _getAdapter2['default'])(this[OPTIONS]);\n\n        if (typeof adapter.wrap !== 'function') {\n          throw new RangeError('your adapter does not support `wrap`. Try upgrading it!');\n        }\n\n        return this.single('renderProp', function (n) {\n          if (n.nodeType === 'host') {\n            throw new TypeError('ReactWrapper::renderProp() can only be called on custom components');\n          }\n\n          if (typeof propName !== 'string') {\n            throw new TypeError('ReactWrapper::renderProp(): `propName` must be a string');\n          }\n\n          var props = _this22.props();\n\n          if (!(0, _has2['default'])(props, propName)) {\n            throw new Error('ReactWrapper::renderProp(): no prop called \\u201C' + String(propName) + '\\u201C found');\n          }\n\n          var propValue = props[propName];\n\n          if (typeof propValue !== 'function') {\n            throw new TypeError('ReactWrapper::renderProp(): expected prop \\u201C' + String(propName) + '\\u201C to contain a function, but it holds \\u201C' + (typeof propValue === 'undefined' ? 'undefined' : _typeof(propValue)) + '\\u201C');\n          }\n\n          return function () {\n            var element = propValue.apply(undefined, arguments);\n            var wrapped = adapter.wrap(element);\n            return _this22.wrap(wrapped, null, _this22[OPTIONS]);\n          };\n        });\n      }\n\n      return renderProp;\n    }()\n    /**\n     * Returns the key assigned to the current node.\n     *\n     * @returns {String}\n     */\n\n  }, {\n    key: 'key',\n    value: function () {\n      function key() {\n        return this.single('key', function (n) {\n          return n.key === undefined ? null : n.key;\n        });\n      }\n\n      return key;\n    }()\n    /**\n     * Returns the type of the root node of this wrapper. If it's a composite component, this will be\n     * the component constructor. If it's native DOM node, it will be a string.\n     *\n     * @returns {String|Function}\n     */\n\n  }, {\n    key: 'type',\n    value: function () {\n      function type() {\n        return this.single('type', function (n) {\n          return (0, _Utils.typeOfNode)(n);\n        });\n      }\n\n      return type;\n    }()\n    /**\n     * Returns the name of the root node of this wrapper.\n     *\n     * In order of precedence => type.displayName -> type.name -> type.\n     *\n     * @returns {String}\n     */\n\n  }, {\n    key: 'name',\n    value: function () {\n      function name() {\n        var adapter = (0, _getAdapter2['default'])(this[OPTIONS]);\n        return this.single('name', function (n) {\n          return adapter.displayNameOfNode ? adapter.displayNameOfNode(n) : (0, _Utils.displayNameOfNode)(n);\n        });\n      }\n\n      return name;\n    }()\n    /**\n     * Returns whether or not the current root node has the given class name or not.\n     *\n     * NOTE: can only be called on a wrapper of a single node.\n     *\n     * @param {String} className\n     * @returns {Boolean}\n     */\n\n  }, {\n    key: 'hasClass',\n    value: function () {\n      function hasClass(className) {\n        if (typeof className === 'string' && className.indexOf('.') !== -1) {\n          // eslint-disable-next-line no-console\n          console.warn('It looks like you\\'re calling `ReactWrapper::hasClass()` with a CSS selector. hasClass() expects a class name, not a CSS selector.');\n        }\n\n        return this.single('hasClass', function (n) {\n          return (0, _RSTTraversal.hasClassName)(n, className);\n        });\n      }\n\n      return hasClass;\n    }()\n    /**\n     * Iterates through each node of the current wrapper and executes the provided function with a\n     * wrapper around the corresponding node passed in as the first argument.\n     *\n     * @param {Function} fn\n     * @returns {ReactWrapper}\n     */\n\n  }, {\n    key: 'forEach',\n    value: function () {\n      function forEach(fn) {\n        var _this23 = this;\n\n        this.getNodesInternal().forEach(function (n, i) {\n          return fn.call(_this23, _this23.wrap(n), i);\n        });\n        return this;\n      }\n\n      return forEach;\n    }()\n    /**\n     * Maps the current array of nodes to another array. Each node is passed in as a `ReactWrapper`\n     * to the map function.\n     *\n     * @param {Function} fn\n     * @returns {Array}\n     */\n\n  }, {\n    key: 'map',\n    value: function () {\n      function map(fn) {\n        var _this24 = this;\n\n        return this.getNodesInternal().map(function (n, i) {\n          return fn.call(_this24, _this24.wrap(n), i);\n        });\n      }\n\n      return map;\n    }()\n    /**\n     * Reduces the current array of nodes to another array.\n     * Each node is passed in as a `ShallowWrapper` to the reducer function.\n     *\n     * @param {Function} fn - the reducer function\n     * @param {*} initialValue - the initial value\n     * @returns {*}\n     */\n\n  }, {\n    key: 'reduce',\n    value: function () {\n      function reduce(fn) {\n        var _this25 = this;\n\n        var initialValue = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;\n\n        if (arguments.length > 1) {\n          return this.getNodesInternal().reduce(function (accum, n, i) {\n            return fn.call(_this25, accum, _this25.wrap(n), i);\n          }, initialValue);\n        }\n\n        return this.getNodesInternal().reduce(function (accum, n, i) {\n          return fn.call(_this25, i === 1 ? _this25.wrap(accum) : accum, _this25.wrap(n), i);\n        });\n      }\n\n      return reduce;\n    }()\n    /**\n     * Reduces the current array of nodes to another array, from right to left. Each node is passed\n     * in as a `ShallowWrapper` to the reducer function.\n     *\n     * @param {Function} fn - the reducer function\n     * @param {*} initialValue - the initial value\n     * @returns {*}\n     */\n\n  }, {\n    key: 'reduceRight',\n    value: function () {\n      function reduceRight(fn) {\n        var _this26 = this;\n\n        var initialValue = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;\n\n        if (arguments.length > 1) {\n          return this.getNodesInternal().reduceRight(function (accum, n, i) {\n            return fn.call(_this26, accum, _this26.wrap(n), i);\n          }, initialValue);\n        }\n\n        return this.getNodesInternal().reduceRight(function (accum, n, i) {\n          return fn.call(_this26, i === 1 ? _this26.wrap(accum) : accum, _this26.wrap(n), i);\n        });\n      }\n\n      return reduceRight;\n    }()\n    /**\n     * Returns a new wrapper with a subset of the nodes of the original wrapper, according to the\n     * rules of `Array#slice`.\n     *\n     * @param {Number} begin\n     * @param {Number} end\n     * @returns {ShallowWrapper}\n     */\n\n  }, {\n    key: 'slice',\n    value: function () {\n      function slice(begin, end) {\n        return this.wrap(this.getNodesInternal().slice(begin, end));\n      }\n\n      return slice;\n    }()\n    /**\n     * Returns whether or not any of the nodes in the wrapper match the provided selector.\n     *\n     * @param {EnzymeSelector} selector\n     * @returns {Boolean}\n     */\n\n  }, {\n    key: 'some',\n    value: function () {\n      function some(selector) {\n        if (this[ROOT] === this) {\n          throw new Error('ReactWrapper::some() can not be called on the root');\n        }\n\n        var predicate = (0, _selectors.buildPredicate)(selector);\n        return this.getNodesInternal().some(predicate);\n      }\n\n      return some;\n    }()\n    /**\n     * Returns whether or not any of the nodes in the wrapper pass the provided predicate function.\n     *\n     * @param {Function} predicate\n     * @returns {Boolean}\n     */\n\n  }, {\n    key: 'someWhere',\n    value: function () {\n      function someWhere(predicate) {\n        var _this27 = this;\n\n        return this.getNodesInternal().some(function (n, i) {\n          return predicate.call(_this27, _this27.wrap(n), i);\n        });\n      }\n\n      return someWhere;\n    }()\n    /**\n     * Returns whether or not all of the nodes in the wrapper match the provided selector.\n     *\n     * @param {EnzymeSelector} selector\n     * @returns {Boolean}\n     */\n\n  }, {\n    key: 'every',\n    value: function () {\n      function every(selector) {\n        var predicate = (0, _selectors.buildPredicate)(selector);\n        return this.getNodesInternal().every(predicate);\n      }\n\n      return every;\n    }()\n    /**\n     * Returns whether or not any of the nodes in the wrapper pass the provided predicate function.\n     *\n     * @param {Function} predicate\n     * @returns {Boolean}\n     */\n\n  }, {\n    key: 'everyWhere',\n    value: function () {\n      function everyWhere(predicate) {\n        var _this28 = this;\n\n        return this.getNodesInternal().every(function (n, i) {\n          return predicate.call(_this28, _this28.wrap(n), i);\n        });\n      }\n\n      return everyWhere;\n    }()\n    /**\n     * Utility method used to create new wrappers with a mapping function that returns an array of\n     * nodes in response to a single node wrapper. The returned wrapper is a single wrapper around\n     * all of the mapped nodes flattened (and de-duplicated).\n     *\n     * @param {Function} fn\n     * @returns {ReactWrapper}\n     */\n\n  }, {\n    key: 'flatMap',\n    value: function () {\n      function flatMap(fn) {\n        var _this29 = this;\n\n        var nodes = this.getNodesInternal().map(function (n, i) {\n          return fn.call(_this29, _this29.wrap(n), i);\n        });\n        var flattened = (0, _arrayPrototype2['default'])(nodes, 1);\n        return this.wrap(flattened.filter(Boolean));\n      }\n\n      return flatMap;\n    }()\n    /**\n     * Finds all nodes in the current wrapper nodes' render trees that match the provided predicate\n     * function.\n     *\n     * @param {Function} predicate\n     * @returns {ReactWrapper}\n     */\n\n  }, {\n    key: 'findWhere',\n    value: function () {\n      function findWhere(predicate) {\n        var _this30 = this;\n\n        return findWhereUnwrapped(this, function (n) {\n          var node = _this30.wrap(n);\n\n          return node.length > 0 && predicate(node);\n        });\n      }\n\n      return findWhere;\n    }()\n    /**\n     * Returns the node at a given index of the current wrapper.\n     *\n     * @param {Number} index\n     * @returns {ReactElement}\n     */\n\n  }, {\n    key: 'get',\n    value: function () {\n      function get(index) {\n        return this.getElements()[index];\n      }\n\n      return get;\n    }()\n    /**\n     * Returns a wrapper around the node at a given index of the current wrapper.\n     *\n     * @param {Number} index\n     * @returns {ReactWrapper}\n     */\n\n  }, {\n    key: 'at',\n    value: function () {\n      function at(index) {\n        var nodes = this.getNodesInternal();\n\n        if (index < nodes.length) {\n          return this.wrap(nodes[index]);\n        }\n\n        return this.wrap([]);\n      }\n\n      return at;\n    }()\n    /**\n     * Returns a wrapper around the first node of the current wrapper.\n     *\n     * @returns {ReactWrapper}\n     */\n\n  }, {\n    key: 'first',\n    value: function () {\n      function first() {\n        return this.at(0);\n      }\n\n      return first;\n    }()\n    /**\n     * Returns a wrapper around the last node of the current wrapper.\n     *\n     * @returns {ReactWrapper}\n     */\n\n  }, {\n    key: 'last',\n    value: function () {\n      function last() {\n        return this.at(this.length - 1);\n      }\n\n      return last;\n    }()\n    /**\n     * Delegates to exists()\n     *\n     * @returns {boolean}\n     */\n\n  }, {\n    key: 'isEmpty',\n    value: function () {\n      function isEmpty() {\n        // eslint-disable-next-line no-console\n        console.warn('Enzyme::Deprecated method isEmpty() called, use exists() instead.');\n        return !this.exists();\n      }\n\n      return isEmpty;\n    }()\n    /**\n     * Returns true if the current wrapper has nodes. False otherwise.\n     * If called with a selector it returns `.find(selector).exists()` instead.\n     *\n     * @param {EnzymeSelector} selector (optional)\n     * @returns {boolean}\n     */\n\n  }, {\n    key: 'exists',\n    value: function () {\n      function exists() {\n        var selector = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n        return arguments.length > 0 ? this.find(selector).exists() : this.length > 0;\n      }\n\n      return exists;\n    }()\n    /**\n     * Utility method that throws an error if the current instance has a length other than one.\n     * This is primarily used to enforce that certain methods are only run on a wrapper when it is\n     * wrapping a single node.\n     *\n     * @param {Function} fn\n     * @returns {*}\n     */\n\n  }, {\n    key: 'single',\n    value: function () {\n      function single(name, fn) {\n        var fnName = typeof name === 'string' ? name : 'unknown';\n        var callback = typeof fn === 'function' ? fn : name;\n\n        if (this.length !== 1) {\n          throw new Error('Method \\u201C' + fnName + '\\u201D is meant to be run on 1 node. ' + String(this.length) + ' found instead.');\n        }\n\n        return callback.call(this, this.getNodeInternal());\n      }\n\n      return single;\n    }()\n    /**\n     * Helpful utility method to create a new wrapper with the same root as the current wrapper, with\n     * any nodes passed in as the first parameter automatically wrapped.\n     *\n     * @param {ReactWrapper|ReactElement|Array<ReactElement>} node\n     * @returns {ReactWrapper}\n     */\n\n  }, {\n    key: 'wrap',\n    value: function () {\n      function wrap(node) {\n        var root = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this[ROOT];\n\n        if (node instanceof ReactWrapper) {\n          return node;\n        }\n\n        for (var _len2 = arguments.length, args = Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {\n          args[_key2 - 2] = arguments[_key2];\n        }\n\n        return new (Function.prototype.bind.apply(ReactWrapper, [null].concat([node, root], args)))();\n      }\n\n      return wrap;\n    }()\n    /**\n     * Returns an HTML-like string of the shallow render for debugging purposes.\n     *\n     * @param {Object} [options] - Property bag of additional options.\n     * @param {boolean} [options.ignoreProps] - if true, props are omitted from the string.\n     * @param {boolean} [options.verbose] - if true, arrays and objects to be verbosely printed.\n     * @returns {String}\n     */\n\n  }, {\n    key: 'debug',\n    value: function () {\n      function debug() {\n        var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n        return (0, _Debug.debugNodes)(this.getNodesInternal(), options);\n      }\n\n      return debug;\n    }()\n    /**\n     * Invokes intercepter and returns itself. intercepter is called with itself.\n     * This is helpful when debugging nodes in method chains.\n     * @param fn\n     * @returns {ReactWrapper}\n     */\n\n  }, {\n    key: 'tap',\n    value: function () {\n      function tap(intercepter) {\n        intercepter(this);\n        return this;\n      }\n\n      return tap;\n    }()\n    /**\n     * Detaches the react tree from the DOM. Runs `ReactDOM.unmountComponentAtNode()` under the hood.\n     *\n     * This method will most commonly be used as a \"cleanup\" method if you decide to use the\n     * `attachTo` option in `mount(node, options)`.\n     *\n     * The method is intentionally not \"fluent\" (in that it doesn't return `this`) because you should\n     * not be doing anything with this wrapper after this method is called.\n     */\n\n  }, {\n    key: 'detach',\n    value: function () {\n      function detach() {\n        if (this[ROOT] !== this) {\n          throw new Error('ReactWrapper::detach() can only be called on the root');\n        }\n\n        if (!this[OPTIONS].attachTo) {\n          throw new Error('ReactWrapper::detach() can only be called on when the `attachTo` option was passed into `mount()`.');\n        }\n\n        this[RENDERER].unmount();\n      }\n\n      return detach;\n    }()\n    /**\n     * Strips out all the not host-nodes from the list of nodes\n     *\n     * This method is useful if you want to check for the presence of host nodes\n     * (actually rendered HTML elements) ignoring the React nodes.\n     */\n\n  }, {\n    key: 'hostNodes',\n    value: function () {\n      function hostNodes() {\n        return this.filterWhere(function (n) {\n          return typeof n.type() === 'string';\n        });\n      }\n\n      return hostNodes;\n    }()\n  }]);\n\n  return ReactWrapper;\n}();\n/**\n * A *special* \"root\" wrapper that represents the component passed as `wrappingComponent`.\n * It is linked to the primary root such that updates to it will update the primary,\n * and vice versa.\n *\n * @class WrappingComponentWrapper\n */\n\n\nvar WrappingComponentWrapper = function (_ReactWrapper) {\n  _inherits(WrappingComponentWrapper, _ReactWrapper);\n  /* eslint-disable class-methods-use-this */\n\n\n  function WrappingComponentWrapper(root, renderer) {\n    _classCallCheck(this, WrappingComponentWrapper);\n\n    var _this31 = _possibleConstructorReturn(this, (WrappingComponentWrapper.__proto__ || Object.getPrototypeOf(WrappingComponentWrapper)).call(this, renderer.getNode(), root));\n\n    (0, _Utils.privateSet)(_this31, ROOT, _this31);\n    (0, _Utils.privateSet)(_this31, RENDERER, renderer);\n\n    _this31[LINKED_ROOTS].push(root);\n\n    return _this31;\n  }\n\n  _createClass(WrappingComponentWrapper, [{\n    key: 'getWrappingComponent',\n    value: function () {\n      function getWrappingComponent() {\n        throw new TypeError('ReactWrapper::getWrappingComponent() can only be called on the root');\n      }\n\n      return getWrappingComponent;\n    }()\n  }]);\n\n  return WrappingComponentWrapper;\n}(ReactWrapper);\n\nif (_Utils.ITERATOR_SYMBOL) {\n  Object.defineProperty(ReactWrapper.prototype, _Utils.ITERATOR_SYMBOL, {\n    configurable: true,\n    value: function () {\n      function iterator() {\n        var _ref;\n\n        var iter = this[NODES][_Utils.ITERATOR_SYMBOL]();\n\n        var adapter = (0, _getAdapter2['default'])(this[OPTIONS]);\n        return _ref = {}, _defineProperty(_ref, _Utils.ITERATOR_SYMBOL, function () {\n          return this;\n        }), _defineProperty(_ref, 'next', function () {\n          function next() {\n            var next = iter.next();\n\n            if (next.done) {\n              return {\n                done: true\n              };\n            }\n\n            return {\n              done: false,\n              value: adapter.nodeToElement(next.value)\n            };\n          }\n\n          return next;\n        }()), _ref;\n      }\n\n      return iterator;\n    }()\n  });\n}\n\nfunction privateWarning(prop, extraMessage) {\n  Object.defineProperty(ReactWrapper.prototype, prop, {\n    get: function () {\n      function get() {\n        throw new Error('\\n        Attempted to access ReactWrapper::' + String(prop) + ', which was previously a private property on\\n        Enzyme ReactWrapper instances, but is no longer and should not be relied upon.\\n        ' + String(extraMessage) + '\\n      ');\n      }\n\n      return get;\n    }(),\n    enumerable: false,\n    configurable: false\n  });\n}\n\nprivateWarning('node', 'Consider using the getElement() method instead.');\nprivateWarning('nodes', 'Consider using the getElements() method instead.');\nprivateWarning('renderer', '');\nprivateWarning('options', '');\nprivateWarning('complexSelector', '');\nexports['default'] = ReactWrapper; //# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9SZWFjdFdyYXBwZXIuanMiXSwibmFtZXMiOlsiTk9ERSIsIk5PREVTIiwiUkVOREVSRVIiLCJVTlJFTkRFUkVEIiwiUk9PVCIsIk9QVElPTlMiLCJST09UX05PREVTIiwiV1JBUFBJTkdfQ09NUE9ORU5UIiwiTElOS0VEX1JPT1RTIiwiVVBEQVRFRF9CWSIsImZpbmRXaGVyZVVud3JhcHBlZCIsIndyYXBwZXIiLCJwcmVkaWNhdGUiLCJmaWx0ZXIiLCJ0cmVlRmlsdGVyIiwiZmxhdE1hcCIsIm4iLCJnZXROb2RlSW50ZXJuYWwiLCJmaWx0ZXJXaGVyZVVud3JhcHBlZCIsIndyYXAiLCJnZXROb2Rlc0ludGVybmFsIiwiQm9vbGVhbiIsImdldFJvb3ROb2RlSW50ZXJuYWwiLCJsZW5ndGgiLCJFcnJvciIsIm5vZGVQYXJlbnRzIiwibm9kZSIsInByaXZhdGVTZXROb2RlcyIsIm5vZGVzIiwiQXJyYXkiLCJpc0FycmF5IiwiUmVhY3RXcmFwcGVyIiwicm9vdCIsInBhc3NlZE9wdGlvbnMiLCJnbG9iYWwiLCJ3aW5kb3ciLCJkb2N1bWVudCIsIm9wdGlvbnMiLCJhZGFwdGVyIiwiaXNWYWxpZEVsZW1lbnQiLCJUeXBlRXJyb3IiLCJyZW5kZXJlciIsImNyZWF0ZVJlbmRlcmVyIiwibW9kZSIsInJlbmRlciIsImNvbnRleHQiLCJnZXROb2RlIiwid3JhcHBpbmdDb21wb25lbnQiLCJnZXRXcmFwcGluZ0NvbXBvbmVudFJlbmRlcmVyIiwiV3JhcHBpbmdDb21wb25lbnRXcmFwcGVyIiwicHVzaCIsInNpbmdsZSIsIm5vZGVUb0VsZW1lbnQiLCJtYXAiLCJub2RlVG9Ib3N0Tm9kZSIsInJlZm5hbWUiLCJpbnN0YW5jZSIsInJlZnMiLCJ1cGRhdGUiLCJmb3JFYWNoIiwibGlua2VkUm9vdCIsInVubW91bnQiLCJwcm9wcyIsImNhbGxiYWNrIiwidW5kZWZpbmVkIiwiYXJndW1lbnRzIiwic3RhdGUiLCJub2RlVHlwZSIsInNldFN0YXRlIiwiaW52b2tlU2V0U3RhdGVDYWxsYmFjayIsImNhbGwiLCJub2RlT3JOb2RlcyIsIm90aGVyIiwibm9kZUVxdWFsIiwiZWxlbWVudFRvTm9kZSIsInJzdE5vZGUiLCJhIiwiYiIsImV2ZXJ5IiwiY29udGFpbnNNYXRjaGluZ0VsZW1lbnQiLCJzb21lIiwic2VsZWN0b3IiLCJodG1sIiwiZXZlbnQiLCJtb2NrIiwic2ltdWxhdGVFdmVudCIsImVycm9yIiwidGhpc05vZGUiLCJzaW11bGF0ZUVycm9yIiwicm9vdE5vZGUiLCJub2RlSGllcmFyY2h5IiwiY29uY2F0IiwicHJvcHNPZk5vZGUiLCJuYW1lIiwiX3N0YXRlIiwiX2NvbnRleHQiLCJhbGxDaGlsZHJlbiIsImluZGV4IiwiY2hpbGRyZW4iLCJhdCIsImFsbFBhcmVudHMiLCJwYXJlbnRzIiwiZ2V0IiwiaXMiLCJtYXRjaGluZ0FuY2VzdG9ycyIsImZpcnN0IiwiZmluZFdoZXJlIiwicHJvcE5hbWUiLCJoYW5kbGVyIiwicHJvcCIsImFyZ3MiLCJyZXNwb25zZSIsIndyYXBJbnZva2UiLCJSYW5nZUVycm9yIiwicHJvcFZhbHVlIiwiZWxlbWVudCIsIndyYXBwZWQiLCJrZXkiLCJkaXNwbGF5TmFtZU9mTm9kZSIsImNsYXNzTmFtZSIsImluZGV4T2YiLCJjb25zb2xlIiwid2FybiIsImZuIiwiaSIsImluaXRpYWxWYWx1ZSIsInJlZHVjZSIsImFjY3VtIiwicmVkdWNlUmlnaHQiLCJiZWdpbiIsImVuZCIsInNsaWNlIiwiZmxhdHRlbmVkIiwiZ2V0RWxlbWVudHMiLCJleGlzdHMiLCJmaW5kIiwiZm5OYW1lIiwiaW50ZXJjZXB0ZXIiLCJhdHRhY2hUbyIsImZpbHRlcldoZXJlIiwidHlwZSIsIklURVJBVE9SX1NZTUJPTCIsIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwicHJvdG90eXBlIiwiY29uZmlndXJhYmxlIiwidmFsdWUiLCJpdGVyYXRvciIsIml0ZXIiLCJuZXh0IiwiZG9uZSIsInByaXZhdGVXYXJuaW5nIiwiZXh0cmFNZXNzYWdlIiwiZW51bWVyYWJsZSJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7QUFBQTs7OztBQUNBOzs7O0FBRUE7O0FBZUE7Ozs7QUFDQTs7QUFDQTs7QUFVQTs7Ozs7Ozs7Ozs7O0FBRUEsSUFBTUEsT0FBTyxnQkFBSSxVQUFKLENBQWI7QUFDQSxJQUFNQyxRQUFRLGdCQUFJLFdBQUosQ0FBZDtBQUNBLElBQU1DLFdBQVcsZ0JBQUksY0FBSixDQUFqQjtBQUNBLElBQU1DLGFBQWEsZ0JBQUksZ0JBQUosQ0FBbkI7QUFDQSxJQUFNQyxPQUFPLGdCQUFJLFVBQUosQ0FBYjtBQUNBLElBQU1DLFVBQVUsZ0JBQUksYUFBSixDQUFoQjtBQUNBLElBQU1DLGFBQWEsZ0JBQUksZUFBSixDQUFuQjtBQUNBLElBQU1DLHFCQUFxQixnQkFBSSx1QkFBSixDQUEzQjtBQUNBLElBQU1DLGVBQWUsZ0JBQUksaUJBQUosQ0FBckI7QUFDQSxJQUFNQyxhQUFhLGdCQUFJLGVBQUosQ0FBbkI7O0FBRUE7Ozs7Ozs7OztBQVNBLFNBQVNDLGtCQUFULENBQTRCQyxPQUE1QixFQUFxQ0MsU0FBckMsRUFBcUU7QUFBQSxNQUFyQkMsTUFBcUIsdUVBQVpDLHdCQUFZOztBQUNuRSxTQUFPSCxRQUFRSSxPQUFSLENBQWdCLFVBQUNDLENBQUQ7QUFBQSxXQUFPSCxPQUFPRyxFQUFFQyxlQUFGLEVBQVAsRUFBNEJMLFNBQTVCLENBQVA7QUFBQSxHQUFoQixDQUFQO0FBQ0Q7O0FBRUQ7Ozs7Ozs7O0FBUUEsU0FBU00sb0JBQVQsQ0FBOEJQLE9BQTlCLEVBQXVDQyxTQUF2QyxFQUFrRDtBQUNoRCxTQUFPRCxRQUFRUSxJQUFSLENBQWFSLFFBQVFTLGdCQUFSLEdBQTJCUCxNQUEzQixDQUFrQ0QsU0FBbEMsRUFBNkNDLE1BQTdDLENBQW9EUSxPQUFwRCxDQUFiLENBQVA7QUFDRDs7QUFFRCxTQUFTQyxtQkFBVCxDQUE2QlgsT0FBN0IsRUFBc0M7QUFDcEMsTUFBSUEsUUFBUVAsSUFBUixFQUFjbUIsTUFBZCxLQUF5QixDQUE3QixFQUFnQztBQUM5QixVQUFNLElBQUlDLEtBQUosQ0FBVSw2RUFBVixDQUFOO0FBQ0Q7QUFDRCxNQUFJYixRQUFRUCxJQUFSLE1BQWtCTyxPQUF0QixFQUErQjtBQUM3QixXQUFPQSxRQUFRTCxVQUFSLEVBQW9CLENBQXBCLENBQVA7QUFDRDtBQUNELFNBQU9LLFFBQVFQLElBQVIsRUFBY0osSUFBZCxDQUFQO0FBQ0Q7O0FBRUQsU0FBU3lCLFdBQVQsQ0FBcUJkLE9BQXJCLEVBQThCZSxJQUE5QixFQUFvQztBQUNsQyxTQUFPLGlDQUFjQSxJQUFkLEVBQW9CSixvQkFBb0JYLE9BQXBCLENBQXBCLENBQVA7QUFDRDs7QUFFRCxTQUFTZ0IsZUFBVCxDQUF5QmhCLE9BQXpCLEVBQWtDaUIsS0FBbEMsRUFBeUM7QUFDdkMsTUFBSSxDQUFDQSxLQUFMLEVBQVk7QUFDViwyQkFBV2pCLE9BQVgsRUFBb0JYLElBQXBCLEVBQTBCLElBQTFCO0FBQ0EsMkJBQVdXLE9BQVgsRUFBb0JWLEtBQXBCLEVBQTJCLEVBQTNCO0FBQ0QsR0FIRCxNQUdPLElBQUksQ0FBQzRCLE1BQU1DLE9BQU4sQ0FBY0YsS0FBZCxDQUFMLEVBQTJCO0FBQ2hDLDJCQUFXakIsT0FBWCxFQUFvQlgsSUFBcEIsRUFBMEI0QixLQUExQjtBQUNBLDJCQUFXakIsT0FBWCxFQUFvQlYsS0FBcEIsRUFBMkIsQ0FBQzJCLEtBQUQsQ0FBM0I7QUFDRCxHQUhNLE1BR0E7QUFDTCwyQkFBV2pCLE9BQVgsRUFBb0JYLElBQXBCLEVBQTBCNEIsTUFBTSxDQUFOLENBQTFCO0FBQ0EsMkJBQVdqQixPQUFYLEVBQW9CVixLQUFwQixFQUEyQjJCLEtBQTNCO0FBQ0Q7QUFDRCx5QkFBV2pCLE9BQVgsRUFBb0IsUUFBcEIsRUFBOEJBLFFBQVFWLEtBQVIsRUFBZXNCLE1BQTdDO0FBQ0Q7O0FBRUQ7Ozs7SUFHTVEsWTtBQUNKLHdCQUFZSCxLQUFaLEVBQW1CSSxJQUFuQixFQUE2QztBQUFBLFFBQXBCQyxhQUFvQix1RUFBSixFQUFJOztBQUFBOztBQUMzQyxRQUFJLENBQUNDLE9BQU9DLE1BQVIsSUFBa0IsQ0FBQ0QsT0FBT0UsUUFBOUIsRUFBd0M7QUFDdEMsWUFBTSxJQUFJWixLQUFKLENBQVUsNEVBQVYsQ0FBTjtBQUNEO0FBQ0QsUUFBTWEsVUFBVSx3QkFBWUosYUFBWixDQUFoQjs7QUFFQSxRQUFJLENBQUNELElBQUwsRUFBVztBQUNULFVBQU1NLFVBQVUsNkJBQVdELE9BQVgsQ0FBaEI7QUFDQSxVQUFJLENBQUNDLFFBQVFDLGNBQVIsQ0FBdUJYLEtBQXZCLENBQUwsRUFBb0M7QUFDbEMsY0FBTSxJQUFJWSxTQUFKLENBQWMsMkNBQWQsQ0FBTjtBQUNEOztBQUVELFVBQU1DLFdBQVdILFFBQVFJLGNBQVIsNEJBQXlCQyxNQUFNLE9BQS9CLElBQTJDTixPQUEzQyxFQUFqQjtBQUNBLDZCQUFXLElBQVgsRUFBaUJuQyxRQUFqQixFQUEyQnVDLFFBQTNCO0FBQ0FBLGVBQVNHLE1BQVQsQ0FBZ0JoQixLQUFoQixFQUF1QlMsUUFBUVEsT0FBL0I7QUFDQSw2QkFBVyxJQUFYLEVBQWlCekMsSUFBakIsRUFBdUIsSUFBdkI7QUFDQXVCLHNCQUFnQixJQUFoQixFQUFzQixLQUFLekIsUUFBTCxFQUFlNEMsT0FBZixFQUF0QjtBQUNBLDZCQUFXLElBQVgsRUFBaUJ6QyxPQUFqQixFQUEwQmdDLE9BQTFCO0FBQ0EsNkJBQVcsSUFBWCxFQUFpQjdCLFlBQWpCLEVBQStCLEVBQS9COztBQUVBLFVBQUksOEJBQWtCNkIsUUFBUVUsaUJBQTFCLEVBQTZDVCxPQUE3QyxDQUFKLEVBQTJEO0FBQ3pELFlBQUksT0FBTyxLQUFLcEMsUUFBTCxFQUFlOEMsNEJBQXRCLEtBQXVELFVBQTNELEVBQXVFO0FBQ3JFLGdCQUFNLElBQUlSLFNBQUosQ0FBYyxzRUFBZCxDQUFOO0FBQ0Q7O0FBRUQ7QUFDQSwrQkFBVyxJQUFYLEVBQWlCakMsa0JBQWpCLEVBQXFDLElBQUkwQyx3QkFBSixDQUNuQyxJQURtQyxFQUM3QixLQUFLL0MsUUFBTCxFQUFlOEMsNEJBQWYsRUFENkIsQ0FBckM7QUFHQSxhQUFLeEMsWUFBTCxFQUFtQjBDLElBQW5CLENBQXdCLEtBQUszQyxrQkFBTCxDQUF4QjtBQUNEO0FBQ0YsS0F6QkQsTUF5Qk87QUFDTCw2QkFBVyxJQUFYLEVBQWlCTCxRQUFqQixFQUEyQjhCLEtBQUs5QixRQUFMLENBQTNCO0FBQ0EsNkJBQVcsSUFBWCxFQUFpQkUsSUFBakIsRUFBdUI0QixJQUF2QjtBQUNBTCxzQkFBZ0IsSUFBaEIsRUFBc0JDLEtBQXRCO0FBQ0EsNkJBQVcsSUFBWCxFQUFpQnRCLFVBQWpCLEVBQTZCMEIsS0FBSy9CLEtBQUwsQ0FBN0I7QUFDQSw2QkFBVyxJQUFYLEVBQWlCSSxPQUFqQixFQUEwQjJCLEtBQUszQixPQUFMLENBQTFCO0FBQ0EsNkJBQVcsSUFBWCxFQUFpQkcsWUFBakIsRUFBK0IsRUFBL0I7QUFDRDtBQUNELDJCQUFXLElBQVgsRUFBaUJMLFVBQWpCLEVBQTZCeUIsS0FBN0I7QUFDQSwyQkFBVyxJQUFYLEVBQWlCbkIsVUFBakIsRUFBNkIsSUFBN0I7QUFDRDs7QUFFRDs7Ozs7Ozs7OztzQkFLTztBQUNMLGVBQU8sS0FBS0wsSUFBTCxDQUFQO0FBQ0Q7Ozs7O0FBRUQ7Ozs7Ozs7OztpQ0FLa0I7QUFDaEIsWUFBSSxLQUFLbUIsTUFBTCxLQUFnQixDQUFwQixFQUF1QjtBQUNyQixnQkFBTSxJQUFJQyxLQUFKLENBQVUsbUVBQVYsQ0FBTjtBQUNEO0FBQ0QsZUFBTyxLQUFLdkIsS0FBTCxFQUFZLENBQVosQ0FBUDtBQUNEOzs7OztBQUVEOzs7Ozs7Ozs7a0NBS21CO0FBQ2pCLGVBQU8sS0FBS0EsS0FBTCxDQUFQO0FBQ0Q7Ozs7O0FBRUQ7Ozs7Ozs7Ozs0QkFLYTtBQUFBOztBQUNYLGVBQU8sS0FBS2tELE1BQUwsQ0FBWSxZQUFaLEVBQTBCO0FBQUEsaUJBQU0sNkJBQVcsTUFBSzlDLE9BQUwsQ0FBWCxFQUEwQitDLGFBQTFCLENBQXdDLE1BQUtwRCxJQUFMLENBQXhDLENBQU47QUFBQSxTQUExQixDQUFQO0FBQ0Q7Ozs7O0FBRUQ7Ozs7Ozs7Ozs2QkFLYztBQUFBOztBQUNaLGVBQU8sS0FBS0MsS0FBTCxFQUFZb0QsR0FBWixDQUFnQixVQUFDckMsQ0FBRDtBQUFBLGlCQUFPLDZCQUFXLE9BQUtYLE9BQUwsQ0FBWCxFQUEwQitDLGFBQTFCLENBQXdDcEMsQ0FBeEMsQ0FBUDtBQUFBLFNBQWhCLENBQVA7QUFDRDs7Ozs7QUFFRDs7Ozs7eUJBQ1U7QUFDUixjQUFNLElBQUlRLEtBQUosQ0FBVSxzRkFBVixDQUFOO0FBQ0Q7Ozs7O0FBRUQ7Ozs7OzBCQUNXO0FBQ1QsY0FBTSxJQUFJQSxLQUFKLENBQVUsa0RBQVYsQ0FBTjtBQUNEOzs7OztBQUVEOzs7Ozs7Ozs7Ozs0QkFPYTtBQUNYLFlBQU1jLFVBQVUsNkJBQVcsS0FBS2pDLE9BQUwsQ0FBWCxDQUFoQjtBQUNBLGVBQU8sS0FBSzhDLE1BQUwsQ0FBWSxZQUFaLEVBQTBCLFVBQUNuQyxDQUFEO0FBQUEsaUJBQU9zQixRQUFRZ0IsY0FBUixDQUF1QnRDLENBQXZCLEVBQTBCLElBQTFCLENBQVA7QUFBQSxTQUExQixDQUFQO0FBQ0Q7Ozs7O0FBRUQ7Ozs7Ozs7Ozs7Ozs7bUJBU0l1QyxPLEVBQVM7QUFDWCxZQUFJLEtBQUtuRCxJQUFMLE1BQWUsSUFBbkIsRUFBeUI7QUFDdkIsZ0JBQU0sSUFBSW9CLEtBQUosQ0FBVSwyREFBVixDQUFOO0FBQ0Q7QUFDRCxlQUFPLEtBQUtnQyxRQUFMLEdBQWdCQyxJQUFoQixDQUFxQkYsT0FBckIsQ0FBUDtBQUNEOzs7OztBQUVEOzs7Ozs7Ozs7Ozs7Ozs7MEJBV1c7QUFBQTs7QUFDVCxlQUFPLEtBQUtKLE1BQUwsQ0FBWSxVQUFaLEVBQXdCO0FBQUEsaUJBQU0sT0FBS25ELElBQUwsRUFBV3dELFFBQWpCO0FBQUEsU0FBeEIsQ0FBUDtBQUNEOzs7OztBQUVEOzs7Ozs7Ozs7OztzQ0FPdUI7QUFDckIsWUFBSSxLQUFLcEQsSUFBTCxNQUFlLElBQW5CLEVBQXlCO0FBQ3ZCLGdCQUFNLElBQUlvQixLQUFKLENBQVUscUVBQVYsQ0FBTjtBQUNEO0FBQ0QsWUFBSSxDQUFDLEtBQUtuQixPQUFMLEVBQWMwQyxpQkFBbkIsRUFBc0M7QUFDcEMsZ0JBQU0sSUFBSXZCLEtBQUosQ0FBVSw4SEFBVixDQUFOO0FBQ0Q7QUFDRCxlQUFPLEtBQUtqQixrQkFBTCxDQUFQO0FBQ0Q7Ozs7O0FBRUQ7Ozs7Ozs7Ozs7Ozt3QkFRUztBQUFBOztBQUNQLFlBQU15QixPQUFPLEtBQUs1QixJQUFMLENBQWI7QUFDQSxZQUFJLFNBQVM0QixJQUFiLEVBQW1CO0FBQ2pCLGlCQUFPQSxLQUFLMEIsTUFBTCxFQUFQO0FBQ0Q7QUFDRC9CLHdCQUFnQixJQUFoQixFQUFzQixLQUFLekIsUUFBTCxFQUFlNEMsT0FBZixFQUF0QjtBQUNBLGFBQUt0QyxZQUFMLEVBQW1CbUQsT0FBbkIsQ0FBMkIsVUFBQ0MsVUFBRCxFQUFnQjtBQUN6QyxjQUFJQSxlQUFlLE9BQUtuRCxVQUFMLENBQW5CLEVBQXFDO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0FtRCx1QkFBV25ELFVBQVgsSUFBeUIsTUFBekI7QUFDQSxnQkFBSTtBQUNGbUQseUJBQVdGLE1BQVg7QUFDRCxhQUZELFNBRVU7QUFDUkUseUJBQVduRCxVQUFYLElBQXlCLElBQXpCO0FBQ0Q7QUFDRjtBQUNGLFNBYkQ7QUFjQSxlQUFPLElBQVA7QUFDRDs7Ozs7QUFFRDs7Ozs7Ozs7Ozt5QkFNVTtBQUFBOztBQUNSLFlBQUksS0FBS0wsSUFBTCxNQUFlLElBQW5CLEVBQXlCO0FBQ3ZCLGdCQUFNLElBQUlvQixLQUFKLENBQVUsd0RBQVYsQ0FBTjtBQUNEO0FBQ0QsYUFBSzJCLE1BQUwsQ0FBWSxTQUFaLEVBQXVCLFlBQU07QUFDM0IsaUJBQUtqRCxRQUFMLEVBQWUyRCxPQUFmO0FBQ0EsaUJBQUtILE1BQUw7QUFDRCxTQUhEO0FBSUEsZUFBTyxJQUFQO0FBQ0Q7Ozs7O0FBRUQ7Ozs7Ozs7Ozs7O3VCQU9RO0FBQUE7O0FBQ04sWUFBSSxLQUFLdEQsSUFBTCxNQUFlLElBQW5CLEVBQXlCO0FBQ3ZCLGdCQUFNLElBQUlvQixLQUFKLENBQVUsc0RBQVYsQ0FBTjtBQUNEO0FBQ0QsYUFBS3RCLFFBQUwsRUFBZTBDLE1BQWYsQ0FBc0IsS0FBS3pDLFVBQUwsQ0FBdEIsRUFBd0MsS0FBS0UsT0FBTCxFQUFjd0MsT0FBdEQsRUFBK0Q7QUFBQSxpQkFBTSxPQUFLYSxNQUFMLEVBQU47QUFBQSxTQUEvRDtBQUNBLGVBQU8sSUFBUDtBQUNEOzs7OztBQUVEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7d0JBY1NJLEssRUFBNkI7QUFBQTs7QUFBQSxZQUF0QkMsUUFBc0IsdUVBQVhDLFNBQVc7O0FBQ3BDLFlBQUksS0FBSzVELElBQUwsTUFBZSxJQUFuQixFQUF5QjtBQUN2QixnQkFBTSxJQUFJb0IsS0FBSixDQUFVLHlEQUFWLENBQU47QUFDRDtBQUNELFlBQUl5QyxVQUFVMUMsTUFBVixHQUFtQixDQUFuQixJQUF3QixPQUFPd0MsUUFBUCxLQUFvQixVQUFoRCxFQUE0RDtBQUMxRCxnQkFBTSxJQUFJdkIsU0FBSixDQUFjLG9FQUFkLENBQU47QUFDRDtBQUNELFlBQU1GLFVBQVUsNkJBQVcsS0FBS2pDLE9BQUwsQ0FBWCxDQUFoQjtBQUNBLGFBQUtGLFVBQUwsSUFBbUIseUJBQWFtQyxPQUFiLEVBQXNCLEtBQUtuQyxVQUFMLENBQXRCLEVBQXdDMkQsS0FBeEMsQ0FBbkI7QUFDQSxhQUFLNUQsUUFBTCxFQUFlMEMsTUFBZixDQUFzQixLQUFLekMsVUFBTCxDQUF0QixFQUF3QyxJQUF4QyxFQUE4QyxZQUFNO0FBQ2xELGlCQUFLdUQsTUFBTDtBQUNBLGNBQUlLLFFBQUosRUFBYztBQUNaQTtBQUNEO0FBQ0YsU0FMRDtBQU1BLGVBQU8sSUFBUDtBQUNEOzs7OztBQUVEOzs7Ozs7Ozs7Ozs7Ozs7Ozt3QkFhU0csSyxFQUE2QjtBQUFBOztBQUFBLFlBQXRCSCxRQUFzQix1RUFBWEMsU0FBVzs7QUFDcEMsWUFBSSxLQUFLUixRQUFMLE9BQW9CLElBQXBCLElBQTRCLEtBQUt2QyxlQUFMLEdBQXVCa0QsUUFBdkIsS0FBb0MsT0FBcEUsRUFBNkU7QUFDM0UsZ0JBQU0sSUFBSTNDLEtBQUosQ0FBVSxpRUFBVixDQUFOO0FBQ0Q7QUFDRCxZQUFJeUMsVUFBVTFDLE1BQVYsR0FBbUIsQ0FBbkIsSUFBd0IsT0FBT3dDLFFBQVAsS0FBb0IsVUFBaEQsRUFBNEQ7QUFDMUQsZ0JBQU0sSUFBSXZCLFNBQUosQ0FBYyxvRUFBZCxDQUFOO0FBQ0Q7QUFDRCxhQUFLZ0IsUUFBTCxHQUFnQlksUUFBaEIsQ0FBeUJGLEtBQXpCLEVBQWdDLFlBQU07QUFDcEMsaUJBQUtSLE1BQUw7QUFDQSxjQUFJSyxRQUFKLEVBQWM7QUFDWixnQkFBTXpCLFVBQVUsNkJBQVcsT0FBS2pDLE9BQUwsQ0FBWCxDQUFoQjtBQUNBLGdCQUFNbUQsV0FBVyxPQUFLQSxRQUFMLEVBQWpCO0FBQ0EsZ0JBQUlsQixRQUFRK0Isc0JBQVosRUFBb0M7QUFDbEMvQixzQkFBUStCLHNCQUFSLENBQStCYixRQUEvQixFQUF5Q08sUUFBekM7QUFDRCxhQUZELE1BRU87QUFDTEEsdUJBQVNPLElBQVQsQ0FBY2QsUUFBZDtBQUNEO0FBQ0Y7QUFDRixTQVhEO0FBWUEsZUFBTyxJQUFQO0FBQ0Q7Ozs7O0FBRUQ7Ozs7Ozs7Ozs7Ozs7MEJBU1dYLE8sRUFBUztBQUFBOztBQUNsQixZQUFJLEtBQUt6QyxJQUFMLE1BQWUsSUFBbkIsRUFBeUI7QUFDdkIsZ0JBQU0sSUFBSW9CLEtBQUosQ0FBVSwyREFBVixDQUFOO0FBQ0Q7QUFDRCxZQUFJLENBQUMsS0FBS25CLE9BQUwsRUFBY3dDLE9BQW5CLEVBQTRCO0FBQzFCLGdCQUFNLElBQUlyQixLQUFKLENBQVUsd0dBQVYsQ0FBTjtBQUNEO0FBQ0QsYUFBS3RCLFFBQUwsRUFBZTBDLE1BQWYsQ0FBc0IsS0FBS3pDLFVBQUwsQ0FBdEIsRUFBd0MwQyxPQUF4QyxFQUFpRDtBQUFBLGlCQUFNLE9BQUthLE1BQUwsRUFBTjtBQUFBLFNBQWpEO0FBQ0EsZUFBTyxJQUFQO0FBQ0Q7Ozs7O0FBRUQ7Ozs7Ozs7Ozs7Ozs7Ozs7d0JBWVNhLFcsRUFBYTtBQUNwQixZQUFNakMsVUFBVSw2QkFBVyxLQUFLakMsT0FBTCxDQUFYLENBQWhCOztBQUVBLFlBQU1PLFlBQVlpQixNQUFNQyxPQUFOLENBQWN5QyxXQUFkLElBQ2QsVUFBQ0MsS0FBRDtBQUFBLGlCQUFXLHFDQUNYQyxnQkFEVyxFQUVYRCxLQUZXLEVBR1hELFlBQVlsQixHQUFaLENBQWdCLFVBQUMzQixJQUFEO0FBQUEsbUJBQVVZLFFBQVFvQyxhQUFSLENBQXNCaEQsSUFBdEIsQ0FBVjtBQUFBLFdBQWhCLENBSFcsQ0FBWDtBQUFBLFNBRGMsR0FNZCxVQUFDOEMsS0FBRDtBQUFBLGlCQUFXLHNCQUFVbEMsUUFBUW9DLGFBQVIsQ0FBc0JILFdBQXRCLENBQVYsRUFBOENDLEtBQTlDLENBQVg7QUFBQSxTQU5KOztBQVFBLGVBQU85RCxtQkFBbUIsSUFBbkIsRUFBeUJFLFNBQXpCLEVBQW9DVyxNQUFwQyxHQUE2QyxDQUFwRDtBQUNEOzs7OztBQUVEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozt1Q0FnQndCRyxJLEVBQU07QUFDNUIsWUFBTWlELFVBQVUsNkJBQVcsS0FBS3RFLE9BQUwsQ0FBWCxFQUEwQnFFLGFBQTFCLENBQXdDaEQsSUFBeEMsQ0FBaEI7QUFDQSxZQUFNZDtBQUFZLG1CQUFaQSxTQUFZLENBQUM0RCxLQUFEO0FBQUEsbUJBQVcsd0JBQVlHLE9BQVosRUFBcUJILEtBQXJCLEVBQTRCLFVBQUNJLENBQUQsRUFBSUMsQ0FBSjtBQUFBLHFCQUFVRCxLQUFLQyxDQUFmO0FBQUEsYUFBNUIsQ0FBWDtBQUFBOztBQUFaO0FBQUEsV0FBTjtBQUNBLGVBQU9uRSxtQkFBbUIsSUFBbkIsRUFBeUJFLFNBQXpCLEVBQW9DVyxNQUFwQyxHQUE2QyxDQUFwRDtBQUNEOzs7OztBQUVEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzJDQWtCNEJLLEssRUFBTztBQUFBOztBQUNqQyxZQUFJLENBQUNDLE1BQU1DLE9BQU4sQ0FBY0YsS0FBZCxDQUFMLEVBQTJCO0FBQ3pCLGdCQUFNLElBQUlZLFNBQUosQ0FBYywwQkFBZCxDQUFOO0FBQ0Q7O0FBRUQsZUFBT1osTUFBTWtELEtBQU4sQ0FBWSxVQUFDcEQsSUFBRDtBQUFBLGlCQUFVLFFBQUtxRCx1QkFBTCxDQUE2QnJELElBQTdCLENBQVY7QUFBQSxTQUFaLENBQVA7QUFDRDs7Ozs7QUFFRDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzsyQ0FrQjRCRSxLLEVBQU87QUFBQTs7QUFDakMsZUFBT0MsTUFBTUMsT0FBTixDQUFjRixLQUFkLEtBQXdCQSxNQUFNb0QsSUFBTixDQUFXLFVBQUN0RCxJQUFEO0FBQUEsaUJBQVUsUUFBS3FELHVCQUFMLENBQTZCckQsSUFBN0IsQ0FBVjtBQUFBLFNBQVgsQ0FBL0I7QUFDRDs7Ozs7QUFFRDs7Ozs7Ozs7Ozs7Ozs7OztzQkFZT0EsSSxFQUFNO0FBQUE7O0FBQ1gsZUFBTyxLQUFLeUIsTUFBTCxDQUFZLFFBQVosRUFBc0I7QUFBQSxpQkFBTSxzQkFBVSxRQUFLbEMsZUFBTCxFQUFWLEVBQWtDUyxJQUFsQyxDQUFOO0FBQUEsU0FBdEIsQ0FBUDtBQUNEOzs7OztBQUVEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OEJBaUJlQSxJLEVBQU07QUFBQTs7QUFDbkIsZUFBTyxLQUFLeUIsTUFBTCxDQUFZLGdCQUFaLEVBQThCLFlBQU07QUFDekMsY0FBTWIsVUFBVSw2QkFBVyxRQUFLakMsT0FBTCxDQUFYLENBQWhCO0FBQ0EsY0FBTXNFLFVBQVVyQyxRQUFRb0MsYUFBUixDQUFzQmhELElBQXRCLENBQWhCO0FBQ0EsaUJBQU8sd0JBQVlpRCxPQUFaLEVBQXFCLFFBQUsxRCxlQUFMLEVBQXJCLEVBQTZDLFVBQUMyRCxDQUFELEVBQUlDLENBQUo7QUFBQSxtQkFBVUQsS0FBS0MsQ0FBZjtBQUFBLFdBQTdDLENBQVA7QUFDRCxTQUpNLENBQVA7QUFLRDs7Ozs7QUFFRDs7Ozs7Ozs7OztvQkFNS0ksUSxFQUFVO0FBQ2IsZUFBTyxLQUFLOUQsSUFBTCxDQUFVLHNDQUFzQjhELFFBQXRCLEVBQWdDLEtBQUs3RCxnQkFBTCxFQUFoQyxDQUFWLENBQVA7QUFDRDs7Ozs7QUFFRDs7Ozs7Ozs7Ozs7O2tCQVFHNkQsUSxFQUFVO0FBQ1gsWUFBTXJFLFlBQVksK0JBQWVxRSxRQUFmLENBQWxCO0FBQ0EsZUFBTyxLQUFLOUIsTUFBTCxDQUFZLElBQVosRUFBa0IsVUFBQ25DLENBQUQ7QUFBQSxpQkFBT0osVUFBVUksQ0FBVixDQUFQO0FBQUEsU0FBbEIsQ0FBUDtBQUNEOzs7OztBQUVEOzs7Ozs7Ozs7K0JBS2dCO0FBQ2QsWUFBTVksUUFBUSxLQUFLWCxlQUFMLEVBQWQ7O0FBRUEsZUFBTyx5QkFBYVcsS0FBYixDQUFQO0FBQ0Q7Ozs7O0FBRUQ7Ozs7Ozs7Ozs7OzJCQU9ZaEIsUyxFQUFXO0FBQUE7O0FBQ3JCLGVBQU9NLHFCQUFxQixJQUFyQixFQUEyQixVQUFDRixDQUFEO0FBQUEsaUJBQU9KLFVBQVUsUUFBS08sSUFBTCxDQUFVSCxDQUFWLENBQVYsQ0FBUDtBQUFBLFNBQTNCLENBQVA7QUFDRDs7Ozs7QUFFRDs7Ozs7Ozs7Ozs7c0JBT09pRSxRLEVBQVU7QUFDZixZQUFNckUsWUFBWSwrQkFBZXFFLFFBQWYsQ0FBbEI7QUFDQSxlQUFPL0QscUJBQXFCLElBQXJCLEVBQTJCTixTQUEzQixDQUFQO0FBQ0Q7Ozs7O0FBRUQ7Ozs7Ozs7Ozs7O21CQU9JcUUsUSxFQUFVO0FBQ1osWUFBTXJFLFlBQVksK0JBQWVxRSxRQUFmLENBQWxCO0FBQ0EsZUFBTy9ELHFCQUFxQixJQUFyQixFQUEyQixVQUFDRixDQUFEO0FBQUEsaUJBQU8sQ0FBQ0osVUFBVUksQ0FBVixDQUFSO0FBQUEsU0FBM0IsQ0FBUDtBQUNEOzs7OztBQUVEOzs7Ozs7Ozs7Ozs7O3NCQVNPO0FBQ0wsWUFBTXNCLFVBQVUsNkJBQVcsS0FBS2pDLE9BQUwsQ0FBWCxDQUFoQjtBQUNBLGVBQU8sS0FBSzhDLE1BQUwsQ0FBWSxNQUFaLEVBQW9CLFVBQUNuQyxDQUFEO0FBQUEsaUJBQU8sd0NBQXFCQSxDQUFyQixFQUF3QnNCLE9BQXhCLENBQVA7QUFBQSxTQUFwQixDQUFQO0FBQ0Q7Ozs7O0FBRUQ7Ozs7Ozs7Ozs7O3NCQU9PO0FBQ0wsWUFBTUEsVUFBVSw2QkFBVyxLQUFLakMsT0FBTCxDQUFYLENBQWhCO0FBQ0EsZUFBTyxLQUFLOEMsTUFBTCxDQUFZLE1BQVosRUFBb0IsVUFBQ25DLENBQUQ7QUFBQSxpQkFBTyx3Q0FBcUJBLENBQXJCLEVBQXdCc0IsT0FBeEIsQ0FBUDtBQUFBLFNBQXBCLENBQVA7QUFDRDs7Ozs7QUFFRDs7Ozs7Ozs7Ozs7d0JBT1M7QUFDUCxZQUFNNEMsT0FBTyxLQUFLQSxJQUFMLEVBQWI7QUFDQSxlQUFPLDRCQUFnQkEsSUFBaEIsQ0FBUDtBQUNEOzs7OztBQUVEOzs7Ozs7Ozs7Ozs7d0JBUVNDLEssRUFBa0I7QUFBQTs7QUFBQSxZQUFYQyxJQUFXLHVFQUFKLEVBQUk7O0FBQ3pCLGVBQU8sS0FBS2pDLE1BQUwsQ0FBWSxVQUFaLEVBQXdCLFVBQUNuQyxDQUFELEVBQU87QUFDcEMsa0JBQUtkLFFBQUwsRUFBZW1GLGFBQWYsQ0FBNkJyRSxDQUE3QixFQUFnQ21FLEtBQWhDLEVBQXVDQyxJQUF2QztBQUNBLGtCQUFLaEYsSUFBTCxFQUFXc0QsTUFBWDtBQUNBLGlCQUFPLE9BQVA7QUFDRCxTQUpNLENBQVA7QUFLRDs7Ozs7QUFFRDs7Ozs7Ozs7Ozs2QkFNYzRCLEssRUFBTztBQUFBOztBQUNuQixZQUFJLEtBQUtsRixJQUFMLE1BQWUsSUFBbkIsRUFBeUI7QUFDdkIsZ0JBQU0sSUFBSW9CLEtBQUosQ0FBVSw2REFBVixDQUFOO0FBQ0Q7O0FBRUQsZUFBTyxLQUFLMkIsTUFBTCxDQUFZLGVBQVosRUFBNkIsVUFBQ29DLFFBQUQsRUFBYztBQUNoRCxjQUFJQSxTQUFTcEIsUUFBVCxLQUFzQixNQUExQixFQUFrQztBQUNoQyxrQkFBTSxJQUFJM0MsS0FBSixDQUFVLHVFQUFWLENBQU47QUFDRDs7QUFFRCxjQUFNaUIsV0FBVyxRQUFLdkMsUUFBTCxDQUFqQjtBQUNBLGNBQUksT0FBT3VDLFNBQVMrQyxhQUFoQixLQUFrQyxVQUF0QyxFQUFrRDtBQUNoRCxrQkFBTSxJQUFJaEQsU0FBSixDQUFjLGtFQUFkLENBQU47QUFDRDs7QUFFRCxjQUFNaUQsV0FBV25FLG9CQUFvQixPQUFwQixDQUFqQjtBQUNBLGNBQU1vRSxnQkFBZ0IsQ0FBQ0gsUUFBRCxFQUFXSSxNQUFYLENBQWtCbEUsWUFBWSxPQUFaLEVBQWtCOEQsUUFBbEIsQ0FBbEIsQ0FBdEI7QUFDQTlDLG1CQUFTK0MsYUFBVCxDQUF1QkUsYUFBdkIsRUFBc0NELFFBQXRDLEVBQWdESCxLQUFoRDs7QUFFQSxrQkFBS2xGLElBQUwsRUFBV3NELE1BQVg7QUFDQSxpQkFBTyxPQUFQO0FBQ0QsU0FoQk0sQ0FBUDtBQWlCRDs7Ozs7QUFFRDs7Ozs7Ozs7Ozs7dUJBT1E7QUFDTixlQUFPLEtBQUtQLE1BQUwsQ0FBWSxPQUFaLEVBQXFCeUMseUJBQXJCLENBQVA7QUFDRDs7Ozs7QUFFRDs7Ozs7Ozs7Ozs7OztxQkFTTUMsSSxFQUFNO0FBQUE7O0FBQ1YsWUFBTU4sV0FBVyxLQUFLbkYsSUFBTCxNQUFlLElBQWYsR0FBc0IsS0FBS0YsUUFBTCxFQUFlNEMsT0FBZixFQUF0QixHQUFpRCxLQUFLN0IsZUFBTCxFQUFsRTtBQUNBLFlBQUksS0FBS3VDLFFBQUwsT0FBb0IsSUFBcEIsSUFBNEIrQixTQUFTcEIsUUFBVCxLQUFzQixPQUF0RCxFQUErRDtBQUM3RCxnQkFBTSxJQUFJM0MsS0FBSixDQUFVLDhEQUFWLENBQU47QUFDRDtBQUNELFlBQU1zRSxTQUFTLEtBQUszQyxNQUFMLENBQVksT0FBWixFQUFxQjtBQUFBLGlCQUFNLFFBQUtLLFFBQUwsR0FBZ0JVLEtBQXRCO0FBQUEsU0FBckIsQ0FBZjtBQUNBLFlBQUksT0FBTzJCLElBQVAsS0FBZ0IsV0FBcEIsRUFBaUM7QUFDL0IsY0FBSUMsVUFBVSxJQUFkLEVBQW9CO0FBQ2xCLGtCQUFNLElBQUl0RCxTQUFKLGtDQUFzQ3FELElBQXRDLDREQUFOO0FBQ0Q7QUFDRCxpQkFBT0MsT0FBT0QsSUFBUCxDQUFQO0FBQ0Q7QUFDRCxlQUFPQyxNQUFQO0FBQ0Q7Ozs7O0FBRUQ7Ozs7Ozs7Ozs7Ozs7dUJBU1FELEksRUFBTTtBQUFBOztBQUNaLFlBQUksS0FBS3pGLElBQUwsTUFBZSxJQUFuQixFQUF5QjtBQUN2QixnQkFBTSxJQUFJb0IsS0FBSixDQUFVLHdEQUFWLENBQU47QUFDRDtBQUNELFlBQU1nQyxXQUFXLEtBQUtMLE1BQUwsQ0FBWSxTQUFaLEVBQXVCO0FBQUEsaUJBQU0sUUFBS0ssUUFBTCxFQUFOO0FBQUEsU0FBdkIsQ0FBakI7QUFDQSxZQUFJQSxhQUFhLElBQWpCLEVBQXVCO0FBQ3JCLGdCQUFNLElBQUloQyxLQUFKLENBQVUseUVBQVYsQ0FBTjtBQUNEO0FBQ0QsWUFBTXVFLFdBQVd2QyxTQUFTWCxPQUExQjtBQUNBLFlBQUksT0FBT2dELElBQVAsS0FBZ0IsV0FBcEIsRUFBaUM7QUFDL0IsaUJBQU9FLFNBQVNGLElBQVQsQ0FBUDtBQUNEO0FBQ0QsZUFBT0UsUUFBUDtBQUNEOzs7OztBQUVEOzs7Ozs7Ozs7O3dCQU1TZCxRLEVBQVU7QUFDakIsWUFBTWUsY0FBYyxLQUFLakYsT0FBTCxDQUFhLFVBQUNDLENBQUQ7QUFBQSxpQkFBTyxrQ0FBZUEsRUFBRUMsZUFBRixFQUFmLENBQVA7QUFBQSxTQUFiLENBQXBCO0FBQ0EsZUFBT2dFLFdBQVdlLFlBQVluRixNQUFaLENBQW1Cb0UsUUFBbkIsQ0FBWCxHQUEwQ2UsV0FBakQ7QUFDRDs7Ozs7QUFFRDs7Ozs7Ozs7Ozt1QkFNUUMsSyxFQUFPO0FBQUE7O0FBQ2IsZUFBTyxLQUFLOUMsTUFBTCxDQUFZLFNBQVosRUFBdUI7QUFBQSxpQkFBTSxRQUFLK0MsUUFBTCxHQUFnQkMsRUFBaEIsQ0FBbUJGLEtBQW5CLENBQU47QUFBQSxTQUF2QixDQUFQO0FBQ0Q7Ozs7O0FBRUQ7Ozs7Ozs7Ozs7Ozs7dUJBU1FoQixRLEVBQVU7QUFBQTs7QUFDaEIsZUFBTyxLQUFLOUIsTUFBTCxDQUFZLFNBQVosRUFBdUIsVUFBQ25DLENBQUQsRUFBTztBQUNuQyxjQUFNb0YsYUFBYSxRQUFLakYsSUFBTCxDQUFVTSxZQUFZLE9BQVosRUFBa0JULENBQWxCLENBQVYsQ0FBbkI7QUFDQSxpQkFBT2lFLFdBQVdtQixXQUFXdkYsTUFBWCxDQUFrQm9FLFFBQWxCLENBQVgsR0FBeUNtQixVQUFoRDtBQUNELFNBSE0sQ0FBUDtBQUlEOzs7OztBQUVEOzs7Ozs7Ozs7d0JBS1M7QUFDUCxlQUFPLEtBQUtyRixPQUFMLENBQWEsVUFBQ0MsQ0FBRDtBQUFBLGlCQUFPLENBQUNBLEVBQUVxRixPQUFGLEdBQVlDLEdBQVosQ0FBZ0IsQ0FBaEIsQ0FBRCxDQUFQO0FBQUEsU0FBYixDQUFQO0FBQ0Q7Ozs7O0FBRUQ7Ozs7Ozs7Ozt1QkFLUXJCLFEsRUFBVTtBQUNoQixZQUFJLEtBQUtzQixFQUFMLENBQVF0QixRQUFSLENBQUosRUFBdUI7QUFDckIsaUJBQU8sSUFBUDtBQUNEO0FBQ0QsWUFBTXVCLG9CQUFvQixLQUFLSCxPQUFMLEdBQWV4RixNQUFmLENBQXNCb0UsUUFBdEIsQ0FBMUI7QUFDQSxlQUFPdUIsa0JBQWtCakYsTUFBbEIsR0FBMkIsQ0FBM0IsR0FBK0JpRixrQkFBa0JDLEtBQWxCLEVBQS9CLEdBQTJELEtBQUtDLFNBQUwsQ0FBZTtBQUFBLGlCQUFNLEtBQU47QUFBQSxTQUFmLENBQWxFO0FBQ0Q7Ozs7O0FBRUQ7Ozs7Ozs7Ozs7b0JBTUtDLFEsRUFBVTtBQUNiLGVBQU8sS0FBSzdDLEtBQUwsR0FBYTZDLFFBQWIsQ0FBUDtBQUNEOzs7OztBQUVEOzs7Ozs7Ozs7OztzQkFPT0EsUSxFQUFVO0FBQUE7O0FBQ2YsZUFBTyxLQUFLeEQsTUFBTCxDQUFZLFFBQVosRUFBc0IsWUFBTTtBQUNqQyxjQUFNeUQsVUFBVSxRQUFLQyxJQUFMLENBQVVGLFFBQVYsQ0FBaEI7QUFDQSxjQUFJLE9BQU9DLE9BQVAsS0FBbUIsVUFBdkIsRUFBbUM7QUFDakMsa0JBQU0sSUFBSXBFLFNBQUosQ0FBYyw4RUFBZCxDQUFOO0FBQ0Q7QUFDRCxpQkFBTyxZQUFhO0FBQUEsOENBQVRzRSxJQUFTO0FBQVRBLGtCQUFTO0FBQUE7O0FBQ2xCLGdCQUFNQyxXQUFXLE9BQU8sUUFBSzdHLFFBQUwsRUFBZThHLFVBQXRCLEtBQXFDLFVBQXJDLEdBQ2IsUUFBSzlHLFFBQUwsRUFBZThHLFVBQWYsQ0FBMEI7QUFBQSxxQkFBTUoseUJBQVdFLElBQVgsQ0FBTjtBQUFBLGFBQTFCLENBRGEsR0FFYkYseUJBQVdFLElBQVgsQ0FGSjtBQUdBLG9CQUFLMUcsSUFBTCxFQUFXc0QsTUFBWDtBQUNBLG1CQUFPcUQsUUFBUDtBQUNELFdBTkQ7QUFPRCxTQVpNLENBQVA7QUFhRDs7Ozs7QUFFRDs7Ozs7Ozs7OzswQkFNV0osUSxFQUFVO0FBQUE7O0FBQ25CLFlBQU1yRSxVQUFVLDZCQUFXLEtBQUtqQyxPQUFMLENBQVgsQ0FBaEI7QUFDQSxZQUFJLE9BQU9pQyxRQUFRbkIsSUFBZixLQUF3QixVQUE1QixFQUF3QztBQUN0QyxnQkFBTSxJQUFJOEYsVUFBSixDQUFlLHlEQUFmLENBQU47QUFDRDs7QUFFRCxlQUFPLEtBQUs5RCxNQUFMLENBQVksWUFBWixFQUEwQixVQUFDbkMsQ0FBRCxFQUFPO0FBQ3RDLGNBQUlBLEVBQUVtRCxRQUFGLEtBQWUsTUFBbkIsRUFBMkI7QUFDekIsa0JBQU0sSUFBSTNCLFNBQUosQ0FBYyxvRUFBZCxDQUFOO0FBQ0Q7QUFDRCxjQUFJLE9BQU9tRSxRQUFQLEtBQW9CLFFBQXhCLEVBQWtDO0FBQ2hDLGtCQUFNLElBQUluRSxTQUFKLENBQWMseURBQWQsQ0FBTjtBQUNEO0FBQ0QsY0FBTXNCLFFBQVEsUUFBS0EsS0FBTCxFQUFkO0FBQ0EsY0FBSSxDQUFDLHNCQUFJQSxLQUFKLEVBQVc2QyxRQUFYLENBQUwsRUFBMkI7QUFDekIsa0JBQU0sSUFBSW5GLEtBQUosOERBQXlEbUYsUUFBekQsbUJBQU47QUFDRDtBQUNELGNBQU1PLFlBQVlwRCxNQUFNNkMsUUFBTixDQUFsQjtBQUNBLGNBQUksT0FBT08sU0FBUCxLQUFxQixVQUF6QixFQUFxQztBQUNuQyxrQkFBTSxJQUFJMUUsU0FBSiw2REFBNERtRSxRQUE1RCxrRUFBcUhPLFNBQXJILHlDQUFxSEEsU0FBckgsY0FBTjtBQUNEOztBQUVELGlCQUFPLFlBQWE7QUFDbEIsZ0JBQU1DLFVBQVVELHFDQUFoQjtBQUNBLGdCQUFNRSxVQUFVOUUsUUFBUW5CLElBQVIsQ0FBYWdHLE9BQWIsQ0FBaEI7QUFDQSxtQkFBTyxRQUFLaEcsSUFBTCxDQUFVaUcsT0FBVixFQUFtQixJQUFuQixFQUF5QixRQUFLL0csT0FBTCxDQUF6QixDQUFQO0FBQ0QsV0FKRDtBQUtELFNBckJNLENBQVA7QUFzQkQ7Ozs7O0FBRUQ7Ozs7Ozs7OztxQkFLTTtBQUNKLGVBQU8sS0FBSzhDLE1BQUwsQ0FBWSxLQUFaLEVBQW1CLFVBQUNuQyxDQUFEO0FBQUEsaUJBQVFBLEVBQUVxRyxHQUFGLEtBQVVyRCxTQUFWLEdBQXNCLElBQXRCLEdBQTZCaEQsRUFBRXFHLEdBQXZDO0FBQUEsU0FBbkIsQ0FBUDtBQUNEOzs7OztBQUVEOzs7Ozs7Ozs7O3NCQU1PO0FBQ0wsZUFBTyxLQUFLbEUsTUFBTCxDQUFZLE1BQVosRUFBb0IsVUFBQ25DLENBQUQ7QUFBQSxpQkFBTyx1QkFBV0EsQ0FBWCxDQUFQO0FBQUEsU0FBcEIsQ0FBUDtBQUNEOzs7OztBQUVEOzs7Ozs7Ozs7OztzQkFPTztBQUNMLFlBQU1zQixVQUFVLDZCQUFXLEtBQUtqQyxPQUFMLENBQVgsQ0FBaEI7QUFDQSxlQUFPLEtBQUs4QyxNQUFMLENBQVksTUFBWixFQUFvQixVQUFDbkMsQ0FBRDtBQUFBLGlCQUN6QnNCLFFBQVFnRixpQkFBUixHQUE0QmhGLFFBQVFnRixpQkFBUixDQUEwQnRHLENBQTFCLENBQTVCLEdBQTJELDhCQUFrQkEsQ0FBbEIsQ0FEbEM7QUFBQSxTQUFwQixDQUFQO0FBR0Q7Ozs7O0FBRUQ7Ozs7Ozs7Ozs7Ozt3QkFRU3VHLFMsRUFBVztBQUNsQixZQUFJLE9BQU9BLFNBQVAsS0FBcUIsUUFBckIsSUFBaUNBLFVBQVVDLE9BQVYsQ0FBa0IsR0FBbEIsTUFBMkIsQ0FBQyxDQUFqRSxFQUFvRTtBQUNsRTtBQUNBQyxrQkFBUUMsSUFBUixDQUFhLG9JQUFiO0FBQ0Q7QUFDRCxlQUFPLEtBQUt2RSxNQUFMLENBQVksVUFBWixFQUF3QixVQUFDbkMsQ0FBRDtBQUFBLGlCQUFPLGdDQUFhQSxDQUFiLEVBQWdCdUcsU0FBaEIsQ0FBUDtBQUFBLFNBQXhCLENBQVA7QUFDRDs7Ozs7QUFFRDs7Ozs7Ozs7Ozs7dUJBT1FJLEUsRUFBSTtBQUFBOztBQUNWLGFBQUt2RyxnQkFBTCxHQUF3QnVDLE9BQXhCLENBQWdDLFVBQUMzQyxDQUFELEVBQUk0RyxDQUFKO0FBQUEsaUJBQVVELEdBQUdyRCxJQUFILENBQVEsT0FBUixFQUFjLFFBQUtuRCxJQUFMLENBQVVILENBQVYsQ0FBZCxFQUE0QjRHLENBQTVCLENBQVY7QUFBQSxTQUFoQztBQUNBLGVBQU8sSUFBUDtBQUNEOzs7OztBQUVEOzs7Ozs7Ozs7OzttQkFPSUQsRSxFQUFJO0FBQUE7O0FBQ04sZUFBTyxLQUFLdkcsZ0JBQUwsR0FBd0JpQyxHQUF4QixDQUE0QixVQUFDckMsQ0FBRCxFQUFJNEcsQ0FBSjtBQUFBLGlCQUFVRCxHQUFHckQsSUFBSCxDQUFRLE9BQVIsRUFBYyxRQUFLbkQsSUFBTCxDQUFVSCxDQUFWLENBQWQsRUFBNEI0RyxDQUE1QixDQUFWO0FBQUEsU0FBNUIsQ0FBUDtBQUNEOzs7OztBQUVEOzs7Ozs7Ozs7Ozs7c0JBUU9ELEUsRUFBOEI7QUFBQTs7QUFBQSxZQUExQkUsWUFBMEIsdUVBQVg3RCxTQUFXOztBQUNuQyxZQUFJQyxVQUFVMUMsTUFBVixHQUFtQixDQUF2QixFQUEwQjtBQUN4QixpQkFBTyxLQUFLSCxnQkFBTCxHQUF3QjBHLE1BQXhCLENBQ0wsVUFBQ0MsS0FBRCxFQUFRL0csQ0FBUixFQUFXNEcsQ0FBWDtBQUFBLG1CQUFpQkQsR0FBR3JELElBQUgsQ0FBUSxPQUFSLEVBQWN5RCxLQUFkLEVBQXFCLFFBQUs1RyxJQUFMLENBQVVILENBQVYsQ0FBckIsRUFBbUM0RyxDQUFuQyxDQUFqQjtBQUFBLFdBREssRUFFTEMsWUFGSyxDQUFQO0FBSUQ7QUFDRCxlQUFPLEtBQUt6RyxnQkFBTCxHQUF3QjBHLE1BQXhCLENBQStCLFVBQUNDLEtBQUQsRUFBUS9HLENBQVIsRUFBVzRHLENBQVg7QUFBQSxpQkFBaUJELEdBQUdyRCxJQUFILENBQ3JELE9BRHFELEVBRXJEc0QsTUFBTSxDQUFOLEdBQVUsUUFBS3pHLElBQUwsQ0FBVTRHLEtBQVYsQ0FBVixHQUE2QkEsS0FGd0IsRUFHckQsUUFBSzVHLElBQUwsQ0FBVUgsQ0FBVixDQUhxRCxFQUlyRDRHLENBSnFELENBQWpCO0FBQUEsU0FBL0IsQ0FBUDtBQU1EOzs7OztBQUVEOzs7Ozs7Ozs7Ozs7MkJBUVlELEUsRUFBOEI7QUFBQTs7QUFBQSxZQUExQkUsWUFBMEIsdUVBQVg3RCxTQUFXOztBQUN4QyxZQUFJQyxVQUFVMUMsTUFBVixHQUFtQixDQUF2QixFQUEwQjtBQUN4QixpQkFBTyxLQUFLSCxnQkFBTCxHQUF3QjRHLFdBQXhCLENBQ0wsVUFBQ0QsS0FBRCxFQUFRL0csQ0FBUixFQUFXNEcsQ0FBWDtBQUFBLG1CQUFpQkQsR0FBR3JELElBQUgsQ0FBUSxPQUFSLEVBQWN5RCxLQUFkLEVBQXFCLFFBQUs1RyxJQUFMLENBQVVILENBQVYsQ0FBckIsRUFBbUM0RyxDQUFuQyxDQUFqQjtBQUFBLFdBREssRUFFTEMsWUFGSyxDQUFQO0FBSUQ7QUFDRCxlQUFPLEtBQUt6RyxnQkFBTCxHQUF3QjRHLFdBQXhCLENBQW9DLFVBQUNELEtBQUQsRUFBUS9HLENBQVIsRUFBVzRHLENBQVg7QUFBQSxpQkFBaUJELEdBQUdyRCxJQUFILENBQzFELE9BRDBELEVBRTFEc0QsTUFBTSxDQUFOLEdBQVUsUUFBS3pHLElBQUwsQ0FBVTRHLEtBQVYsQ0FBVixHQUE2QkEsS0FGNkIsRUFHMUQsUUFBSzVHLElBQUwsQ0FBVUgsQ0FBVixDQUgwRCxFQUkxRDRHLENBSjBELENBQWpCO0FBQUEsU0FBcEMsQ0FBUDtBQU1EOzs7OztBQUVEOzs7Ozs7Ozs7Ozs7cUJBUU1LLEssRUFBT0MsRyxFQUFLO0FBQ2hCLGVBQU8sS0FBSy9HLElBQUwsQ0FBVSxLQUFLQyxnQkFBTCxHQUF3QitHLEtBQXhCLENBQThCRixLQUE5QixFQUFxQ0MsR0FBckMsQ0FBVixDQUFQO0FBQ0Q7Ozs7O0FBRUQ7Ozs7Ozs7Ozs7b0JBTUtqRCxRLEVBQVU7QUFDYixZQUFJLEtBQUs3RSxJQUFMLE1BQWUsSUFBbkIsRUFBeUI7QUFDdkIsZ0JBQU0sSUFBSW9CLEtBQUosQ0FBVSxvREFBVixDQUFOO0FBQ0Q7QUFDRCxZQUFNWixZQUFZLCtCQUFlcUUsUUFBZixDQUFsQjtBQUNBLGVBQU8sS0FBSzdELGdCQUFMLEdBQXdCNEQsSUFBeEIsQ0FBNkJwRSxTQUE3QixDQUFQO0FBQ0Q7Ozs7O0FBRUQ7Ozs7Ozs7Ozs7eUJBTVVBLFMsRUFBVztBQUFBOztBQUNuQixlQUFPLEtBQUtRLGdCQUFMLEdBQXdCNEQsSUFBeEIsQ0FBNkIsVUFBQ2hFLENBQUQsRUFBSTRHLENBQUo7QUFBQSxpQkFBVWhILFVBQVUwRCxJQUFWLENBQWUsT0FBZixFQUFxQixRQUFLbkQsSUFBTCxDQUFVSCxDQUFWLENBQXJCLEVBQW1DNEcsQ0FBbkMsQ0FBVjtBQUFBLFNBQTdCLENBQVA7QUFDRDs7Ozs7QUFFRDs7Ozs7Ozs7OztxQkFNTTNDLFEsRUFBVTtBQUNkLFlBQU1yRSxZQUFZLCtCQUFlcUUsUUFBZixDQUFsQjtBQUNBLGVBQU8sS0FBSzdELGdCQUFMLEdBQXdCMEQsS0FBeEIsQ0FBOEJsRSxTQUE5QixDQUFQO0FBQ0Q7Ozs7O0FBRUQ7Ozs7Ozs7Ozs7MEJBTVdBLFMsRUFBVztBQUFBOztBQUNwQixlQUFPLEtBQUtRLGdCQUFMLEdBQXdCMEQsS0FBeEIsQ0FBOEIsVUFBQzlELENBQUQsRUFBSTRHLENBQUo7QUFBQSxpQkFBVWhILFVBQVUwRCxJQUFWLENBQWUsT0FBZixFQUFxQixRQUFLbkQsSUFBTCxDQUFVSCxDQUFWLENBQXJCLEVBQW1DNEcsQ0FBbkMsQ0FBVjtBQUFBLFNBQTlCLENBQVA7QUFDRDs7Ozs7QUFFRDs7Ozs7Ozs7Ozs7O3VCQVFRRCxFLEVBQUk7QUFBQTs7QUFDVixZQUFNL0YsUUFBUSxLQUFLUixnQkFBTCxHQUF3QmlDLEdBQXhCLENBQTRCLFVBQUNyQyxDQUFELEVBQUk0RyxDQUFKO0FBQUEsaUJBQVVELEdBQUdyRCxJQUFILENBQVEsT0FBUixFQUFjLFFBQUtuRCxJQUFMLENBQVVILENBQVYsQ0FBZCxFQUE0QjRHLENBQTVCLENBQVY7QUFBQSxTQUE1QixDQUFkO0FBQ0EsWUFBTVEsWUFBWSxpQ0FBS3hHLEtBQUwsRUFBWSxDQUFaLENBQWxCO0FBQ0EsZUFBTyxLQUFLVCxJQUFMLENBQVVpSCxVQUFVdkgsTUFBVixDQUFpQlEsT0FBakIsQ0FBVixDQUFQO0FBQ0Q7Ozs7O0FBRUQ7Ozs7Ozs7Ozs7O3lCQU9VVCxTLEVBQVc7QUFBQTs7QUFDbkIsZUFBT0YsbUJBQW1CLElBQW5CLEVBQXlCLFVBQUNNLENBQUQsRUFBTztBQUNyQyxjQUFNVSxPQUFPLFFBQUtQLElBQUwsQ0FBVUgsQ0FBVixDQUFiO0FBQ0EsaUJBQU9VLEtBQUtILE1BQUwsR0FBYyxDQUFkLElBQW1CWCxVQUFVYyxJQUFWLENBQTFCO0FBQ0QsU0FITSxDQUFQO0FBSUQ7Ozs7O0FBRUQ7Ozs7Ozs7Ozs7bUJBTUl1RSxLLEVBQU87QUFDVCxlQUFPLEtBQUtvQyxXQUFMLEdBQW1CcEMsS0FBbkIsQ0FBUDtBQUNEOzs7OztBQUVEOzs7Ozs7Ozs7O2tCQU1HQSxLLEVBQU87QUFDUixZQUFNckUsUUFBUSxLQUFLUixnQkFBTCxFQUFkO0FBQ0EsWUFBSTZFLFFBQVFyRSxNQUFNTCxNQUFsQixFQUEwQjtBQUN4QixpQkFBTyxLQUFLSixJQUFMLENBQVVTLE1BQU1xRSxLQUFOLENBQVYsQ0FBUDtBQUNEO0FBQ0QsZUFBTyxLQUFLOUUsSUFBTCxDQUFVLEVBQVYsQ0FBUDtBQUNEOzs7OztBQUVEOzs7Ozs7Ozs7dUJBS1E7QUFDTixlQUFPLEtBQUtnRixFQUFMLENBQVEsQ0FBUixDQUFQO0FBQ0Q7Ozs7O0FBRUQ7Ozs7Ozs7OztzQkFLTztBQUNMLGVBQU8sS0FBS0EsRUFBTCxDQUFRLEtBQUs1RSxNQUFMLEdBQWMsQ0FBdEIsQ0FBUDtBQUNEOzs7OztBQUVEOzs7Ozs7Ozs7eUJBS1U7QUFDUjtBQUNBa0csZ0JBQVFDLElBQVIsQ0FBYSxtRUFBYjtBQUNBLGVBQU8sQ0FBQyxLQUFLWSxNQUFMLEVBQVI7QUFDRDs7Ozs7QUFFRDs7Ozs7Ozs7Ozs7d0JBT3dCO0FBQUEsWUFBakJyRCxRQUFpQix1RUFBTixJQUFNOztBQUN0QixlQUFPaEIsVUFBVTFDLE1BQVYsR0FBbUIsQ0FBbkIsR0FBdUIsS0FBS2dILElBQUwsQ0FBVXRELFFBQVYsRUFBb0JxRCxNQUFwQixFQUF2QixHQUFzRCxLQUFLL0csTUFBTCxHQUFjLENBQTNFO0FBQ0Q7Ozs7O0FBRUQ7Ozs7Ozs7Ozs7OztzQkFRT3NFLEksRUFBTThCLEUsRUFBSTtBQUNmLFlBQU1hLFNBQVMsT0FBTzNDLElBQVAsS0FBZ0IsUUFBaEIsR0FBMkJBLElBQTNCLEdBQWtDLFNBQWpEO0FBQ0EsWUFBTTlCLFdBQVcsT0FBTzRELEVBQVAsS0FBYyxVQUFkLEdBQTJCQSxFQUEzQixHQUFnQzlCLElBQWpEO0FBQ0EsWUFBSSxLQUFLdEUsTUFBTCxLQUFnQixDQUFwQixFQUF1QjtBQUNyQixnQkFBTSxJQUFJQyxLQUFKLG1CQUFxQmdILE1BQXJCLG9EQUE4RCxLQUFLakgsTUFBbkUsc0JBQU47QUFDRDtBQUNELGVBQU93QyxTQUFTTyxJQUFULENBQWMsSUFBZCxFQUFvQixLQUFLckQsZUFBTCxFQUFwQixDQUFQO0FBQ0Q7Ozs7O0FBRUQ7Ozs7Ozs7Ozs7O29CQU9LUyxJLEVBQWtDO0FBQUEsWUFBNUJNLElBQTRCLHVFQUFyQixLQUFLNUIsSUFBTCxDQUFxQjs7QUFDckMsWUFBSXNCLGdCQUFnQkssWUFBcEIsRUFBa0M7QUFDaEMsaUJBQU9MLElBQVA7QUFDRDs7QUFIb0MsMkNBQU5vRixJQUFNO0FBQU5BLGNBQU07QUFBQTs7QUFJckMsa0RBQVcvRSxZQUFYLGlCQUF3QkwsSUFBeEIsRUFBOEJNLElBQTlCLEdBQXVDOEUsSUFBdkM7QUFDRDs7Ozs7QUFFRDs7Ozs7Ozs7Ozs7O3VCQVFvQjtBQUFBLFlBQWR6RSxPQUFjLHVFQUFKLEVBQUk7O0FBQ2xCLGVBQU8sdUJBQVcsS0FBS2pCLGdCQUFMLEVBQVgsRUFBb0NpQixPQUFwQyxDQUFQO0FBQ0Q7Ozs7O0FBRUQ7Ozs7Ozs7Ozs7bUJBTUlvRyxXLEVBQWE7QUFDZkEsb0JBQVksSUFBWjtBQUNBLGVBQU8sSUFBUDtBQUNEOzs7OztBQUVEOzs7Ozs7Ozs7Ozs7O3dCQVNTO0FBQ1AsWUFBSSxLQUFLckksSUFBTCxNQUFlLElBQW5CLEVBQXlCO0FBQ3ZCLGdCQUFNLElBQUlvQixLQUFKLENBQVUsdURBQVYsQ0FBTjtBQUNEO0FBQ0QsWUFBSSxDQUFDLEtBQUtuQixPQUFMLEVBQWNxSSxRQUFuQixFQUE2QjtBQUMzQixnQkFBTSxJQUFJbEgsS0FBSixDQUFVLG9HQUFWLENBQU47QUFDRDtBQUNELGFBQUt0QixRQUFMLEVBQWUyRCxPQUFmO0FBQ0Q7Ozs7O0FBRUQ7Ozs7Ozs7Ozs7MkJBTVk7QUFDVixlQUFPLEtBQUs4RSxXQUFMLENBQWlCLFVBQUMzSCxDQUFEO0FBQUEsaUJBQU8sT0FBT0EsRUFBRTRILElBQUYsRUFBUCxLQUFvQixRQUEzQjtBQUFBLFNBQWpCLENBQVA7QUFDRDs7Ozs7Ozs7O0FBR0g7Ozs7Ozs7OztJQU9NM0Ysd0I7OztBQUNKO0FBQ0Esb0NBQVlqQixJQUFaLEVBQWtCUyxRQUFsQixFQUE0QjtBQUFBOztBQUFBLHNKQUNwQkEsU0FBU0ssT0FBVCxFQURvQixFQUNBZCxJQURBOztBQUcxQixvQ0FBaUI1QixJQUFqQjtBQUNBLG9DQUFpQkYsUUFBakIsRUFBMkJ1QyxRQUEzQjtBQUNBLFlBQUtqQyxZQUFMLEVBQW1CMEMsSUFBbkIsQ0FBd0JsQixJQUF4QjtBQUwwQjtBQU0zQjs7Ozs7c0NBRXNCO0FBQ3JCLGNBQU0sSUFBSVEsU0FBSixDQUFjLHFFQUFkLENBQU47QUFDRDs7Ozs7OztFQVpvQ1QsWTs7QUFldkMsSUFBSThHLHNCQUFKLEVBQXFCO0FBQ25CQyxTQUFPQyxjQUFQLENBQXNCaEgsYUFBYWlILFNBQW5DLEVBQThDSCxzQkFBOUMsRUFBK0Q7QUFDN0RJLGtCQUFjLElBRCtDO0FBRTdEQztBQUFPLGVBQVNDLFFBQVQsR0FBb0I7QUFBQTs7QUFDekIsWUFBTUMsT0FBTyxLQUFLbkosS0FBTCxFQUFZNEksc0JBQVosR0FBYjtBQUNBLFlBQU12RyxVQUFVLDZCQUFXLEtBQUtqQyxPQUFMLENBQVgsQ0FBaEI7QUFDQSxnREFDR3dJLHNCQURILGNBQ3NCO0FBQUUsaUJBQU8sSUFBUDtBQUFjLFNBRHRDO0FBQUEsMEJBRVM7QUFDTCxnQkFBTVEsT0FBT0QsS0FBS0MsSUFBTCxFQUFiO0FBQ0EsZ0JBQUlBLEtBQUtDLElBQVQsRUFBZTtBQUNiLHFCQUFPLEVBQUVBLE1BQU0sSUFBUixFQUFQO0FBQ0Q7QUFDRCxtQkFBTztBQUNMQSxvQkFBTSxLQUREO0FBRUxKLHFCQUFPNUcsUUFBUWMsYUFBUixDQUFzQmlHLEtBQUtILEtBQTNCO0FBRkYsYUFBUDtBQUlEOztBQVhIO0FBQUE7QUFhRDs7QUFoQkQsYUFBZ0JDLFFBQWhCO0FBQUE7QUFGNkQsR0FBL0Q7QUFvQkQ7O0FBRUQsU0FBU0ksY0FBVCxDQUF3QjFDLElBQXhCLEVBQThCMkMsWUFBOUIsRUFBNEM7QUFDMUNWLFNBQU9DLGNBQVAsQ0FBc0JoSCxhQUFhaUgsU0FBbkMsRUFBOENuQyxJQUE5QyxFQUFvRDtBQUNsRFAsT0FEa0Q7QUFBQSxxQkFDNUM7QUFDSixjQUFNLElBQUk5RSxLQUFKLHlEQUNnQ3FGLElBRGhDLDhKQUdGMkMsWUFIRSxlQUFOO0FBS0Q7O0FBUGlEO0FBQUE7O0FBUWxEQyxnQkFBWSxLQVJzQztBQVNsRFIsa0JBQWM7QUFUb0MsR0FBcEQ7QUFXRDs7QUFFRE0sZUFBZSxNQUFmLEVBQXVCLGlEQUF2QjtBQUNBQSxlQUFlLE9BQWYsRUFBd0Isa0RBQXhCO0FBQ0FBLGVBQWUsVUFBZixFQUEyQixFQUEzQjtBQUNBQSxlQUFlLFNBQWYsRUFBMEIsRUFBMUI7QUFDQUEsZUFBZSxpQkFBZixFQUFrQyxFQUFsQzs7cUJBRWV4SCxZIiwiZmlsZSI6IlJlYWN0V3JhcHBlci5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBmbGF0IGZyb20gJ2FycmF5LnByb3RvdHlwZS5mbGF0JztcbmltcG9ydCBoYXMgZnJvbSAnaGFzJztcblxuaW1wb3J0IHtcbiAgY29udGFpbnNDaGlsZHJlblN1YkFycmF5LFxuICB0eXBlT2ZOb2RlLFxuICBkaXNwbGF5TmFtZU9mTm9kZSxcbiAgSVRFUkFUT1JfU1lNQk9MLFxuICBub2RlRXF1YWwsXG4gIG5vZGVNYXRjaGVzLFxuICBtYWtlT3B0aW9ucyxcbiAgc3ltLFxuICBwcml2YXRlU2V0LFxuICBjbG9uZUVsZW1lbnQsXG4gIHJlbmRlcmVkRGl2ZSxcbiAgaXNDdXN0b21Db21wb25lbnQsXG4gIGxvYWRDaGVlcmlvUm9vdCxcbn0gZnJvbSAnLi9VdGlscyc7XG5pbXBvcnQgZ2V0QWRhcHRlciBmcm9tICcuL2dldEFkYXB0ZXInO1xuaW1wb3J0IHsgZGVidWdOb2RlcyB9IGZyb20gJy4vRGVidWcnO1xuaW1wb3J0IHtcbiAgcHJvcHNPZk5vZGUsXG4gIGhhc0NsYXNzTmFtZSxcbiAgY2hpbGRyZW5PZk5vZGUsXG4gIHBhcmVudHNPZk5vZGUsXG4gIHRyZWVGaWx0ZXIsXG4gIGdldFRleHRGcm9tSG9zdE5vZGVzLFxuICBnZXRIVE1MRnJvbUhvc3ROb2Rlcyxcbn0gZnJvbSAnLi9SU1RUcmF2ZXJzYWwnO1xuXG5pbXBvcnQgeyBidWlsZFByZWRpY2F0ZSwgcmVkdWNlVHJlZXNCeVNlbGVjdG9yIH0gZnJvbSAnLi9zZWxlY3RvcnMnO1xuXG5jb25zdCBOT0RFID0gc3ltKCdfX25vZGVfXycpO1xuY29uc3QgTk9ERVMgPSBzeW0oJ19fbm9kZXNfXycpO1xuY29uc3QgUkVOREVSRVIgPSBzeW0oJ19fcmVuZGVyZXJfXycpO1xuY29uc3QgVU5SRU5ERVJFRCA9IHN5bSgnX191bnJlbmRlcmVkX18nKTtcbmNvbnN0IFJPT1QgPSBzeW0oJ19fcm9vdF9fJyk7XG5jb25zdCBPUFRJT05TID0gc3ltKCdfX29wdGlvbnNfXycpO1xuY29uc3QgUk9PVF9OT0RFUyA9IHN5bSgnX19yb290Tm9kZXNfXycpO1xuY29uc3QgV1JBUFBJTkdfQ09NUE9ORU5UID0gc3ltKCdfX3dyYXBwaW5nQ29tcG9uZW50X18nKTtcbmNvbnN0IExJTktFRF9ST09UUyA9IHN5bSgnX19saW5rZWRSb290c19fJyk7XG5jb25zdCBVUERBVEVEX0JZID0gc3ltKCdfX3VwZGF0ZWRCeV9fJyk7XG5cbi8qKlxuICogRmluZHMgYWxsIG5vZGVzIGluIHRoZSBjdXJyZW50IHdyYXBwZXIgbm9kZXMnIHJlbmRlciB0cmVlcyB0aGF0IG1hdGNoIHRoZSBwcm92aWRlZCBwcmVkaWNhdGVcbiAqIGZ1bmN0aW9uLlxuICpcbiAqIEBwYXJhbSB7UmVhY3RXcmFwcGVyfSB3cmFwcGVyXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcmVkaWNhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZpbHRlclxuICogQHJldHVybnMge1JlYWN0V3JhcHBlcn1cbiAqL1xuZnVuY3Rpb24gZmluZFdoZXJlVW53cmFwcGVkKHdyYXBwZXIsIHByZWRpY2F0ZSwgZmlsdGVyID0gdHJlZUZpbHRlcikge1xuICByZXR1cm4gd3JhcHBlci5mbGF0TWFwKChuKSA9PiBmaWx0ZXIobi5nZXROb2RlSW50ZXJuYWwoKSwgcHJlZGljYXRlKSk7XG59XG5cbi8qKlxuICogUmV0dXJucyBhIG5ldyB3cmFwcGVyIGluc3RhbmNlIHdpdGggb25seSB0aGUgbm9kZXMgb2YgdGhlIGN1cnJlbnQgd3JhcHBlciBpbnN0YW5jZSB0aGF0IG1hdGNoXG4gKiB0aGUgcHJvdmlkZWQgcHJlZGljYXRlIGZ1bmN0aW9uLlxuICpcbiAqIEBwYXJhbSB7UmVhY3RXcmFwcGVyfSB3cmFwcGVyXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcmVkaWNhdGVcbiAqIEByZXR1cm5zIHtSZWFjdFdyYXBwZXJ9XG4gKi9cbmZ1bmN0aW9uIGZpbHRlcldoZXJlVW53cmFwcGVkKHdyYXBwZXIsIHByZWRpY2F0ZSkge1xuICByZXR1cm4gd3JhcHBlci53cmFwKHdyYXBwZXIuZ2V0Tm9kZXNJbnRlcm5hbCgpLmZpbHRlcihwcmVkaWNhdGUpLmZpbHRlcihCb29sZWFuKSk7XG59XG5cbmZ1bmN0aW9uIGdldFJvb3ROb2RlSW50ZXJuYWwod3JhcHBlcikge1xuICBpZiAod3JhcHBlcltST09UXS5sZW5ndGggIT09IDEpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2dldFJvb3ROb2RlSW50ZXJuYWwod3JhcHBlcikgY2FuIG9ubHkgYmUgY2FsbGVkIHdoZW4gd3JhcHBlciB3cmFwcyBvbmUgbm9kZScpO1xuICB9XG4gIGlmICh3cmFwcGVyW1JPT1RdICE9PSB3cmFwcGVyKSB7XG4gICAgcmV0dXJuIHdyYXBwZXJbUk9PVF9OT0RFU11bMF07XG4gIH1cbiAgcmV0dXJuIHdyYXBwZXJbUk9PVF1bTk9ERV07XG59XG5cbmZ1bmN0aW9uIG5vZGVQYXJlbnRzKHdyYXBwZXIsIG5vZGUpIHtcbiAgcmV0dXJuIHBhcmVudHNPZk5vZGUobm9kZSwgZ2V0Um9vdE5vZGVJbnRlcm5hbCh3cmFwcGVyKSk7XG59XG5cbmZ1bmN0aW9uIHByaXZhdGVTZXROb2Rlcyh3cmFwcGVyLCBub2Rlcykge1xuICBpZiAoIW5vZGVzKSB7XG4gICAgcHJpdmF0ZVNldCh3cmFwcGVyLCBOT0RFLCBudWxsKTtcbiAgICBwcml2YXRlU2V0KHdyYXBwZXIsIE5PREVTLCBbXSk7XG4gIH0gZWxzZSBpZiAoIUFycmF5LmlzQXJyYXkobm9kZXMpKSB7XG4gICAgcHJpdmF0ZVNldCh3cmFwcGVyLCBOT0RFLCBub2Rlcyk7XG4gICAgcHJpdmF0ZVNldCh3cmFwcGVyLCBOT0RFUywgW25vZGVzXSk7XG4gIH0gZWxzZSB7XG4gICAgcHJpdmF0ZVNldCh3cmFwcGVyLCBOT0RFLCBub2Rlc1swXSk7XG4gICAgcHJpdmF0ZVNldCh3cmFwcGVyLCBOT0RFUywgbm9kZXMpO1xuICB9XG4gIHByaXZhdGVTZXQod3JhcHBlciwgJ2xlbmd0aCcsIHdyYXBwZXJbTk9ERVNdLmxlbmd0aCk7XG59XG5cbi8qKlxuICogQGNsYXNzIFJlYWN0V3JhcHBlclxuICovXG5jbGFzcyBSZWFjdFdyYXBwZXIge1xuICBjb25zdHJ1Y3Rvcihub2Rlcywgcm9vdCwgcGFzc2VkT3B0aW9ucyA9IHt9KSB7XG4gICAgaWYgKCFnbG9iYWwud2luZG93ICYmICFnbG9iYWwuZG9jdW1lbnQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSXQgbG9va3MgbGlrZSB5b3UgY2FsbGVkIGBtb3VudCgpYCB3aXRob3V0IGEgZ2xvYmFsIGRvY3VtZW50IGJlaW5nIGxvYWRlZC4nKTtcbiAgICB9XG4gICAgY29uc3Qgb3B0aW9ucyA9IG1ha2VPcHRpb25zKHBhc3NlZE9wdGlvbnMpO1xuXG4gICAgaWYgKCFyb290KSB7XG4gICAgICBjb25zdCBhZGFwdGVyID0gZ2V0QWRhcHRlcihvcHRpb25zKTtcbiAgICAgIGlmICghYWRhcHRlci5pc1ZhbGlkRWxlbWVudChub2RlcykpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignUmVhY3RXcmFwcGVyIGNhbiBvbmx5IHdyYXAgdmFsaWQgZWxlbWVudHMnKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgcmVuZGVyZXIgPSBhZGFwdGVyLmNyZWF0ZVJlbmRlcmVyKHsgbW9kZTogJ21vdW50JywgLi4ub3B0aW9ucyB9KTtcbiAgICAgIHByaXZhdGVTZXQodGhpcywgUkVOREVSRVIsIHJlbmRlcmVyKTtcbiAgICAgIHJlbmRlcmVyLnJlbmRlcihub2Rlcywgb3B0aW9ucy5jb250ZXh0KTtcbiAgICAgIHByaXZhdGVTZXQodGhpcywgUk9PVCwgdGhpcyk7XG4gICAgICBwcml2YXRlU2V0Tm9kZXModGhpcywgdGhpc1tSRU5ERVJFUl0uZ2V0Tm9kZSgpKTtcbiAgICAgIHByaXZhdGVTZXQodGhpcywgT1BUSU9OUywgb3B0aW9ucyk7XG4gICAgICBwcml2YXRlU2V0KHRoaXMsIExJTktFRF9ST09UUywgW10pO1xuXG4gICAgICBpZiAoaXNDdXN0b21Db21wb25lbnQob3B0aW9ucy53cmFwcGluZ0NvbXBvbmVudCwgYWRhcHRlcikpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzW1JFTkRFUkVSXS5nZXRXcmFwcGluZ0NvbXBvbmVudFJlbmRlcmVyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigneW91ciBhZGFwdGVyIGRvZXMgbm90IHN1cHBvcnQgYHdyYXBwaW5nQ29tcG9uZW50YC4gVHJ5IHVwZ3JhZGluZyBpdCEnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11c2UtYmVmb3JlLWRlZmluZVxuICAgICAgICBwcml2YXRlU2V0KHRoaXMsIFdSQVBQSU5HX0NPTVBPTkVOVCwgbmV3IFdyYXBwaW5nQ29tcG9uZW50V3JhcHBlcihcbiAgICAgICAgICB0aGlzLCB0aGlzW1JFTkRFUkVSXS5nZXRXcmFwcGluZ0NvbXBvbmVudFJlbmRlcmVyKCksXG4gICAgICAgICkpO1xuICAgICAgICB0aGlzW0xJTktFRF9ST09UU10ucHVzaCh0aGlzW1dSQVBQSU5HX0NPTVBPTkVOVF0pO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBwcml2YXRlU2V0KHRoaXMsIFJFTkRFUkVSLCByb290W1JFTkRFUkVSXSk7XG4gICAgICBwcml2YXRlU2V0KHRoaXMsIFJPT1QsIHJvb3QpO1xuICAgICAgcHJpdmF0ZVNldE5vZGVzKHRoaXMsIG5vZGVzKTtcbiAgICAgIHByaXZhdGVTZXQodGhpcywgUk9PVF9OT0RFUywgcm9vdFtOT0RFU10pO1xuICAgICAgcHJpdmF0ZVNldCh0aGlzLCBPUFRJT05TLCByb290W09QVElPTlNdKTtcbiAgICAgIHByaXZhdGVTZXQodGhpcywgTElOS0VEX1JPT1RTLCBbXSk7XG4gICAgfVxuICAgIHByaXZhdGVTZXQodGhpcywgVU5SRU5ERVJFRCwgbm9kZXMpO1xuICAgIHByaXZhdGVTZXQodGhpcywgVVBEQVRFRF9CWSwgbnVsbCk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgcm9vdCB3cmFwcGVyXG4gICAqXG4gICAqIEByZXR1cm4ge1JlYWN0V3JhcHBlcn1cbiAgICovXG4gIHJvb3QoKSB7XG4gICAgcmV0dXJuIHRoaXNbUk9PVF07XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgd3JhcHBlZCBjb21wb25lbnQuXG4gICAqXG4gICAqIEByZXR1cm4ge1JlYWN0Q29tcG9uZW50fVxuICAgKi9cbiAgZ2V0Tm9kZUludGVybmFsKCkge1xuICAgIGlmICh0aGlzLmxlbmd0aCAhPT0gMSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdSZWFjdFdyYXBwZXI6OmdldE5vZGUoKSBjYW4gb25seSBiZSBjYWxsZWQgd2hlbiB3cmFwcGluZyBvbmUgbm9kZScpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpc1tOT0RFU11bMF07XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgdGhlIHdyYXBwZWQgY29tcG9uZW50cy5cbiAgICpcbiAgICogQHJldHVybiB7QXJyYXk8UmVhY3RDb21wb25lbnQ+fVxuICAgKi9cbiAgZ2V0Tm9kZXNJbnRlcm5hbCgpIHtcbiAgICByZXR1cm4gdGhpc1tOT0RFU107XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgd3JhcHBlZCBSZWFjdEVsZW1lbnQuXG4gICAqXG4gICAqIEByZXR1cm4ge1JlYWN0RWxlbWVudH1cbiAgICovXG4gIGdldEVsZW1lbnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuc2luZ2xlKCdnZXRFbGVtZW50JywgKCkgPT4gZ2V0QWRhcHRlcih0aGlzW09QVElPTlNdKS5ub2RlVG9FbGVtZW50KHRoaXNbTk9ERV0pKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSB3cmFwcGVkIFJlYWN0RWxlbWVudHMuXG4gICAqXG4gICAqIEByZXR1cm4ge0FycmF5PFJlYWN0RWxlbWVudD59XG4gICAqL1xuICBnZXRFbGVtZW50cygpIHtcbiAgICByZXR1cm4gdGhpc1tOT0RFU10ubWFwKChuKSA9PiBnZXRBZGFwdGVyKHRoaXNbT1BUSU9OU10pLm5vZGVUb0VsZW1lbnQobikpO1xuICB9XG5cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNsYXNzLW1ldGhvZHMtdXNlLXRoaXNcbiAgZ2V0Tm9kZSgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1JlYWN0V3JhcHBlcjo6Z2V0Tm9kZSgpIGlzIG5vIGxvbmdlciBzdXBwb3J0ZWQuIFVzZSBSZWFjdFdyYXBwZXI6Omluc3RhbmNlKCkgaW5zdGVhZCcpO1xuICB9XG5cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNsYXNzLW1ldGhvZHMtdXNlLXRoaXNcbiAgZ2V0Tm9kZXMoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdSZWFjdFdyYXBwZXI6OmdldE5vZGVzKCkgaXMgbm8gbG9uZ2VyIHN1cHBvcnRlZC4nKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBvdXRlciBtb3N0IERPTUNvbXBvbmVudCBvZiB0aGUgY3VycmVudCB3cmFwcGVyLlxuICAgKlxuICAgKiBOT1RFOiBjYW4gb25seSBiZSBjYWxsZWQgb24gYSB3cmFwcGVyIG9mIGEgc2luZ2xlIG5vZGUuXG4gICAqXG4gICAqIEByZXR1cm5zIHtET01Db21wb25lbnR9XG4gICAqL1xuICBnZXRET01Ob2RlKCkge1xuICAgIGNvbnN0IGFkYXB0ZXIgPSBnZXRBZGFwdGVyKHRoaXNbT1BUSU9OU10pO1xuICAgIHJldHVybiB0aGlzLnNpbmdsZSgnZ2V0RE9NTm9kZScsIChuKSA9PiBhZGFwdGVyLm5vZGVUb0hvc3ROb2RlKG4sIHRydWUpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJZiB0aGUgcm9vdCBjb21wb25lbnQgY29udGFpbmVkIGEgcmVmLCB5b3UgY2FuIGFjY2VzcyBpdCBoZXJlIGFuZCBnZXQgdGhlIHJlbGV2YW50XG4gICAqIHJlYWN0IGNvbXBvbmVudCBpbnN0YW5jZSBvciBIVE1MIGVsZW1lbnQgaW5zdGFuY2UuXG4gICAqXG4gICAqIE5PVEU6IGNhbiBvbmx5IGJlIGNhbGxlZCBvbiBhIHdyYXBwZXIgaW5zdGFuY2UgdGhhdCBpcyBhbHNvIHRoZSByb290IGluc3RhbmNlLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gcmVmbmFtZVxuICAgKiBAcmV0dXJucyB7UmVhY3RDb21wb25lbnQgfCBIVE1MRWxlbWVudH1cbiAgICovXG4gIHJlZihyZWZuYW1lKSB7XG4gICAgaWYgKHRoaXNbUk9PVF0gIT09IHRoaXMpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignUmVhY3RXcmFwcGVyOjpyZWYocmVmbmFtZSkgY2FuIG9ubHkgYmUgY2FsbGVkIG9uIHRoZSByb290Jyk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmluc3RhbmNlKCkucmVmc1tyZWZuYW1lXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSB3cmFwcGVyJ3MgdW5kZXJseWluZyBpbnN0YW5jZS5cbiAgICpcbiAgICogRXhhbXBsZTpcbiAgICogYGBgXG4gICAqIGNvbnN0IHdyYXBwZXIgPSBtb3VudCg8TXlDb21wb25lbnQgLz4pO1xuICAgKiBjb25zdCBpbnN0ID0gd3JhcHBlci5pbnN0YW5jZSgpO1xuICAgKiBleHBlY3QoaW5zdCkudG8uYmUuaW5zdGFuY2VPZihNeUNvbXBvbmVudCk7XG4gICAqIGBgYFxuICAgKiBAcmV0dXJucyB7UmVhY3RDb21wb25lbnR8RE9NQ29tcG9uZW50fVxuICAgKi9cbiAgaW5zdGFuY2UoKSB7XG4gICAgcmV0dXJuIHRoaXMuc2luZ2xlKCdpbnN0YW5jZScsICgpID0+IHRoaXNbTk9ERV0uaW5zdGFuY2UpO1xuICB9XG5cbiAgLyoqXG4gICAqIElmIGEgYHdyYXBwaW5nQ29tcG9uZW50YCB3YXMgcGFzc2VkIGluIGBvcHRpb25zYCwgdGhpcyBtZXRob2RzIHJldHVybnMgYSBgUmVhY3RXcmFwcGVyYCBhcm91bmRcbiAgICogdGhlIHJlbmRlcmVkIGB3cmFwcGluZ0NvbXBvbmVudGAuIFRoaXMgYFJlYWN0V3JhcHBlcmAgY2FuIGJlIHVzZWQgdG8gdXBkYXRlIHRoZVxuICAgKiBgd3JhcHBpbmdDb21wb25lbnRgJ3MgcHJvcHMsIHN0YXRlLCBldGMuXG4gICAqXG4gICAqIEByZXR1cm5zIFJlYWN0V3JhcHBlclxuICAgKi9cbiAgZ2V0V3JhcHBpbmdDb21wb25lbnQoKSB7XG4gICAgaWYgKHRoaXNbUk9PVF0gIT09IHRoaXMpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignUmVhY3RXcmFwcGVyOjpnZXRXcmFwcGluZ0NvbXBvbmVudCgpIGNhbiBvbmx5IGJlIGNhbGxlZCBvbiB0aGUgcm9vdCcpO1xuICAgIH1cbiAgICBpZiAoIXRoaXNbT1BUSU9OU10ud3JhcHBpbmdDb21wb25lbnQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignUmVhY3RXcmFwcGVyOjpnZXRXcmFwcGluZ0NvbXBvbmVudCgpIGNhbiBvbmx5IGJlIGNhbGxlZCBvbiBhIHdyYXBwZXIgdGhhdCB3YXMgb3JpZ2luYWxseSBwYXNzZWQgYSBgd3JhcHBpbmdDb21wb25lbnRgIG9wdGlvbicpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpc1tXUkFQUElOR19DT01QT05FTlRdO1xuICB9XG5cbiAgLyoqXG4gICAqIEZvcmNlcyBhIHJlLXJlbmRlci4gVXNlZnVsIHRvIHJ1biBiZWZvcmUgY2hlY2tpbmcgdGhlIHJlbmRlciBvdXRwdXQgaWYgc29tZXRoaW5nIGV4dGVybmFsXG4gICAqIG1heSBiZSB1cGRhdGluZyB0aGUgc3RhdGUgb2YgdGhlIGNvbXBvbmVudCBzb21ld2hlcmUuXG4gICAqXG4gICAqIE5PVEU6IG5vIG1hdHRlciB3aGF0IGluc3RhbmNlIHRoaXMgaXMgY2FsbGVkIG9uLCBpdCB3aWxsIGFsd2F5cyB1cGRhdGUgdGhlIHJvb3QuXG4gICAqXG4gICAqIEByZXR1cm5zIHtSZWFjdFdyYXBwZXJ9XG4gICAqL1xuICB1cGRhdGUoKSB7XG4gICAgY29uc3Qgcm9vdCA9IHRoaXNbUk9PVF07XG4gICAgaWYgKHRoaXMgIT09IHJvb3QpIHtcbiAgICAgIHJldHVybiByb290LnVwZGF0ZSgpO1xuICAgIH1cbiAgICBwcml2YXRlU2V0Tm9kZXModGhpcywgdGhpc1tSRU5ERVJFUl0uZ2V0Tm9kZSgpKTtcbiAgICB0aGlzW0xJTktFRF9ST09UU10uZm9yRWFjaCgobGlua2VkUm9vdCkgPT4ge1xuICAgICAgaWYgKGxpbmtlZFJvb3QgIT09IHRoaXNbVVBEQVRFRF9CWV0pIHtcbiAgICAgICAgLyogZXNsaW50LWRpc2FibGUgbm8tcGFyYW0tcmVhc3NpZ24gKi9cbiAgICAgICAgLy8gT25seSB1cGRhdGUgYSBsaW5rZWQgaXQgcm9vdCBpZiBpdCBpcyBub3QgdGhlIG9yaWdpbmF0b3Igb2Ygb3VyIHVwZGF0ZSgpLlxuICAgICAgICAvLyBUaGlzIGlzIG5lZWRlZCB0byBwcmV2ZW50IGluZmluaXRlIHJlY3Vyc2lvbiB3aGVuIHRoZXJlIGlzIGEgYmktZGlyZWN0aW9uYWxcbiAgICAgICAgLy8gbGluayBiZXR3ZWVuIHR3byByb290cy5cbiAgICAgICAgbGlua2VkUm9vdFtVUERBVEVEX0JZXSA9IHRoaXM7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgbGlua2VkUm9vdC51cGRhdGUoKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICBsaW5rZWRSb290W1VQREFURURfQlldID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIEEgbWV0aG9kIHRoYXQgdW5tb3VudHMgdGhlIGNvbXBvbmVudC4gVGhpcyBjYW4gYmUgdXNlZCB0byBzaW11bGF0ZSBhIGNvbXBvbmVudCBnb2luZyB0aHJvdWdoXG4gICAqIGFuZCB1bm1vdW50L21vdW50IGxpZmVjeWNsZS5cbiAgICpcbiAgICogQHJldHVybnMge1JlYWN0V3JhcHBlcn1cbiAgICovXG4gIHVubW91bnQoKSB7XG4gICAgaWYgKHRoaXNbUk9PVF0gIT09IHRoaXMpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignUmVhY3RXcmFwcGVyOjp1bm1vdW50KCkgY2FuIG9ubHkgYmUgY2FsbGVkIG9uIHRoZSByb290Jyk7XG4gICAgfVxuICAgIHRoaXMuc2luZ2xlKCd1bm1vdW50JywgKCkgPT4ge1xuICAgICAgdGhpc1tSRU5ERVJFUl0udW5tb3VudCgpO1xuICAgICAgdGhpcy51cGRhdGUoKTtcbiAgICB9KTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBBIG1ldGhvZCB0aGF0IHJlLW1vdW50cyB0aGUgY29tcG9uZW50LCBpZiBpdCBpcyBub3QgY3VycmVudGx5IG1vdW50ZWQuXG4gICAqIFRoaXMgY2FuIGJlIHVzZWQgdG8gc2ltdWxhdGUgYSBjb21wb25lbnQgZ29pbmcgdGhyb3VnaFxuICAgKiBhbiB1bm1vdW50L21vdW50IGxpZmVjeWNsZS5cbiAgICpcbiAgICogQHJldHVybnMge1JlYWN0V3JhcHBlcn1cbiAgICovXG4gIG1vdW50KCkge1xuICAgIGlmICh0aGlzW1JPT1RdICE9PSB0aGlzKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1JlYWN0V3JhcHBlcjo6bW91bnQoKSBjYW4gb25seSBiZSBjYWxsZWQgb24gdGhlIHJvb3QnKTtcbiAgICB9XG4gICAgdGhpc1tSRU5ERVJFUl0ucmVuZGVyKHRoaXNbVU5SRU5ERVJFRF0sIHRoaXNbT1BUSU9OU10uY29udGV4dCwgKCkgPT4gdGhpcy51cGRhdGUoKSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogQSBtZXRob2QgdGhhdCBzZXRzIHRoZSBwcm9wcyBvZiB0aGUgcm9vdCBjb21wb25lbnQsIGFuZCByZS1yZW5kZXJzLiBVc2VmdWwgZm9yIHdoZW4geW91IGFyZVxuICAgKiB3YW50aW5nIHRvIHRlc3QgaG93IHRoZSBjb21wb25lbnQgYmVoYXZlcyBvdmVyIHRpbWUgd2l0aCBjaGFuZ2luZyBwcm9wcy4gQ2FsbGluZyB0aGlzLCBmb3JcbiAgICogaW5zdGFuY2UsIHdpbGwgY2FsbCB0aGUgYGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHNgIGxpZmVjeWNsZSBtZXRob2QuXG4gICAqXG4gICAqIFNpbWlsYXIgdG8gYHNldFN0YXRlYCwgdGhpcyBtZXRob2QgYWNjZXB0cyBhIHByb3BzIG9iamVjdCBhbmQgd2lsbCBtZXJnZSBpdCBpbiB3aXRoIHRoZSBhbHJlYWR5XG4gICAqIGV4aXN0aW5nIHByb3BzLlxuICAgKlxuICAgKiBOT1RFOiBjYW4gb25seSBiZSBjYWxsZWQgb24gYSB3cmFwcGVyIGluc3RhbmNlIHRoYXQgaXMgYWxzbyB0aGUgcm9vdCBpbnN0YW5jZS5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IHByb3BzIG9iamVjdFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYiAtIGNhbGxiYWNrIGZ1bmN0aW9uXG4gICAqIEByZXR1cm5zIHtSZWFjdFdyYXBwZXJ9XG4gICAqL1xuICBzZXRQcm9wcyhwcm9wcywgY2FsbGJhY2sgPSB1bmRlZmluZWQpIHtcbiAgICBpZiAodGhpc1tST09UXSAhPT0gdGhpcykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdSZWFjdFdyYXBwZXI6OnNldFByb3BzKCkgY2FuIG9ubHkgYmUgY2FsbGVkIG9uIHRoZSByb290Jyk7XG4gICAgfVxuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSAmJiB0eXBlb2YgY2FsbGJhY2sgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1JlYWN0V3JhcHBlcjo6c2V0UHJvcHMoKSBleHBlY3RzIGEgZnVuY3Rpb24gYXMgaXRzIHNlY29uZCBhcmd1bWVudCcpO1xuICAgIH1cbiAgICBjb25zdCBhZGFwdGVyID0gZ2V0QWRhcHRlcih0aGlzW09QVElPTlNdKTtcbiAgICB0aGlzW1VOUkVOREVSRURdID0gY2xvbmVFbGVtZW50KGFkYXB0ZXIsIHRoaXNbVU5SRU5ERVJFRF0sIHByb3BzKTtcbiAgICB0aGlzW1JFTkRFUkVSXS5yZW5kZXIodGhpc1tVTlJFTkRFUkVEXSwgbnVsbCwgKCkgPT4ge1xuICAgICAgdGhpcy51cGRhdGUoKTtcbiAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIEEgbWV0aG9kIHRvIGludm9rZSBgc2V0U3RhdGVgIG9uIHRoZSByb290IGNvbXBvbmVudCBpbnN0YW5jZSBzaW1pbGFyIHRvIGhvdyB5b3UgbWlnaHQgaW4gdGhlXG4gICAqIGRlZmluaXRpb24gb2YgdGhlIGNvbXBvbmVudCwgYW5kIHJlLXJlbmRlcnMuICBUaGlzIG1ldGhvZCBpcyB1c2VmdWwgZm9yIHRlc3RpbmcgeW91ciBjb21wb25lbnRcbiAgICogaW4gaGFyZCB0byBhY2hpZXZlIHN0YXRlcywgaG93ZXZlciBzaG91bGQgYmUgdXNlZCBzcGFyaW5nbHkuIElmIHBvc3NpYmxlLCB5b3Ugc2hvdWxkIHV0aWxpemVcbiAgICogeW91ciBjb21wb25lbnQncyBleHRlcm5hbCBBUEkgaW4gb3JkZXIgdG8gZ2V0IGl0IGludG8gd2hhdGV2ZXIgc3RhdGUgeW91IHdhbnQgdG8gdGVzdCwgaW4gb3JkZXJcbiAgICogdG8gYmUgYXMgYWNjdXJhdGUgb2YgYSB0ZXN0IGFzIHBvc3NpYmxlLiBUaGlzIGlzIG5vdCBhbHdheXMgcHJhY3RpY2FsLCBob3dldmVyLlxuICAgKlxuICAgKiBOT1RFOiBjYW4gb25seSBiZSBjYWxsZWQgb24gYSB3cmFwcGVyIGluc3RhbmNlIHRoYXQgaXMgYWxzbyB0aGUgcm9vdCBpbnN0YW5jZS5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IHN0YXRlIHRvIG1lcmdlXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNiIC0gY2FsbGJhY2sgZnVuY3Rpb25cbiAgICogQHJldHVybnMge1JlYWN0V3JhcHBlcn1cbiAgICovXG4gIHNldFN0YXRlKHN0YXRlLCBjYWxsYmFjayA9IHVuZGVmaW5lZCkge1xuICAgIGlmICh0aGlzLmluc3RhbmNlKCkgPT09IG51bGwgfHwgdGhpcy5nZXROb2RlSW50ZXJuYWwoKS5ub2RlVHlwZSAhPT0gJ2NsYXNzJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdSZWFjdFdyYXBwZXI6OnNldFN0YXRlKCkgY2FuIG9ubHkgYmUgY2FsbGVkIG9uIGNsYXNzIGNvbXBvbmVudHMnKTtcbiAgICB9XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIHR5cGVvZiBjYWxsYmFjayAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignUmVhY3RXcmFwcGVyOjpzZXRTdGF0ZSgpIGV4cGVjdHMgYSBmdW5jdGlvbiBhcyBpdHMgc2Vjb25kIGFyZ3VtZW50Jyk7XG4gICAgfVxuICAgIHRoaXMuaW5zdGFuY2UoKS5zZXRTdGF0ZShzdGF0ZSwgKCkgPT4ge1xuICAgICAgdGhpcy51cGRhdGUoKTtcbiAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICBjb25zdCBhZGFwdGVyID0gZ2V0QWRhcHRlcih0aGlzW09QVElPTlNdKTtcbiAgICAgICAgY29uc3QgaW5zdGFuY2UgPSB0aGlzLmluc3RhbmNlKCk7XG4gICAgICAgIGlmIChhZGFwdGVyLmludm9rZVNldFN0YXRlQ2FsbGJhY2spIHtcbiAgICAgICAgICBhZGFwdGVyLmludm9rZVNldFN0YXRlQ2FsbGJhY2soaW5zdGFuY2UsIGNhbGxiYWNrKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjYWxsYmFjay5jYWxsKGluc3RhbmNlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIEEgbWV0aG9kIHRoYXQgc2V0cyB0aGUgY29udGV4dCBvZiB0aGUgcm9vdCBjb21wb25lbnQsIGFuZCByZS1yZW5kZXJzLiBVc2VmdWwgZm9yIHdoZW4geW91IGFyZVxuICAgKiB3YW50aW5nIHRvIHRlc3QgaG93IHRoZSBjb21wb25lbnQgYmVoYXZlcyBvdmVyIHRpbWUgd2l0aCBjaGFuZ2luZyBjb250ZXh0cy5cbiAgICpcbiAgICogTk9URTogY2FuIG9ubHkgYmUgY2FsbGVkIG9uIGEgd3JhcHBlciBpbnN0YW5jZSB0aGF0IGlzIGFsc28gdGhlIHJvb3QgaW5zdGFuY2UuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBjb250ZXh0IG9iamVjdFxuICAgKiBAcmV0dXJucyB7UmVhY3RXcmFwcGVyfVxuICAgKi9cbiAgc2V0Q29udGV4dChjb250ZXh0KSB7XG4gICAgaWYgKHRoaXNbUk9PVF0gIT09IHRoaXMpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignUmVhY3RXcmFwcGVyOjpzZXRDb250ZXh0KCkgY2FuIG9ubHkgYmUgY2FsbGVkIG9uIHRoZSByb290Jyk7XG4gICAgfVxuICAgIGlmICghdGhpc1tPUFRJT05TXS5jb250ZXh0KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1JlYWN0V3JhcHBlcjo6c2V0Q29udGV4dCgpIGNhbiBvbmx5IGJlIGNhbGxlZCBvbiBhIHdyYXBwZXIgdGhhdCB3YXMgb3JpZ2luYWxseSBwYXNzZWQgYSBjb250ZXh0IG9wdGlvbicpO1xuICAgIH1cbiAgICB0aGlzW1JFTkRFUkVSXS5yZW5kZXIodGhpc1tVTlJFTkRFUkVEXSwgY29udGV4dCwgKCkgPT4gdGhpcy51cGRhdGUoKSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogV2hldGhlciBvciBub3QgYSBnaXZlbiByZWFjdCBlbGVtZW50IGV4aXN0cyBpbiB0aGUgbW91bnQgcmVuZGVyIHRyZWUuXG4gICAqXG4gICAqIEV4YW1wbGU6XG4gICAqIGBgYFxuICAgKiBjb25zdCB3cmFwcGVyID0gbW91bnQoPE15Q29tcG9uZW50IC8+KTtcbiAgICogZXhwZWN0KHdyYXBwZXIuY29udGFpbnMoPGRpdiBjbGFzc05hbWU9XCJmb28gYmFyXCIgLz4pKS50by5lcXVhbCh0cnVlKTtcbiAgICogYGBgXG4gICAqXG4gICAqIEBwYXJhbSB7UmVhY3RFbGVtZW50fEFycmF5PFJlYWN0RWxlbWVudD59IG5vZGVPck5vZGVzXG4gICAqIEByZXR1cm5zIHtCb29sZWFufVxuICAgKi9cbiAgY29udGFpbnMobm9kZU9yTm9kZXMpIHtcbiAgICBjb25zdCBhZGFwdGVyID0gZ2V0QWRhcHRlcih0aGlzW09QVElPTlNdKTtcblxuICAgIGNvbnN0IHByZWRpY2F0ZSA9IEFycmF5LmlzQXJyYXkobm9kZU9yTm9kZXMpXG4gICAgICA/IChvdGhlcikgPT4gY29udGFpbnNDaGlsZHJlblN1YkFycmF5KFxuICAgICAgICBub2RlRXF1YWwsXG4gICAgICAgIG90aGVyLFxuICAgICAgICBub2RlT3JOb2Rlcy5tYXAoKG5vZGUpID0+IGFkYXB0ZXIuZWxlbWVudFRvTm9kZShub2RlKSksXG4gICAgICApXG4gICAgICA6IChvdGhlcikgPT4gbm9kZUVxdWFsKGFkYXB0ZXIuZWxlbWVudFRvTm9kZShub2RlT3JOb2RlcyksIG90aGVyKTtcblxuICAgIHJldHVybiBmaW5kV2hlcmVVbndyYXBwZWQodGhpcywgcHJlZGljYXRlKS5sZW5ndGggPiAwO1xuICB9XG5cbiAgLyoqXG4gICAqIFdoZXRoZXIgb3Igbm90IGEgZ2l2ZW4gcmVhY3QgZWxlbWVudCBleGlzdHMgaW4gdGhlIGN1cnJlbnQgcmVuZGVyIHRyZWUuXG4gICAqIEl0IHdpbGwgZGV0ZXJtaW5lIGlmIG9uZSBvZiB0aGUgd3JhcHBlcnMgZWxlbWVudCBcImxvb2tzIGxpa2VcIiB0aGUgZXhwZWN0ZWRcbiAgICogZWxlbWVudCBieSBjaGVja2luZyBpZiBhbGwgcHJvcHMgb2YgdGhlIGV4cGVjdGVkIGVsZW1lbnQgYXJlIHByZXNlbnRcbiAgICogb24gdGhlIHdyYXBwZXJzIGVsZW1lbnQgYW5kIGVxdWFscyB0byBlYWNoIG90aGVyLlxuICAgKlxuICAgKiBFeGFtcGxlOlxuICAgKiBgYGBcbiAgICogLy8gTXlDb21wb25lbnQgb3V0cHV0cyA8ZGl2PjxkaXYgY2xhc3M9XCJmb29cIj5IZWxsbzwvZGl2PjwvZGl2PlxuICAgKiBjb25zdCB3cmFwcGVyID0gbW91bnQoPE15Q29tcG9uZW50IC8+KTtcbiAgICogZXhwZWN0KHdyYXBwZXIuY29udGFpbnNNYXRjaGluZ0VsZW1lbnQoPGRpdj5IZWxsbzwvZGl2PikpLnRvLmVxdWFsKHRydWUpO1xuICAgKiBgYGBcbiAgICpcbiAgICogQHBhcmFtIHtSZWFjdEVsZW1lbnR9IG5vZGVcbiAgICogQHJldHVybnMge0Jvb2xlYW59XG4gICAqL1xuICBjb250YWluc01hdGNoaW5nRWxlbWVudChub2RlKSB7XG4gICAgY29uc3QgcnN0Tm9kZSA9IGdldEFkYXB0ZXIodGhpc1tPUFRJT05TXSkuZWxlbWVudFRvTm9kZShub2RlKTtcbiAgICBjb25zdCBwcmVkaWNhdGUgPSAob3RoZXIpID0+IG5vZGVNYXRjaGVzKHJzdE5vZGUsIG90aGVyLCAoYSwgYikgPT4gYSA8PSBiKTtcbiAgICByZXR1cm4gZmluZFdoZXJlVW53cmFwcGVkKHRoaXMsIHByZWRpY2F0ZSkubGVuZ3RoID4gMDtcbiAgfVxuXG4gIC8qKlxuICAgKiBXaGV0aGVyIG9yIG5vdCBhbGwgdGhlIGdpdmVuIHJlYWN0IGVsZW1lbnRzIGV4aXN0IGluIHRoZSBjdXJyZW50IHJlbmRlciB0cmVlLlxuICAgKiBJdCB3aWxsIGRldGVybWluZSBpZiBvbmUgb2YgdGhlIHdyYXBwZXJzIGVsZW1lbnQgXCJsb29rcyBsaWtlXCIgdGhlIGV4cGVjdGVkXG4gICAqIGVsZW1lbnQgYnkgY2hlY2tpbmcgaWYgYWxsIHByb3BzIG9mIHRoZSBleHBlY3RlZCBlbGVtZW50IGFyZSBwcmVzZW50XG4gICAqIG9uIHRoZSB3cmFwcGVycyBlbGVtZW50IGFuZCBlcXVhbHMgdG8gZWFjaCBvdGhlci5cbiAgICpcbiAgICogRXhhbXBsZTpcbiAgICogYGBgXG4gICAqIGNvbnN0IHdyYXBwZXIgPSBtb3VudCg8TXlDb21wb25lbnQgLz4pO1xuICAgKiBleHBlY3Qod3JhcHBlci5jb250YWluc0FsbE1hdGNoaW5nRWxlbWVudHMoW1xuICAgKiAgIDxkaXY+SGVsbG88L2Rpdj4sXG4gICAqICAgPGRpdj5Hb29kYnllPC9kaXY+LFxuICAgKiBdKSkudG8uZXF1YWwodHJ1ZSk7XG4gICAqIGBgYFxuICAgKlxuICAgKiBAcGFyYW0ge0FycmF5PFJlYWN0RWxlbWVudD59IG5vZGVzXG4gICAqIEByZXR1cm5zIHtCb29sZWFufVxuICAgKi9cbiAgY29udGFpbnNBbGxNYXRjaGluZ0VsZW1lbnRzKG5vZGVzKSB7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KG5vZGVzKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignbm9kZXMgc2hvdWxkIGJlIGFuIEFycmF5Jyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5vZGVzLmV2ZXJ5KChub2RlKSA9PiB0aGlzLmNvbnRhaW5zTWF0Y2hpbmdFbGVtZW50KG5vZGUpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBXaGV0aGVyIG9yIG5vdCBvbmUgb2YgdGhlIGdpdmVuIHJlYWN0IGVsZW1lbnRzIGV4aXN0cyBpbiB0aGUgY3VycmVudCByZW5kZXIgdHJlZS5cbiAgICogSXQgd2lsbCBkZXRlcm1pbmUgaWYgb25lIG9mIHRoZSB3cmFwcGVycyBlbGVtZW50IFwibG9va3MgbGlrZVwiIHRoZSBleHBlY3RlZFxuICAgKiBlbGVtZW50IGJ5IGNoZWNraW5nIGlmIGFsbCBwcm9wcyBvZiB0aGUgZXhwZWN0ZWQgZWxlbWVudCBhcmUgcHJlc2VudFxuICAgKiBvbiB0aGUgd3JhcHBlcnMgZWxlbWVudCBhbmQgZXF1YWxzIHRvIGVhY2ggb3RoZXIuXG4gICAqXG4gICAqIEV4YW1wbGU6XG4gICAqIGBgYFxuICAgKiBjb25zdCB3cmFwcGVyID0gbW91bnQoPE15Q29tcG9uZW50IC8+KTtcbiAgICogZXhwZWN0KHdyYXBwZXIuY29udGFpbnNBbnlNYXRjaGluZ0VsZW1lbnRzKFtcbiAgICogICA8ZGl2PkhlbGxvPC9kaXY+LFxuICAgKiAgIDxkaXY+R29vZGJ5ZTwvZGl2PixcbiAgICogXSkpLnRvLmVxdWFsKHRydWUpO1xuICAgKiBgYGBcbiAgICpcbiAgICogQHBhcmFtIHtBcnJheTxSZWFjdEVsZW1lbnQ+fSBub2Rlc1xuICAgKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAgICovXG4gIGNvbnRhaW5zQW55TWF0Y2hpbmdFbGVtZW50cyhub2Rlcykge1xuICAgIHJldHVybiBBcnJheS5pc0FycmF5KG5vZGVzKSAmJiBub2Rlcy5zb21lKChub2RlKSA9PiB0aGlzLmNvbnRhaW5zTWF0Y2hpbmdFbGVtZW50KG5vZGUpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBXaGV0aGVyIG9yIG5vdCBhIGdpdmVuIHJlYWN0IGVsZW1lbnQgZXhpc3RzIGluIHRoZSByZW5kZXIgdHJlZS5cbiAgICpcbiAgICogRXhhbXBsZTpcbiAgICogYGBgXG4gICAqIGNvbnN0IHdyYXBwZXIgPSBtb3VudCg8TXlDb21wb25lbnQgLz4pO1xuICAgKiBleHBlY3Qod3JhcHBlci5jb250YWlucyg8ZGl2IGNsYXNzTmFtZT1cImZvbyBiYXJcIiAvPikpLnRvLmVxdWFsKHRydWUpO1xuICAgKiBgYGBcbiAgICpcbiAgICogQHBhcmFtIHtSZWFjdEVsZW1lbnR9IG5vZGVcbiAgICogQHJldHVybnMge0Jvb2xlYW59XG4gICAqL1xuICBlcXVhbHMobm9kZSkge1xuICAgIHJldHVybiB0aGlzLnNpbmdsZSgnZXF1YWxzJywgKCkgPT4gbm9kZUVxdWFsKHRoaXMuZ2V0Tm9kZUludGVybmFsKCksIG5vZGUpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBXaGV0aGVyIG9yIG5vdCBhIGdpdmVuIHJlYWN0IGVsZW1lbnQgbWF0Y2hlcyB0aGUgcmVuZGVyIHRyZWUuXG4gICAqIE1hdGNoIGlzIGJhc2VkIG9uIHRoZSBleHBlY3RlZCBlbGVtZW50IGFuZCBub3Qgb24gd3JhcHBlciByb290IG5vZGUuXG4gICAqIEl0IHdpbGwgZGV0ZXJtaW5lIGlmIHRoZSB3cmFwcGVyIHJvb3Qgbm9kZSBcImxvb2tzIGxpa2VcIiB0aGUgZXhwZWN0ZWRcbiAgICogZWxlbWVudCBieSBjaGVja2luZyBpZiBhbGwgcHJvcHMgb2YgdGhlIGV4cGVjdGVkIGVsZW1lbnQgYXJlIHByZXNlbnRcbiAgICogb24gdGhlIHdyYXBwZXIgcm9vdCBub2RlIGFuZCBlcXVhbHMgdG8gZWFjaCBvdGhlci5cbiAgICpcbiAgICogRXhhbXBsZTpcbiAgICogYGBgXG4gICAqIC8vIE15Q29tcG9uZW50IG91dHB1dHMgPGRpdiBjbGFzcz1cImZvb1wiPkhlbGxvPC9kaXY+XG4gICAqIGNvbnN0IHdyYXBwZXIgPSBtb3VudCg8TXlDb21wb25lbnQgLz4pO1xuICAgKiBleHBlY3Qod3JhcHBlci5tYXRjaGVzRWxlbWVudCg8ZGl2PkhlbGxvPC9kaXY+KSkudG8uZXF1YWwodHJ1ZSk7XG4gICAqIGBgYFxuICAgKlxuICAgKiBAcGFyYW0ge1JlYWN0RWxlbWVudH0gbm9kZVxuICAgKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAgICovXG4gIG1hdGNoZXNFbGVtZW50KG5vZGUpIHtcbiAgICByZXR1cm4gdGhpcy5zaW5nbGUoJ21hdGNoZXNFbGVtZW50JywgKCkgPT4ge1xuICAgICAgY29uc3QgYWRhcHRlciA9IGdldEFkYXB0ZXIodGhpc1tPUFRJT05TXSk7XG4gICAgICBjb25zdCByc3ROb2RlID0gYWRhcHRlci5lbGVtZW50VG9Ob2RlKG5vZGUpO1xuICAgICAgcmV0dXJuIG5vZGVNYXRjaGVzKHJzdE5vZGUsIHRoaXMuZ2V0Tm9kZUludGVybmFsKCksIChhLCBiKSA9PiBhIDw9IGIpO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEZpbmRzIGV2ZXJ5IG5vZGUgaW4gdGhlIHJlbmRlciB0cmVlIG9mIHRoZSBjdXJyZW50IHdyYXBwZXIgdGhhdCBtYXRjaGVzIHRoZSBwcm92aWRlZCBzZWxlY3Rvci5cbiAgICpcbiAgICogQHBhcmFtIHtFbnp5bWVTZWxlY3Rvcn0gc2VsZWN0b3JcbiAgICogQHJldHVybnMge1JlYWN0V3JhcHBlcn1cbiAgICovXG4gIGZpbmQoc2VsZWN0b3IpIHtcbiAgICByZXR1cm4gdGhpcy53cmFwKHJlZHVjZVRyZWVzQnlTZWxlY3RvcihzZWxlY3RvciwgdGhpcy5nZXROb2Rlc0ludGVybmFsKCkpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHdoZXRoZXIgb3Igbm90IGN1cnJlbnQgbm9kZSBtYXRjaGVzIGEgcHJvdmlkZWQgc2VsZWN0b3IuXG4gICAqXG4gICAqIE5PVEU6IGNhbiBvbmx5IGJlIGNhbGxlZCBvbiBhIHdyYXBwZXIgb2YgYSBzaW5nbGUgbm9kZS5cbiAgICpcbiAgICogQHBhcmFtIHtFbnp5bWVTZWxlY3Rvcn0gc2VsZWN0b3JcbiAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAqL1xuICBpcyhzZWxlY3Rvcikge1xuICAgIGNvbnN0IHByZWRpY2F0ZSA9IGJ1aWxkUHJlZGljYXRlKHNlbGVjdG9yKTtcbiAgICByZXR1cm4gdGhpcy5zaW5nbGUoJ2lzJywgKG4pID0+IHByZWRpY2F0ZShuKSk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0cnVlIGlmIHRoZSBjb21wb25lbnQgcmVuZGVyZWQgbm90aGluZywgaS5lLiwgbnVsbCBvciBmYWxzZS5cbiAgICpcbiAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAqL1xuICBpc0VtcHR5UmVuZGVyKCkge1xuICAgIGNvbnN0IG5vZGVzID0gdGhpcy5nZXROb2RlSW50ZXJuYWwoKTtcblxuICAgIHJldHVybiByZW5kZXJlZERpdmUobm9kZXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBuZXcgd3JhcHBlciBpbnN0YW5jZSB3aXRoIG9ubHkgdGhlIG5vZGVzIG9mIHRoZSBjdXJyZW50IHdyYXBwZXIgaW5zdGFuY2UgdGhhdCBtYXRjaFxuICAgKiB0aGUgcHJvdmlkZWQgcHJlZGljYXRlIGZ1bmN0aW9uLlxuICAgKlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcmVkaWNhdGVcbiAgICogQHJldHVybnMge1JlYWN0V3JhcHBlcn1cbiAgICovXG4gIGZpbHRlcldoZXJlKHByZWRpY2F0ZSkge1xuICAgIHJldHVybiBmaWx0ZXJXaGVyZVVud3JhcHBlZCh0aGlzLCAobikgPT4gcHJlZGljYXRlKHRoaXMud3JhcChuKSkpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBuZXcgd3JhcHBlciBpbnN0YW5jZSB3aXRoIG9ubHkgdGhlIG5vZGVzIG9mIHRoZSBjdXJyZW50IHdyYXBwZXIgaW5zdGFuY2UgdGhhdCBtYXRjaFxuICAgKiB0aGUgcHJvdmlkZWQgc2VsZWN0b3IuXG4gICAqXG4gICAqIEBwYXJhbSB7RW56eW1lU2VsZWN0b3J9IHNlbGVjdG9yXG4gICAqIEByZXR1cm5zIHtSZWFjdFdyYXBwZXJ9XG4gICAqL1xuICBmaWx0ZXIoc2VsZWN0b3IpIHtcbiAgICBjb25zdCBwcmVkaWNhdGUgPSBidWlsZFByZWRpY2F0ZShzZWxlY3Rvcik7XG4gICAgcmV0dXJuIGZpbHRlcldoZXJlVW53cmFwcGVkKHRoaXMsIHByZWRpY2F0ZSk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhIG5ldyB3cmFwcGVyIGluc3RhbmNlIHdpdGggb25seSB0aGUgbm9kZXMgb2YgdGhlIGN1cnJlbnQgd3JhcHBlciB0aGF0IGRpZCBub3QgbWF0Y2hcbiAgICogdGhlIHByb3ZpZGVkIHNlbGVjdG9yLiBFc3NlbnRpYWxseSB0aGUgaW52ZXJzZSBvZiBgZmlsdGVyYC5cbiAgICpcbiAgICogQHBhcmFtIHtFbnp5bWVTZWxlY3Rvcn0gc2VsZWN0b3JcbiAgICogQHJldHVybnMge1JlYWN0V3JhcHBlcn1cbiAgICovXG4gIG5vdChzZWxlY3Rvcikge1xuICAgIGNvbnN0IHByZWRpY2F0ZSA9IGJ1aWxkUHJlZGljYXRlKHNlbGVjdG9yKTtcbiAgICByZXR1cm4gZmlsdGVyV2hlcmVVbndyYXBwZWQodGhpcywgKG4pID0+ICFwcmVkaWNhdGUobikpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBzdHJpbmcgb2YgdGhlIHJlbmRlcmVkIHRleHQgb2YgdGhlIGN1cnJlbnQgcmVuZGVyIHRyZWUuICBUaGlzIGZ1bmN0aW9uIHNob3VsZCBiZVxuICAgKiBsb29rZWQgYXQgd2l0aCBza2VwdGljaXNtIGlmIGJlaW5nIHVzZWQgdG8gdGVzdCB3aGF0IHRoZSBhY3R1YWwgSFRNTCBvdXRwdXQgb2YgdGhlIGNvbXBvbmVudFxuICAgKiB3aWxsIGJlLiBJZiB0aGF0IGlzIHdoYXQgeW91IHdvdWxkIGxpa2UgdG8gdGVzdCwgdXNlIGVuenltZSdzIGByZW5kZXJgIGZ1bmN0aW9uIGluc3RlYWQuXG4gICAqXG4gICAqIE5PVEU6IGNhbiBvbmx5IGJlIGNhbGxlZCBvbiBhIHdyYXBwZXIgb2YgYSBzaW5nbGUgbm9kZS5cbiAgICpcbiAgICogQHJldHVybnMge1N0cmluZ31cbiAgICovXG4gIHRleHQoKSB7XG4gICAgY29uc3QgYWRhcHRlciA9IGdldEFkYXB0ZXIodGhpc1tPUFRJT05TXSk7XG4gICAgcmV0dXJuIHRoaXMuc2luZ2xlKCd0ZXh0JywgKG4pID0+IGdldFRleHRGcm9tSG9zdE5vZGVzKG4sIGFkYXB0ZXIpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBIVE1MIG9mIHRoZSBub2RlLlxuICAgKlxuICAgKiBOT1RFOiBjYW4gb25seSBiZSBjYWxsZWQgb24gYSB3cmFwcGVyIG9mIGEgc2luZ2xlIG5vZGUuXG4gICAqXG4gICAqIEByZXR1cm5zIHtTdHJpbmd9XG4gICAqL1xuICBodG1sKCkge1xuICAgIGNvbnN0IGFkYXB0ZXIgPSBnZXRBZGFwdGVyKHRoaXNbT1BUSU9OU10pO1xuICAgIHJldHVybiB0aGlzLnNpbmdsZSgnaHRtbCcsIChuKSA9PiBnZXRIVE1MRnJvbUhvc3ROb2RlcyhuLCBhZGFwdGVyKSk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgY3VycmVudCBub2RlIHJlbmRlcmVkIHRvIEhUTUwgYW5kIHdyYXBwZWQgaW4gYSBDaGVlcmlvV3JhcHBlci5cbiAgICpcbiAgICogTk9URTogY2FuIG9ubHkgYmUgY2FsbGVkIG9uIGEgd3JhcHBlciBvZiBhIHNpbmdsZSBub2RlLlxuICAgKlxuICAgKiBAcmV0dXJucyB7Q2hlZXJpb1dyYXBwZXJ9XG4gICAqL1xuICByZW5kZXIoKSB7XG4gICAgY29uc3QgaHRtbCA9IHRoaXMuaHRtbCgpO1xuICAgIHJldHVybiBsb2FkQ2hlZXJpb1Jvb3QoaHRtbCk7XG4gIH1cblxuICAvKipcbiAgICogVXNlZCB0byBzaW11bGF0ZSBldmVudHMuIFBhc3MgYW4gZXZlbnRuYW1lIGFuZCAob3B0aW9uYWxseSkgZXZlbnQgYXJndW1lbnRzLiBUaGlzIG1ldGhvZCBvZlxuICAgKiB0ZXN0aW5nIGV2ZW50cyBzaG91bGQgYmUgbWV0IHdpdGggc29tZSBza2VwdGljaXNtLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcbiAgICogQHBhcmFtIHtPYmplY3R9IG1vY2sgKG9wdGlvbmFsKVxuICAgKiBAcmV0dXJucyB7UmVhY3RXcmFwcGVyfVxuICAgKi9cbiAgc2ltdWxhdGUoZXZlbnQsIG1vY2sgPSB7fSkge1xuICAgIHJldHVybiB0aGlzLnNpbmdsZSgnc2ltdWxhdGUnLCAobikgPT4ge1xuICAgICAgdGhpc1tSRU5ERVJFUl0uc2ltdWxhdGVFdmVudChuLCBldmVudCwgbW9jayk7XG4gICAgICB0aGlzW1JPT1RdLnVwZGF0ZSgpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogVXNlZCB0byBzaW11bGF0ZSB0aHJvd2luZyBhIHJlbmRlcmluZyBlcnJvci4gUGFzcyBhbiBlcnJvciB0byB0aHJvdy5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IGVycm9yXG4gICAqIEByZXR1cm5zIHtSZWFjdFdyYXBwZXJ9XG4gICAqL1xuICBzaW11bGF0ZUVycm9yKGVycm9yKSB7XG4gICAgaWYgKHRoaXNbUk9PVF0gPT09IHRoaXMpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignUmVhY3RXcmFwcGVyOjpzaW11bGF0ZUVycm9yKCkgbWF5IG5vdCBiZSBjYWxsZWQgb24gdGhlIHJvb3QnKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5zaW5nbGUoJ3NpbXVsYXRlRXJyb3InLCAodGhpc05vZGUpID0+IHtcbiAgICAgIGlmICh0aGlzTm9kZS5ub2RlVHlwZSA9PT0gJ2hvc3QnKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignUmVhY3RXcmFwcGVyOjpzaW11bGF0ZUVycm9yKCkgY2FuIG9ubHkgYmUgY2FsbGVkIG9uIGN1c3RvbSBjb21wb25lbnRzJyk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHJlbmRlcmVyID0gdGhpc1tSRU5ERVJFUl07XG4gICAgICBpZiAodHlwZW9mIHJlbmRlcmVyLnNpbXVsYXRlRXJyb3IgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigneW91ciBhZGFwdGVyIGRvZXMgbm90IHN1cHBvcnQgYHNpbXVsYXRlRXJyb3JgLiBUcnkgdXBncmFkaW5nIGl0IScpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCByb290Tm9kZSA9IGdldFJvb3ROb2RlSW50ZXJuYWwodGhpcyk7XG4gICAgICBjb25zdCBub2RlSGllcmFyY2h5ID0gW3RoaXNOb2RlXS5jb25jYXQobm9kZVBhcmVudHModGhpcywgdGhpc05vZGUpKTtcbiAgICAgIHJlbmRlcmVyLnNpbXVsYXRlRXJyb3Iobm9kZUhpZXJhcmNoeSwgcm9vdE5vZGUsIGVycm9yKTtcblxuICAgICAgdGhpc1tST09UXS51cGRhdGUoKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHByb3BzIGhhc2ggZm9yIHRoZSByb290IG5vZGUgb2YgdGhlIHdyYXBwZXIuXG4gICAqXG4gICAqIE5PVEU6IGNhbiBvbmx5IGJlIGNhbGxlZCBvbiBhIHdyYXBwZXIgb2YgYSBzaW5nbGUgbm9kZS5cbiAgICpcbiAgICogQHJldHVybnMge09iamVjdH1cbiAgICovXG4gIHByb3BzKCkge1xuICAgIHJldHVybiB0aGlzLnNpbmdsZSgncHJvcHMnLCBwcm9wc09mTm9kZSk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgc3RhdGUgaGFzaCBmb3IgdGhlIHJvb3Qgbm9kZSBvZiB0aGUgd3JhcHBlci4gT3B0aW9uYWxseSBwYXNzIGluIGEgcHJvcCBuYW1lIGFuZCBpdFxuICAgKiB3aWxsIHJldHVybiBqdXN0IHRoYXQgdmFsdWUuXG4gICAqXG4gICAqIE5PVEU6IGNhbiBvbmx5IGJlIGNhbGxlZCBvbiBhIHdyYXBwZXIgb2YgYSBzaW5nbGUgbm9kZS5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgKG9wdGlvbmFsKVxuICAgKiBAcmV0dXJucyB7Kn1cbiAgICovXG4gIHN0YXRlKG5hbWUpIHtcbiAgICBjb25zdCB0aGlzTm9kZSA9IHRoaXNbUk9PVF0gPT09IHRoaXMgPyB0aGlzW1JFTkRFUkVSXS5nZXROb2RlKCkgOiB0aGlzLmdldE5vZGVJbnRlcm5hbCgpO1xuICAgIGlmICh0aGlzLmluc3RhbmNlKCkgPT09IG51bGwgfHwgdGhpc05vZGUubm9kZVR5cGUgIT09ICdjbGFzcycpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignUmVhY3RXcmFwcGVyOjpzdGF0ZSgpIGNhbiBvbmx5IGJlIGNhbGxlZCBvbiBjbGFzcyBjb21wb25lbnRzJyk7XG4gICAgfVxuICAgIGNvbnN0IF9zdGF0ZSA9IHRoaXMuc2luZ2xlKCdzdGF0ZScsICgpID0+IHRoaXMuaW5zdGFuY2UoKS5zdGF0ZSk7XG4gICAgaWYgKHR5cGVvZiBuYW1lICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgaWYgKF9zdGF0ZSA9PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYFJlYWN0V3JhcHBlcjo6c3RhdGUoXCIke25hbWV9XCIpIHJlcXVpcmVzIHRoYXQgXFxgc3RhdGVcXGAgbm90IGJlIFxcYG51bGxcXGAgb3IgXFxgdW5kZWZpbmVkXFxgYCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gX3N0YXRlW25hbWVdO1xuICAgIH1cbiAgICByZXR1cm4gX3N0YXRlO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGNvbnRleHQgaGFzaCBmb3IgdGhlIHJvb3Qgbm9kZSBvZiB0aGUgd3JhcHBlci5cbiAgICogT3B0aW9uYWxseSBwYXNzIGluIGEgcHJvcCBuYW1lIGFuZCBpdCB3aWxsIHJldHVybiBqdXN0IHRoYXQgdmFsdWUuXG4gICAqXG4gICAqIE5PVEU6IGNhbiBvbmx5IGJlIGNhbGxlZCBvbiBhIHdyYXBwZXIgb2YgYSBzaW5nbGUgbm9kZS5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgKG9wdGlvbmFsKVxuICAgKiBAcmV0dXJucyB7Kn1cbiAgICovXG4gIGNvbnRleHQobmFtZSkge1xuICAgIGlmICh0aGlzW1JPT1RdICE9PSB0aGlzKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1JlYWN0V3JhcHBlcjo6Y29udGV4dCgpIGNhbiBvbmx5IGJlIGNhbGxlZCBvbiB0aGUgcm9vdCcpO1xuICAgIH1cbiAgICBjb25zdCBpbnN0YW5jZSA9IHRoaXMuc2luZ2xlKCdjb250ZXh0JywgKCkgPT4gdGhpcy5pbnN0YW5jZSgpKTtcbiAgICBpZiAoaW5zdGFuY2UgPT09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignUmVhY3RXcmFwcGVyOjpjb250ZXh0KCkgY2FuIG9ubHkgYmUgY2FsbGVkIG9uIGNvbXBvbmVudHMgd2l0aCBpbnN0YW5jZXMnKTtcbiAgICB9XG4gICAgY29uc3QgX2NvbnRleHQgPSBpbnN0YW5jZS5jb250ZXh0O1xuICAgIGlmICh0eXBlb2YgbmFtZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHJldHVybiBfY29udGV4dFtuYW1lXTtcbiAgICB9XG4gICAgcmV0dXJuIF9jb250ZXh0O1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBuZXcgd3JhcHBlciB3aXRoIGFsbCBvZiB0aGUgY2hpbGRyZW4gb2YgdGhlIGN1cnJlbnQgd3JhcHBlci5cbiAgICpcbiAgICogQHBhcmFtIHtFbnp5bWVTZWxlY3Rvcn0gW3NlbGVjdG9yXVxuICAgKiBAcmV0dXJucyB7UmVhY3RXcmFwcGVyfVxuICAgKi9cbiAgY2hpbGRyZW4oc2VsZWN0b3IpIHtcbiAgICBjb25zdCBhbGxDaGlsZHJlbiA9IHRoaXMuZmxhdE1hcCgobikgPT4gY2hpbGRyZW5PZk5vZGUobi5nZXROb2RlSW50ZXJuYWwoKSkpO1xuICAgIHJldHVybiBzZWxlY3RvciA/IGFsbENoaWxkcmVuLmZpbHRlcihzZWxlY3RvcikgOiBhbGxDaGlsZHJlbjtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgbmV3IHdyYXBwZXIgd2l0aCBhIHNwZWNpZmljIGNoaWxkXG4gICAqXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbaW5kZXhdXG4gICAqIEByZXR1cm5zIHtSZWFjdFdyYXBwZXJ9XG4gICAqL1xuICBjaGlsZEF0KGluZGV4KSB7XG4gICAgcmV0dXJuIHRoaXMuc2luZ2xlKCdjaGlsZEF0JywgKCkgPT4gdGhpcy5jaGlsZHJlbigpLmF0KGluZGV4KSk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhIHdyYXBwZXIgYXJvdW5kIGFsbCBvZiB0aGUgcGFyZW50cy9hbmNlc3RvcnMgb2YgdGhlIHdyYXBwZXIuIERvZXMgbm90IGluY2x1ZGUgdGhlIG5vZGVcbiAgICogaW4gdGhlIGN1cnJlbnQgd3JhcHBlci5cbiAgICpcbiAgICogTk9URTogY2FuIG9ubHkgYmUgY2FsbGVkIG9uIGEgd3JhcHBlciBvZiBhIHNpbmdsZSBub2RlLlxuICAgKlxuICAgKiBAcGFyYW0ge0VuenltZVNlbGVjdG9yfSBbc2VsZWN0b3JdXG4gICAqIEByZXR1cm5zIHtSZWFjdFdyYXBwZXJ9XG4gICAqL1xuICBwYXJlbnRzKHNlbGVjdG9yKSB7XG4gICAgcmV0dXJuIHRoaXMuc2luZ2xlKCdwYXJlbnRzJywgKG4pID0+IHtcbiAgICAgIGNvbnN0IGFsbFBhcmVudHMgPSB0aGlzLndyYXAobm9kZVBhcmVudHModGhpcywgbikpO1xuICAgICAgcmV0dXJuIHNlbGVjdG9yID8gYWxsUGFyZW50cy5maWx0ZXIoc2VsZWN0b3IpIDogYWxsUGFyZW50cztcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgd3JhcHBlciBhcm91bmQgdGhlIGltbWVkaWF0ZSBwYXJlbnQgb2YgdGhlIGN1cnJlbnQgbm9kZS5cbiAgICpcbiAgICogQHJldHVybnMge1JlYWN0V3JhcHBlcn1cbiAgICovXG4gIHBhcmVudCgpIHtcbiAgICByZXR1cm4gdGhpcy5mbGF0TWFwKChuKSA9PiBbbi5wYXJlbnRzKCkuZ2V0KDApXSk7XG4gIH1cblxuICAvKipcbiAgICpcbiAgICogQHBhcmFtIHtFbnp5bWVTZWxlY3Rvcn0gc2VsZWN0b3JcbiAgICogQHJldHVybnMge1JlYWN0V3JhcHBlcn1cbiAgICovXG4gIGNsb3Nlc3Qoc2VsZWN0b3IpIHtcbiAgICBpZiAodGhpcy5pcyhzZWxlY3RvcikpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBjb25zdCBtYXRjaGluZ0FuY2VzdG9ycyA9IHRoaXMucGFyZW50cygpLmZpbHRlcihzZWxlY3Rvcik7XG4gICAgcmV0dXJuIG1hdGNoaW5nQW5jZXN0b3JzLmxlbmd0aCA+IDAgPyBtYXRjaGluZ0FuY2VzdG9ycy5maXJzdCgpIDogdGhpcy5maW5kV2hlcmUoKCkgPT4gZmFsc2UpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHZhbHVlIG9mICBwcm9wIHdpdGggdGhlIGdpdmVuIG5hbWUgb2YgdGhlIHJvb3Qgbm9kZS5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IHByb3BOYW1lXG4gICAqIEByZXR1cm5zIHsqfVxuICAgKi9cbiAgcHJvcChwcm9wTmFtZSkge1xuICAgIHJldHVybiB0aGlzLnByb3BzKClbcHJvcE5hbWVdO1xuICB9XG5cbiAgLyoqXG4gICAqIFVzZWQgdG8gaW52b2tlIGEgZnVuY3Rpb24gcHJvcC5cbiAgICogV2lsbCBpbnZva2UgYW4gZnVuY3Rpb24gcHJvcCBhbmQgcmV0dXJuIGl0cyB2YWx1ZS5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IHByb3BOYW1lXG4gICAqIEByZXR1cm5zIHtBbnl9XG4gICAqL1xuICBpbnZva2UocHJvcE5hbWUpIHtcbiAgICByZXR1cm4gdGhpcy5zaW5nbGUoJ2ludm9rZScsICgpID0+IHtcbiAgICAgIGNvbnN0IGhhbmRsZXIgPSB0aGlzLnByb3AocHJvcE5hbWUpO1xuICAgICAgaWYgKHR5cGVvZiBoYW5kbGVyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1JlYWN0V3JhcHBlcjo6aW52b2tlKCkgcmVxdWlyZXMgdGhlIG5hbWUgb2YgYSBwcm9wIHdob3NlIHZhbHVlIGlzIGEgZnVuY3Rpb24nKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiAoLi4uYXJncykgPT4ge1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IHR5cGVvZiB0aGlzW1JFTkRFUkVSXS53cmFwSW52b2tlID09PSAnZnVuY3Rpb24nXG4gICAgICAgICAgPyB0aGlzW1JFTkRFUkVSXS53cmFwSW52b2tlKCgpID0+IGhhbmRsZXIoLi4uYXJncykpXG4gICAgICAgICAgOiBoYW5kbGVyKC4uLmFyZ3MpO1xuICAgICAgICB0aGlzW1JPT1RdLnVwZGF0ZSgpO1xuICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgICB9O1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSB3cmFwcGVyIG9mIHRoZSBub2RlIHJlbmRlcmVkIGJ5IHRoZSBwcm92aWRlZCByZW5kZXIgcHJvcC5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IHByb3BOYW1lXG4gICAqIEByZXR1cm5zIHtGdW5jdGlvbn1cbiAgICovXG4gIHJlbmRlclByb3AocHJvcE5hbWUpIHtcbiAgICBjb25zdCBhZGFwdGVyID0gZ2V0QWRhcHRlcih0aGlzW09QVElPTlNdKTtcbiAgICBpZiAodHlwZW9mIGFkYXB0ZXIud3JhcCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3lvdXIgYWRhcHRlciBkb2VzIG5vdCBzdXBwb3J0IGB3cmFwYC4gVHJ5IHVwZ3JhZGluZyBpdCEnKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5zaW5nbGUoJ3JlbmRlclByb3AnLCAobikgPT4ge1xuICAgICAgaWYgKG4ubm9kZVR5cGUgPT09ICdob3N0Jykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdSZWFjdFdyYXBwZXI6OnJlbmRlclByb3AoKSBjYW4gb25seSBiZSBjYWxsZWQgb24gY3VzdG9tIGNvbXBvbmVudHMnKTtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgcHJvcE5hbWUgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1JlYWN0V3JhcHBlcjo6cmVuZGVyUHJvcCgpOiBgcHJvcE5hbWVgIG11c3QgYmUgYSBzdHJpbmcnKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHByb3BzID0gdGhpcy5wcm9wcygpO1xuICAgICAgaWYgKCFoYXMocHJvcHMsIHByb3BOYW1lKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFJlYWN0V3JhcHBlcjo6cmVuZGVyUHJvcCgpOiBubyBwcm9wIGNhbGxlZCDigJwke3Byb3BOYW1lfeKAnCBmb3VuZGApO1xuICAgICAgfVxuICAgICAgY29uc3QgcHJvcFZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xuICAgICAgaWYgKHR5cGVvZiBwcm9wVmFsdWUgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgUmVhY3RXcmFwcGVyOjpyZW5kZXJQcm9wKCk6IGV4cGVjdGVkIHByb3Ag4oCcJHtwcm9wTmFtZX3igJwgdG8gY29udGFpbiBhIGZ1bmN0aW9uLCBidXQgaXQgaG9sZHMg4oCcJHt0eXBlb2YgcHJvcFZhbHVlfeKAnGApO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gKC4uLmFyZ3MpID0+IHtcbiAgICAgICAgY29uc3QgZWxlbWVudCA9IHByb3BWYWx1ZSguLi5hcmdzKTtcbiAgICAgICAgY29uc3Qgd3JhcHBlZCA9IGFkYXB0ZXIud3JhcChlbGVtZW50KTtcbiAgICAgICAgcmV0dXJuIHRoaXMud3JhcCh3cmFwcGVkLCBudWxsLCB0aGlzW09QVElPTlNdKTtcbiAgICAgIH07XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUga2V5IGFzc2lnbmVkIHRvIHRoZSBjdXJyZW50IG5vZGUuXG4gICAqXG4gICAqIEByZXR1cm5zIHtTdHJpbmd9XG4gICAqL1xuICBrZXkoKSB7XG4gICAgcmV0dXJuIHRoaXMuc2luZ2xlKCdrZXknLCAobikgPT4gKG4ua2V5ID09PSB1bmRlZmluZWQgPyBudWxsIDogbi5rZXkpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSB0eXBlIG9mIHRoZSByb290IG5vZGUgb2YgdGhpcyB3cmFwcGVyLiBJZiBpdCdzIGEgY29tcG9zaXRlIGNvbXBvbmVudCwgdGhpcyB3aWxsIGJlXG4gICAqIHRoZSBjb21wb25lbnQgY29uc3RydWN0b3IuIElmIGl0J3MgbmF0aXZlIERPTSBub2RlLCBpdCB3aWxsIGJlIGEgc3RyaW5nLlxuICAgKlxuICAgKiBAcmV0dXJucyB7U3RyaW5nfEZ1bmN0aW9ufVxuICAgKi9cbiAgdHlwZSgpIHtcbiAgICByZXR1cm4gdGhpcy5zaW5nbGUoJ3R5cGUnLCAobikgPT4gdHlwZU9mTm9kZShuKSk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgbmFtZSBvZiB0aGUgcm9vdCBub2RlIG9mIHRoaXMgd3JhcHBlci5cbiAgICpcbiAgICogSW4gb3JkZXIgb2YgcHJlY2VkZW5jZSA9PiB0eXBlLmRpc3BsYXlOYW1lIC0+IHR5cGUubmFtZSAtPiB0eXBlLlxuICAgKlxuICAgKiBAcmV0dXJucyB7U3RyaW5nfVxuICAgKi9cbiAgbmFtZSgpIHtcbiAgICBjb25zdCBhZGFwdGVyID0gZ2V0QWRhcHRlcih0aGlzW09QVElPTlNdKTtcbiAgICByZXR1cm4gdGhpcy5zaW5nbGUoJ25hbWUnLCAobikgPT4gKFxuICAgICAgYWRhcHRlci5kaXNwbGF5TmFtZU9mTm9kZSA/IGFkYXB0ZXIuZGlzcGxheU5hbWVPZk5vZGUobikgOiBkaXNwbGF5TmFtZU9mTm9kZShuKVxuICAgICkpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgd2hldGhlciBvciBub3QgdGhlIGN1cnJlbnQgcm9vdCBub2RlIGhhcyB0aGUgZ2l2ZW4gY2xhc3MgbmFtZSBvciBub3QuXG4gICAqXG4gICAqIE5PVEU6IGNhbiBvbmx5IGJlIGNhbGxlZCBvbiBhIHdyYXBwZXIgb2YgYSBzaW5nbGUgbm9kZS5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IGNsYXNzTmFtZVxuICAgKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAgICovXG4gIGhhc0NsYXNzKGNsYXNzTmFtZSkge1xuICAgIGlmICh0eXBlb2YgY2xhc3NOYW1lID09PSAnc3RyaW5nJyAmJiBjbGFzc05hbWUuaW5kZXhPZignLicpICE9PSAtMSkge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcbiAgICAgIGNvbnNvbGUud2FybignSXQgbG9va3MgbGlrZSB5b3VcXCdyZSBjYWxsaW5nIGBSZWFjdFdyYXBwZXI6Omhhc0NsYXNzKClgIHdpdGggYSBDU1Mgc2VsZWN0b3IuIGhhc0NsYXNzKCkgZXhwZWN0cyBhIGNsYXNzIG5hbWUsIG5vdCBhIENTUyBzZWxlY3Rvci4nKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuc2luZ2xlKCdoYXNDbGFzcycsIChuKSA9PiBoYXNDbGFzc05hbWUobiwgY2xhc3NOYW1lKSk7XG4gIH1cblxuICAvKipcbiAgICogSXRlcmF0ZXMgdGhyb3VnaCBlYWNoIG5vZGUgb2YgdGhlIGN1cnJlbnQgd3JhcHBlciBhbmQgZXhlY3V0ZXMgdGhlIHByb3ZpZGVkIGZ1bmN0aW9uIHdpdGggYVxuICAgKiB3cmFwcGVyIGFyb3VuZCB0aGUgY29ycmVzcG9uZGluZyBub2RlIHBhc3NlZCBpbiBhcyB0aGUgZmlyc3QgYXJndW1lbnQuXG4gICAqXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXG4gICAqIEByZXR1cm5zIHtSZWFjdFdyYXBwZXJ9XG4gICAqL1xuICBmb3JFYWNoKGZuKSB7XG4gICAgdGhpcy5nZXROb2Rlc0ludGVybmFsKCkuZm9yRWFjaCgobiwgaSkgPT4gZm4uY2FsbCh0aGlzLCB0aGlzLndyYXAobiksIGkpKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBNYXBzIHRoZSBjdXJyZW50IGFycmF5IG9mIG5vZGVzIHRvIGFub3RoZXIgYXJyYXkuIEVhY2ggbm9kZSBpcyBwYXNzZWQgaW4gYXMgYSBgUmVhY3RXcmFwcGVyYFxuICAgKiB0byB0aGUgbWFwIGZ1bmN0aW9uLlxuICAgKlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICAgKiBAcmV0dXJucyB7QXJyYXl9XG4gICAqL1xuICBtYXAoZm4pIHtcbiAgICByZXR1cm4gdGhpcy5nZXROb2Rlc0ludGVybmFsKCkubWFwKChuLCBpKSA9PiBmbi5jYWxsKHRoaXMsIHRoaXMud3JhcChuKSwgaSkpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlZHVjZXMgdGhlIGN1cnJlbnQgYXJyYXkgb2Ygbm9kZXMgdG8gYW5vdGhlciBhcnJheS5cbiAgICogRWFjaCBub2RlIGlzIHBhc3NlZCBpbiBhcyBhIGBTaGFsbG93V3JhcHBlcmAgdG8gdGhlIHJlZHVjZXIgZnVuY3Rpb24uXG4gICAqXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIC0gdGhlIHJlZHVjZXIgZnVuY3Rpb25cbiAgICogQHBhcmFtIHsqfSBpbml0aWFsVmFsdWUgLSB0aGUgaW5pdGlhbCB2YWx1ZVxuICAgKiBAcmV0dXJucyB7Kn1cbiAgICovXG4gIHJlZHVjZShmbiwgaW5pdGlhbFZhbHVlID0gdW5kZWZpbmVkKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICByZXR1cm4gdGhpcy5nZXROb2Rlc0ludGVybmFsKCkucmVkdWNlKFxuICAgICAgICAoYWNjdW0sIG4sIGkpID0+IGZuLmNhbGwodGhpcywgYWNjdW0sIHRoaXMud3JhcChuKSwgaSksXG4gICAgICAgIGluaXRpYWxWYWx1ZSxcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmdldE5vZGVzSW50ZXJuYWwoKS5yZWR1Y2UoKGFjY3VtLCBuLCBpKSA9PiBmbi5jYWxsKFxuICAgICAgdGhpcyxcbiAgICAgIGkgPT09IDEgPyB0aGlzLndyYXAoYWNjdW0pIDogYWNjdW0sXG4gICAgICB0aGlzLndyYXAobiksXG4gICAgICBpLFxuICAgICkpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlZHVjZXMgdGhlIGN1cnJlbnQgYXJyYXkgb2Ygbm9kZXMgdG8gYW5vdGhlciBhcnJheSwgZnJvbSByaWdodCB0byBsZWZ0LiBFYWNoIG5vZGUgaXMgcGFzc2VkXG4gICAqIGluIGFzIGEgYFNoYWxsb3dXcmFwcGVyYCB0byB0aGUgcmVkdWNlciBmdW5jdGlvbi5cbiAgICpcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gLSB0aGUgcmVkdWNlciBmdW5jdGlvblxuICAgKiBAcGFyYW0geyp9IGluaXRpYWxWYWx1ZSAtIHRoZSBpbml0aWFsIHZhbHVlXG4gICAqIEByZXR1cm5zIHsqfVxuICAgKi9cbiAgcmVkdWNlUmlnaHQoZm4sIGluaXRpYWxWYWx1ZSA9IHVuZGVmaW5lZCkge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0Tm9kZXNJbnRlcm5hbCgpLnJlZHVjZVJpZ2h0KFxuICAgICAgICAoYWNjdW0sIG4sIGkpID0+IGZuLmNhbGwodGhpcywgYWNjdW0sIHRoaXMud3JhcChuKSwgaSksXG4gICAgICAgIGluaXRpYWxWYWx1ZSxcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmdldE5vZGVzSW50ZXJuYWwoKS5yZWR1Y2VSaWdodCgoYWNjdW0sIG4sIGkpID0+IGZuLmNhbGwoXG4gICAgICB0aGlzLFxuICAgICAgaSA9PT0gMSA/IHRoaXMud3JhcChhY2N1bSkgOiBhY2N1bSxcbiAgICAgIHRoaXMud3JhcChuKSxcbiAgICAgIGksXG4gICAgKSk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhIG5ldyB3cmFwcGVyIHdpdGggYSBzdWJzZXQgb2YgdGhlIG5vZGVzIG9mIHRoZSBvcmlnaW5hbCB3cmFwcGVyLCBhY2NvcmRpbmcgdG8gdGhlXG4gICAqIHJ1bGVzIG9mIGBBcnJheSNzbGljZWAuXG4gICAqXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBiZWdpblxuICAgKiBAcGFyYW0ge051bWJlcn0gZW5kXG4gICAqIEByZXR1cm5zIHtTaGFsbG93V3JhcHBlcn1cbiAgICovXG4gIHNsaWNlKGJlZ2luLCBlbmQpIHtcbiAgICByZXR1cm4gdGhpcy53cmFwKHRoaXMuZ2V0Tm9kZXNJbnRlcm5hbCgpLnNsaWNlKGJlZ2luLCBlbmQpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHdoZXRoZXIgb3Igbm90IGFueSBvZiB0aGUgbm9kZXMgaW4gdGhlIHdyYXBwZXIgbWF0Y2ggdGhlIHByb3ZpZGVkIHNlbGVjdG9yLlxuICAgKlxuICAgKiBAcGFyYW0ge0VuenltZVNlbGVjdG9yfSBzZWxlY3RvclxuICAgKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAgICovXG4gIHNvbWUoc2VsZWN0b3IpIHtcbiAgICBpZiAodGhpc1tST09UXSA9PT0gdGhpcykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdSZWFjdFdyYXBwZXI6OnNvbWUoKSBjYW4gbm90IGJlIGNhbGxlZCBvbiB0aGUgcm9vdCcpO1xuICAgIH1cbiAgICBjb25zdCBwcmVkaWNhdGUgPSBidWlsZFByZWRpY2F0ZShzZWxlY3Rvcik7XG4gICAgcmV0dXJuIHRoaXMuZ2V0Tm9kZXNJbnRlcm5hbCgpLnNvbWUocHJlZGljYXRlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHdoZXRoZXIgb3Igbm90IGFueSBvZiB0aGUgbm9kZXMgaW4gdGhlIHdyYXBwZXIgcGFzcyB0aGUgcHJvdmlkZWQgcHJlZGljYXRlIGZ1bmN0aW9uLlxuICAgKlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcmVkaWNhdGVcbiAgICogQHJldHVybnMge0Jvb2xlYW59XG4gICAqL1xuICBzb21lV2hlcmUocHJlZGljYXRlKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0Tm9kZXNJbnRlcm5hbCgpLnNvbWUoKG4sIGkpID0+IHByZWRpY2F0ZS5jYWxsKHRoaXMsIHRoaXMud3JhcChuKSwgaSkpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgd2hldGhlciBvciBub3QgYWxsIG9mIHRoZSBub2RlcyBpbiB0aGUgd3JhcHBlciBtYXRjaCB0aGUgcHJvdmlkZWQgc2VsZWN0b3IuXG4gICAqXG4gICAqIEBwYXJhbSB7RW56eW1lU2VsZWN0b3J9IHNlbGVjdG9yXG4gICAqIEByZXR1cm5zIHtCb29sZWFufVxuICAgKi9cbiAgZXZlcnkoc2VsZWN0b3IpIHtcbiAgICBjb25zdCBwcmVkaWNhdGUgPSBidWlsZFByZWRpY2F0ZShzZWxlY3Rvcik7XG4gICAgcmV0dXJuIHRoaXMuZ2V0Tm9kZXNJbnRlcm5hbCgpLmV2ZXJ5KHByZWRpY2F0ZSk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB3aGV0aGVyIG9yIG5vdCBhbnkgb2YgdGhlIG5vZGVzIGluIHRoZSB3cmFwcGVyIHBhc3MgdGhlIHByb3ZpZGVkIHByZWRpY2F0ZSBmdW5jdGlvbi5cbiAgICpcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gcHJlZGljYXRlXG4gICAqIEByZXR1cm5zIHtCb29sZWFufVxuICAgKi9cbiAgZXZlcnlXaGVyZShwcmVkaWNhdGUpIHtcbiAgICByZXR1cm4gdGhpcy5nZXROb2Rlc0ludGVybmFsKCkuZXZlcnkoKG4sIGkpID0+IHByZWRpY2F0ZS5jYWxsKHRoaXMsIHRoaXMud3JhcChuKSwgaSkpO1xuICB9XG5cbiAgLyoqXG4gICAqIFV0aWxpdHkgbWV0aG9kIHVzZWQgdG8gY3JlYXRlIG5ldyB3cmFwcGVycyB3aXRoIGEgbWFwcGluZyBmdW5jdGlvbiB0aGF0IHJldHVybnMgYW4gYXJyYXkgb2ZcbiAgICogbm9kZXMgaW4gcmVzcG9uc2UgdG8gYSBzaW5nbGUgbm9kZSB3cmFwcGVyLiBUaGUgcmV0dXJuZWQgd3JhcHBlciBpcyBhIHNpbmdsZSB3cmFwcGVyIGFyb3VuZFxuICAgKiBhbGwgb2YgdGhlIG1hcHBlZCBub2RlcyBmbGF0dGVuZWQgKGFuZCBkZS1kdXBsaWNhdGVkKS5cbiAgICpcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cbiAgICogQHJldHVybnMge1JlYWN0V3JhcHBlcn1cbiAgICovXG4gIGZsYXRNYXAoZm4pIHtcbiAgICBjb25zdCBub2RlcyA9IHRoaXMuZ2V0Tm9kZXNJbnRlcm5hbCgpLm1hcCgobiwgaSkgPT4gZm4uY2FsbCh0aGlzLCB0aGlzLndyYXAobiksIGkpKTtcbiAgICBjb25zdCBmbGF0dGVuZWQgPSBmbGF0KG5vZGVzLCAxKTtcbiAgICByZXR1cm4gdGhpcy53cmFwKGZsYXR0ZW5lZC5maWx0ZXIoQm9vbGVhbikpO1xuICB9XG5cbiAgLyoqXG4gICAqIEZpbmRzIGFsbCBub2RlcyBpbiB0aGUgY3VycmVudCB3cmFwcGVyIG5vZGVzJyByZW5kZXIgdHJlZXMgdGhhdCBtYXRjaCB0aGUgcHJvdmlkZWQgcHJlZGljYXRlXG4gICAqIGZ1bmN0aW9uLlxuICAgKlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcmVkaWNhdGVcbiAgICogQHJldHVybnMge1JlYWN0V3JhcHBlcn1cbiAgICovXG4gIGZpbmRXaGVyZShwcmVkaWNhdGUpIHtcbiAgICByZXR1cm4gZmluZFdoZXJlVW53cmFwcGVkKHRoaXMsIChuKSA9PiB7XG4gICAgICBjb25zdCBub2RlID0gdGhpcy53cmFwKG4pO1xuICAgICAgcmV0dXJuIG5vZGUubGVuZ3RoID4gMCAmJiBwcmVkaWNhdGUobm9kZSk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgbm9kZSBhdCBhIGdpdmVuIGluZGV4IG9mIHRoZSBjdXJyZW50IHdyYXBwZXIuXG4gICAqXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBpbmRleFxuICAgKiBAcmV0dXJucyB7UmVhY3RFbGVtZW50fVxuICAgKi9cbiAgZ2V0KGluZGV4KSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0RWxlbWVudHMoKVtpbmRleF07XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhIHdyYXBwZXIgYXJvdW5kIHRoZSBub2RlIGF0IGEgZ2l2ZW4gaW5kZXggb2YgdGhlIGN1cnJlbnQgd3JhcHBlci5cbiAgICpcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGluZGV4XG4gICAqIEByZXR1cm5zIHtSZWFjdFdyYXBwZXJ9XG4gICAqL1xuICBhdChpbmRleCkge1xuICAgIGNvbnN0IG5vZGVzID0gdGhpcy5nZXROb2Rlc0ludGVybmFsKCk7XG4gICAgaWYgKGluZGV4IDwgbm9kZXMubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gdGhpcy53cmFwKG5vZGVzW2luZGV4XSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLndyYXAoW10pO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSB3cmFwcGVyIGFyb3VuZCB0aGUgZmlyc3Qgbm9kZSBvZiB0aGUgY3VycmVudCB3cmFwcGVyLlxuICAgKlxuICAgKiBAcmV0dXJucyB7UmVhY3RXcmFwcGVyfVxuICAgKi9cbiAgZmlyc3QoKSB7XG4gICAgcmV0dXJuIHRoaXMuYXQoMCk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhIHdyYXBwZXIgYXJvdW5kIHRoZSBsYXN0IG5vZGUgb2YgdGhlIGN1cnJlbnQgd3JhcHBlci5cbiAgICpcbiAgICogQHJldHVybnMge1JlYWN0V3JhcHBlcn1cbiAgICovXG4gIGxhc3QoKSB7XG4gICAgcmV0dXJuIHRoaXMuYXQodGhpcy5sZW5ndGggLSAxKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWxlZ2F0ZXMgdG8gZXhpc3RzKClcbiAgICpcbiAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAqL1xuICBpc0VtcHR5KCkge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG4gICAgY29uc29sZS53YXJuKCdFbnp5bWU6OkRlcHJlY2F0ZWQgbWV0aG9kIGlzRW1wdHkoKSBjYWxsZWQsIHVzZSBleGlzdHMoKSBpbnN0ZWFkLicpO1xuICAgIHJldHVybiAhdGhpcy5leGlzdHMoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIGN1cnJlbnQgd3JhcHBlciBoYXMgbm9kZXMuIEZhbHNlIG90aGVyd2lzZS5cbiAgICogSWYgY2FsbGVkIHdpdGggYSBzZWxlY3RvciBpdCByZXR1cm5zIGAuZmluZChzZWxlY3RvcikuZXhpc3RzKClgIGluc3RlYWQuXG4gICAqXG4gICAqIEBwYXJhbSB7RW56eW1lU2VsZWN0b3J9IHNlbGVjdG9yIChvcHRpb25hbClcbiAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAqL1xuICBleGlzdHMoc2VsZWN0b3IgPSBudWxsKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPiAwID8gdGhpcy5maW5kKHNlbGVjdG9yKS5leGlzdHMoKSA6IHRoaXMubGVuZ3RoID4gMDtcbiAgfVxuXG4gIC8qKlxuICAgKiBVdGlsaXR5IG1ldGhvZCB0aGF0IHRocm93cyBhbiBlcnJvciBpZiB0aGUgY3VycmVudCBpbnN0YW5jZSBoYXMgYSBsZW5ndGggb3RoZXIgdGhhbiBvbmUuXG4gICAqIFRoaXMgaXMgcHJpbWFyaWx5IHVzZWQgdG8gZW5mb3JjZSB0aGF0IGNlcnRhaW4gbWV0aG9kcyBhcmUgb25seSBydW4gb24gYSB3cmFwcGVyIHdoZW4gaXQgaXNcbiAgICogd3JhcHBpbmcgYSBzaW5nbGUgbm9kZS5cbiAgICpcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cbiAgICogQHJldHVybnMgeyp9XG4gICAqL1xuICBzaW5nbGUobmFtZSwgZm4pIHtcbiAgICBjb25zdCBmbk5hbWUgPSB0eXBlb2YgbmFtZSA9PT0gJ3N0cmluZycgPyBuYW1lIDogJ3Vua25vd24nO1xuICAgIGNvbnN0IGNhbGxiYWNrID0gdHlwZW9mIGZuID09PSAnZnVuY3Rpb24nID8gZm4gOiBuYW1lO1xuICAgIGlmICh0aGlzLmxlbmd0aCAhPT0gMSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBNZXRob2Qg4oCcJHtmbk5hbWV94oCdIGlzIG1lYW50IHRvIGJlIHJ1biBvbiAxIG5vZGUuICR7dGhpcy5sZW5ndGh9IGZvdW5kIGluc3RlYWQuYCk7XG4gICAgfVxuICAgIHJldHVybiBjYWxsYmFjay5jYWxsKHRoaXMsIHRoaXMuZ2V0Tm9kZUludGVybmFsKCkpO1xuICB9XG5cbiAgLyoqXG4gICAqIEhlbHBmdWwgdXRpbGl0eSBtZXRob2QgdG8gY3JlYXRlIGEgbmV3IHdyYXBwZXIgd2l0aCB0aGUgc2FtZSByb290IGFzIHRoZSBjdXJyZW50IHdyYXBwZXIsIHdpdGhcbiAgICogYW55IG5vZGVzIHBhc3NlZCBpbiBhcyB0aGUgZmlyc3QgcGFyYW1ldGVyIGF1dG9tYXRpY2FsbHkgd3JhcHBlZC5cbiAgICpcbiAgICogQHBhcmFtIHtSZWFjdFdyYXBwZXJ8UmVhY3RFbGVtZW50fEFycmF5PFJlYWN0RWxlbWVudD59IG5vZGVcbiAgICogQHJldHVybnMge1JlYWN0V3JhcHBlcn1cbiAgICovXG4gIHdyYXAobm9kZSwgcm9vdCA9IHRoaXNbUk9PVF0sIC4uLmFyZ3MpIHtcbiAgICBpZiAobm9kZSBpbnN0YW5jZW9mIFJlYWN0V3JhcHBlcikge1xuICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfVxuICAgIHJldHVybiBuZXcgUmVhY3RXcmFwcGVyKG5vZGUsIHJvb3QsIC4uLmFyZ3MpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYW4gSFRNTC1saWtlIHN0cmluZyBvZiB0aGUgc2hhbGxvdyByZW5kZXIgZm9yIGRlYnVnZ2luZyBwdXJwb3Nlcy5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSAtIFByb3BlcnR5IGJhZyBvZiBhZGRpdGlvbmFsIG9wdGlvbnMuXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuaWdub3JlUHJvcHNdIC0gaWYgdHJ1ZSwgcHJvcHMgYXJlIG9taXR0ZWQgZnJvbSB0aGUgc3RyaW5nLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLnZlcmJvc2VdIC0gaWYgdHJ1ZSwgYXJyYXlzIGFuZCBvYmplY3RzIHRvIGJlIHZlcmJvc2VseSBwcmludGVkLlxuICAgKiBAcmV0dXJucyB7U3RyaW5nfVxuICAgKi9cbiAgZGVidWcob3B0aW9ucyA9IHt9KSB7XG4gICAgcmV0dXJuIGRlYnVnTm9kZXModGhpcy5nZXROb2Rlc0ludGVybmFsKCksIG9wdGlvbnMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEludm9rZXMgaW50ZXJjZXB0ZXIgYW5kIHJldHVybnMgaXRzZWxmLiBpbnRlcmNlcHRlciBpcyBjYWxsZWQgd2l0aCBpdHNlbGYuXG4gICAqIFRoaXMgaXMgaGVscGZ1bCB3aGVuIGRlYnVnZ2luZyBub2RlcyBpbiBtZXRob2QgY2hhaW5zLlxuICAgKiBAcGFyYW0gZm5cbiAgICogQHJldHVybnMge1JlYWN0V3JhcHBlcn1cbiAgICovXG4gIHRhcChpbnRlcmNlcHRlcikge1xuICAgIGludGVyY2VwdGVyKHRoaXMpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIERldGFjaGVzIHRoZSByZWFjdCB0cmVlIGZyb20gdGhlIERPTS4gUnVucyBgUmVhY3RET00udW5tb3VudENvbXBvbmVudEF0Tm9kZSgpYCB1bmRlciB0aGUgaG9vZC5cbiAgICpcbiAgICogVGhpcyBtZXRob2Qgd2lsbCBtb3N0IGNvbW1vbmx5IGJlIHVzZWQgYXMgYSBcImNsZWFudXBcIiBtZXRob2QgaWYgeW91IGRlY2lkZSB0byB1c2UgdGhlXG4gICAqIGBhdHRhY2hUb2Agb3B0aW9uIGluIGBtb3VudChub2RlLCBvcHRpb25zKWAuXG4gICAqXG4gICAqIFRoZSBtZXRob2QgaXMgaW50ZW50aW9uYWxseSBub3QgXCJmbHVlbnRcIiAoaW4gdGhhdCBpdCBkb2Vzbid0IHJldHVybiBgdGhpc2ApIGJlY2F1c2UgeW91IHNob3VsZFxuICAgKiBub3QgYmUgZG9pbmcgYW55dGhpbmcgd2l0aCB0aGlzIHdyYXBwZXIgYWZ0ZXIgdGhpcyBtZXRob2QgaXMgY2FsbGVkLlxuICAgKi9cbiAgZGV0YWNoKCkge1xuICAgIGlmICh0aGlzW1JPT1RdICE9PSB0aGlzKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1JlYWN0V3JhcHBlcjo6ZGV0YWNoKCkgY2FuIG9ubHkgYmUgY2FsbGVkIG9uIHRoZSByb290Jyk7XG4gICAgfVxuICAgIGlmICghdGhpc1tPUFRJT05TXS5hdHRhY2hUbykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdSZWFjdFdyYXBwZXI6OmRldGFjaCgpIGNhbiBvbmx5IGJlIGNhbGxlZCBvbiB3aGVuIHRoZSBgYXR0YWNoVG9gIG9wdGlvbiB3YXMgcGFzc2VkIGludG8gYG1vdW50KClgLicpO1xuICAgIH1cbiAgICB0aGlzW1JFTkRFUkVSXS51bm1vdW50KCk7XG4gIH1cblxuICAvKipcbiAgICogU3RyaXBzIG91dCBhbGwgdGhlIG5vdCBob3N0LW5vZGVzIGZyb20gdGhlIGxpc3Qgb2Ygbm9kZXNcbiAgICpcbiAgICogVGhpcyBtZXRob2QgaXMgdXNlZnVsIGlmIHlvdSB3YW50IHRvIGNoZWNrIGZvciB0aGUgcHJlc2VuY2Ugb2YgaG9zdCBub2Rlc1xuICAgKiAoYWN0dWFsbHkgcmVuZGVyZWQgSFRNTCBlbGVtZW50cykgaWdub3JpbmcgdGhlIFJlYWN0IG5vZGVzLlxuICAgKi9cbiAgaG9zdE5vZGVzKCkge1xuICAgIHJldHVybiB0aGlzLmZpbHRlcldoZXJlKChuKSA9PiB0eXBlb2Ygbi50eXBlKCkgPT09ICdzdHJpbmcnKTtcbiAgfVxufVxuXG4vKipcbiAqIEEgKnNwZWNpYWwqIFwicm9vdFwiIHdyYXBwZXIgdGhhdCByZXByZXNlbnRzIHRoZSBjb21wb25lbnQgcGFzc2VkIGFzIGB3cmFwcGluZ0NvbXBvbmVudGAuXG4gKiBJdCBpcyBsaW5rZWQgdG8gdGhlIHByaW1hcnkgcm9vdCBzdWNoIHRoYXQgdXBkYXRlcyB0byBpdCB3aWxsIHVwZGF0ZSB0aGUgcHJpbWFyeSxcbiAqIGFuZCB2aWNlIHZlcnNhLlxuICpcbiAqIEBjbGFzcyBXcmFwcGluZ0NvbXBvbmVudFdyYXBwZXJcbiAqL1xuY2xhc3MgV3JhcHBpbmdDb21wb25lbnRXcmFwcGVyIGV4dGVuZHMgUmVhY3RXcmFwcGVyIHtcbiAgLyogZXNsaW50LWRpc2FibGUgY2xhc3MtbWV0aG9kcy11c2UtdGhpcyAqL1xuICBjb25zdHJ1Y3Rvcihyb290LCByZW5kZXJlcikge1xuICAgIHN1cGVyKHJlbmRlcmVyLmdldE5vZGUoKSwgcm9vdCk7XG5cbiAgICBwcml2YXRlU2V0KHRoaXMsIFJPT1QsIHRoaXMpO1xuICAgIHByaXZhdGVTZXQodGhpcywgUkVOREVSRVIsIHJlbmRlcmVyKTtcbiAgICB0aGlzW0xJTktFRF9ST09UU10ucHVzaChyb290KTtcbiAgfVxuXG4gIGdldFdyYXBwaW5nQ29tcG9uZW50KCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1JlYWN0V3JhcHBlcjo6Z2V0V3JhcHBpbmdDb21wb25lbnQoKSBjYW4gb25seSBiZSBjYWxsZWQgb24gdGhlIHJvb3QnKTtcbiAgfVxufVxuXG5pZiAoSVRFUkFUT1JfU1lNQk9MKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShSZWFjdFdyYXBwZXIucHJvdG90eXBlLCBJVEVSQVRPUl9TWU1CT0wsIHtcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGl0ZXJhdG9yKCkge1xuICAgICAgY29uc3QgaXRlciA9IHRoaXNbTk9ERVNdW0lURVJBVE9SX1NZTUJPTF0oKTtcbiAgICAgIGNvbnN0IGFkYXB0ZXIgPSBnZXRBZGFwdGVyKHRoaXNbT1BUSU9OU10pO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgW0lURVJBVE9SX1NZTUJPTF0oKSB7IHJldHVybiB0aGlzOyB9LFxuICAgICAgICBuZXh0KCkge1xuICAgICAgICAgIGNvbnN0IG5leHQgPSBpdGVyLm5leHQoKTtcbiAgICAgICAgICBpZiAobmV4dC5kb25lKSB7XG4gICAgICAgICAgICByZXR1cm4geyBkb25lOiB0cnVlIH07XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBkb25lOiBmYWxzZSxcbiAgICAgICAgICAgIHZhbHVlOiBhZGFwdGVyLm5vZGVUb0VsZW1lbnQobmV4dC52YWx1ZSksXG4gICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgIH07XG4gICAgfSxcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIHByaXZhdGVXYXJuaW5nKHByb3AsIGV4dHJhTWVzc2FnZSkge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoUmVhY3RXcmFwcGVyLnByb3RvdHlwZSwgcHJvcCwge1xuICAgIGdldCgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgXG4gICAgICAgIEF0dGVtcHRlZCB0byBhY2Nlc3MgUmVhY3RXcmFwcGVyOjoke3Byb3B9LCB3aGljaCB3YXMgcHJldmlvdXNseSBhIHByaXZhdGUgcHJvcGVydHkgb25cbiAgICAgICAgRW56eW1lIFJlYWN0V3JhcHBlciBpbnN0YW5jZXMsIGJ1dCBpcyBubyBsb25nZXIgYW5kIHNob3VsZCBub3QgYmUgcmVsaWVkIHVwb24uXG4gICAgICAgICR7ZXh0cmFNZXNzYWdlfVxuICAgICAgYCk7XG4gICAgfSxcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICBjb25maWd1cmFibGU6IGZhbHNlLFxuICB9KTtcbn1cblxucHJpdmF0ZVdhcm5pbmcoJ25vZGUnLCAnQ29uc2lkZXIgdXNpbmcgdGhlIGdldEVsZW1lbnQoKSBtZXRob2QgaW5zdGVhZC4nKTtcbnByaXZhdGVXYXJuaW5nKCdub2RlcycsICdDb25zaWRlciB1c2luZyB0aGUgZ2V0RWxlbWVudHMoKSBtZXRob2QgaW5zdGVhZC4nKTtcbnByaXZhdGVXYXJuaW5nKCdyZW5kZXJlcicsICcnKTtcbnByaXZhdGVXYXJuaW5nKCdvcHRpb25zJywgJycpO1xucHJpdmF0ZVdhcm5pbmcoJ2NvbXBsZXhTZWxlY3RvcicsICcnKTtcblxuZXhwb3J0IGRlZmF1bHQgUmVhY3RXcmFwcGVyO1xuIl19","map":{"version":3,"mappings":"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","names":["NODE","NODES","RENDERER","UNRENDERED","ROOT","OPTIONS","ROOT_NODES","WRAPPING_COMPONENT","LINKED_ROOTS","UPDATED_BY","findWhereUnwrapped","wrapper","predicate","filter","treeFilter","flatMap","n","getNodeInternal","filterWhereUnwrapped","wrap","getNodesInternal","Boolean","getRootNodeInternal","length","Error","nodeParents","node","privateSetNodes","nodes","Array","isArray","ReactWrapper","root","passedOptions","_classCallCheck","global","window","document","options","adapter","isValidElement","TypeError","renderer","createRenderer","mode","render","context","getNode","wrappingComponent","getWrappingComponentRenderer","WrappingComponentWrapper","push","single","_this","nodeToElement","map","_this2","nodeToHostNode","refname","instance","refs","_this3","update","forEach","linkedRoot","_this4","_this5","unmount","_this6","props","callback","undefined","arguments","_this7","state","nodeType","setState","_this8","invokeSetStateCallback","call","_this9","nodeOrNodes","other","nodeEqual","elementToNode","rstNode","a","b","every","_this10","containsMatchingElement","some","_this11","_this12","_this13","selector","_this14","html","event","mock","_this15","simulateEvent","error","thisNode","_this16","simulateError","rootNode","nodeHierarchy","concat","propsOfNode","name","_state","_this17","_this18","_context","allChildren","index","_this19","children","at","allParents","_this20","parents","get","is","matchingAncestors","first","findWhere","propName","handler","_this21","prop","args","response","wrapInvoke","RangeError","_this22","propValue","element","wrapped","key","displayNameOfNode","className","indexOf","console","warn","fn","i","_this23","_this24","initialValue","reduce","accum","_this25","reduceRight","_this26","begin","end","slice","_this27","_this28","_this29","flattened","_this30","getElements","exists","find","fnName","intercepter","attachTo","filterWhere","type","_this31","ITERATOR_SYMBOL","Object","defineProperty","prototype","configurable","value","iterator","iter","next","done","privateWarning","extraMessage","enumerable"],"sources":["/Users/sebas/Desktop/robofriends-testing/node_modules/enzyme/src/ReactWrapper.js"],"sourcesContent":["import flat from 'array.prototype.flat';\nimport has from 'has';\n\nimport {\n  containsChildrenSubArray,\n  typeOfNode,\n  displayNameOfNode,\n  ITERATOR_SYMBOL,\n  nodeEqual,\n  nodeMatches,\n  makeOptions,\n  sym,\n  privateSet,\n  cloneElement,\n  renderedDive,\n  isCustomComponent,\n  loadCheerioRoot,\n} from './Utils';\nimport getAdapter from './getAdapter';\nimport { debugNodes } from './Debug';\nimport {\n  propsOfNode,\n  hasClassName,\n  childrenOfNode,\n  parentsOfNode,\n  treeFilter,\n  getTextFromHostNodes,\n  getHTMLFromHostNodes,\n} from './RSTTraversal';\n\nimport { buildPredicate, reduceTreesBySelector } from './selectors';\n\nconst NODE = sym('__node__');\nconst NODES = sym('__nodes__');\nconst RENDERER = sym('__renderer__');\nconst UNRENDERED = sym('__unrendered__');\nconst ROOT = sym('__root__');\nconst OPTIONS = sym('__options__');\nconst ROOT_NODES = sym('__rootNodes__');\nconst WRAPPING_COMPONENT = sym('__wrappingComponent__');\nconst LINKED_ROOTS = sym('__linkedRoots__');\nconst UPDATED_BY = sym('__updatedBy__');\n\n/**\n * Finds all nodes in the current wrapper nodes' render trees that match the provided predicate\n * function.\n *\n * @param {ReactWrapper} wrapper\n * @param {Function} predicate\n * @param {Function} filter\n * @returns {ReactWrapper}\n */\nfunction findWhereUnwrapped(wrapper, predicate, filter = treeFilter) {\n  return wrapper.flatMap((n) => filter(n.getNodeInternal(), predicate));\n}\n\n/**\n * Returns a new wrapper instance with only the nodes of the current wrapper instance that match\n * the provided predicate function.\n *\n * @param {ReactWrapper} wrapper\n * @param {Function} predicate\n * @returns {ReactWrapper}\n */\nfunction filterWhereUnwrapped(wrapper, predicate) {\n  return wrapper.wrap(wrapper.getNodesInternal().filter(predicate).filter(Boolean));\n}\n\nfunction getRootNodeInternal(wrapper) {\n  if (wrapper[ROOT].length !== 1) {\n    throw new Error('getRootNodeInternal(wrapper) can only be called when wrapper wraps one node');\n  }\n  if (wrapper[ROOT] !== wrapper) {\n    return wrapper[ROOT_NODES][0];\n  }\n  return wrapper[ROOT][NODE];\n}\n\nfunction nodeParents(wrapper, node) {\n  return parentsOfNode(node, getRootNodeInternal(wrapper));\n}\n\nfunction privateSetNodes(wrapper, nodes) {\n  if (!nodes) {\n    privateSet(wrapper, NODE, null);\n    privateSet(wrapper, NODES, []);\n  } else if (!Array.isArray(nodes)) {\n    privateSet(wrapper, NODE, nodes);\n    privateSet(wrapper, NODES, [nodes]);\n  } else {\n    privateSet(wrapper, NODE, nodes[0]);\n    privateSet(wrapper, NODES, nodes);\n  }\n  privateSet(wrapper, 'length', wrapper[NODES].length);\n}\n\n/**\n * @class ReactWrapper\n */\nclass ReactWrapper {\n  constructor(nodes, root, passedOptions = {}) {\n    if (!global.window && !global.document) {\n      throw new Error('It looks like you called `mount()` without a global document being loaded.');\n    }\n    const options = makeOptions(passedOptions);\n\n    if (!root) {\n      const adapter = getAdapter(options);\n      if (!adapter.isValidElement(nodes)) {\n        throw new TypeError('ReactWrapper can only wrap valid elements');\n      }\n\n      const renderer = adapter.createRenderer({ mode: 'mount', ...options });\n      privateSet(this, RENDERER, renderer);\n      renderer.render(nodes, options.context);\n      privateSet(this, ROOT, this);\n      privateSetNodes(this, this[RENDERER].getNode());\n      privateSet(this, OPTIONS, options);\n      privateSet(this, LINKED_ROOTS, []);\n\n      if (isCustomComponent(options.wrappingComponent, adapter)) {\n        if (typeof this[RENDERER].getWrappingComponentRenderer !== 'function') {\n          throw new TypeError('your adapter does not support `wrappingComponent`. Try upgrading it!');\n        }\n\n        // eslint-disable-next-line no-use-before-define\n        privateSet(this, WRAPPING_COMPONENT, new WrappingComponentWrapper(\n          this, this[RENDERER].getWrappingComponentRenderer(),\n        ));\n        this[LINKED_ROOTS].push(this[WRAPPING_COMPONENT]);\n      }\n    } else {\n      privateSet(this, RENDERER, root[RENDERER]);\n      privateSet(this, ROOT, root);\n      privateSetNodes(this, nodes);\n      privateSet(this, ROOT_NODES, root[NODES]);\n      privateSet(this, OPTIONS, root[OPTIONS]);\n      privateSet(this, LINKED_ROOTS, []);\n    }\n    privateSet(this, UNRENDERED, nodes);\n    privateSet(this, UPDATED_BY, null);\n  }\n\n  /**\n   * Returns the root wrapper\n   *\n   * @return {ReactWrapper}\n   */\n  root() {\n    return this[ROOT];\n  }\n\n  /**\n   * Returns the wrapped component.\n   *\n   * @return {ReactComponent}\n   */\n  getNodeInternal() {\n    if (this.length !== 1) {\n      throw new Error('ReactWrapper::getNode() can only be called when wrapping one node');\n    }\n    return this[NODES][0];\n  }\n\n  /**\n   * Returns the the wrapped components.\n   *\n   * @return {Array<ReactComponent>}\n   */\n  getNodesInternal() {\n    return this[NODES];\n  }\n\n  /**\n   * Returns the wrapped ReactElement.\n   *\n   * @return {ReactElement}\n   */\n  getElement() {\n    return this.single('getElement', () => getAdapter(this[OPTIONS]).nodeToElement(this[NODE]));\n  }\n\n  /**\n   * Returns the wrapped ReactElements.\n   *\n   * @return {Array<ReactElement>}\n   */\n  getElements() {\n    return this[NODES].map((n) => getAdapter(this[OPTIONS]).nodeToElement(n));\n  }\n\n  // eslint-disable-next-line class-methods-use-this\n  getNode() {\n    throw new Error('ReactWrapper::getNode() is no longer supported. Use ReactWrapper::instance() instead');\n  }\n\n  // eslint-disable-next-line class-methods-use-this\n  getNodes() {\n    throw new Error('ReactWrapper::getNodes() is no longer supported.');\n  }\n\n  /**\n   * Returns the outer most DOMComponent of the current wrapper.\n   *\n   * NOTE: can only be called on a wrapper of a single node.\n   *\n   * @returns {DOMComponent}\n   */\n  getDOMNode() {\n    const adapter = getAdapter(this[OPTIONS]);\n    return this.single('getDOMNode', (n) => adapter.nodeToHostNode(n, true));\n  }\n\n  /**\n   * If the root component contained a ref, you can access it here and get the relevant\n   * react component instance or HTML element instance.\n   *\n   * NOTE: can only be called on a wrapper instance that is also the root instance.\n   *\n   * @param {String} refname\n   * @returns {ReactComponent | HTMLElement}\n   */\n  ref(refname) {\n    if (this[ROOT] !== this) {\n      throw new Error('ReactWrapper::ref(refname) can only be called on the root');\n    }\n    return this.instance().refs[refname];\n  }\n\n  /**\n   * Returns the wrapper's underlying instance.\n   *\n   * Example:\n   * ```\n   * const wrapper = mount(<MyComponent />);\n   * const inst = wrapper.instance();\n   * expect(inst).to.be.instanceOf(MyComponent);\n   * ```\n   * @returns {ReactComponent|DOMComponent}\n   */\n  instance() {\n    return this.single('instance', () => this[NODE].instance);\n  }\n\n  /**\n   * If a `wrappingComponent` was passed in `options`, this methods returns a `ReactWrapper` around\n   * the rendered `wrappingComponent`. This `ReactWrapper` can be used to update the\n   * `wrappingComponent`'s props, state, etc.\n   *\n   * @returns ReactWrapper\n   */\n  getWrappingComponent() {\n    if (this[ROOT] !== this) {\n      throw new Error('ReactWrapper::getWrappingComponent() can only be called on the root');\n    }\n    if (!this[OPTIONS].wrappingComponent) {\n      throw new Error('ReactWrapper::getWrappingComponent() can only be called on a wrapper that was originally passed a `wrappingComponent` option');\n    }\n    return this[WRAPPING_COMPONENT];\n  }\n\n  /**\n   * Forces a re-render. Useful to run before checking the render output if something external\n   * may be updating the state of the component somewhere.\n   *\n   * NOTE: no matter what instance this is called on, it will always update the root.\n   *\n   * @returns {ReactWrapper}\n   */\n  update() {\n    const root = this[ROOT];\n    if (this !== root) {\n      return root.update();\n    }\n    privateSetNodes(this, this[RENDERER].getNode());\n    this[LINKED_ROOTS].forEach((linkedRoot) => {\n      if (linkedRoot !== this[UPDATED_BY]) {\n        /* eslint-disable no-param-reassign */\n        // Only update a linked it root if it is not the originator of our update().\n        // This is needed to prevent infinite recursion when there is a bi-directional\n        // link between two roots.\n        linkedRoot[UPDATED_BY] = this;\n        try {\n          linkedRoot.update();\n        } finally {\n          linkedRoot[UPDATED_BY] = null;\n        }\n      }\n    });\n    return this;\n  }\n\n  /**\n   * A method that unmounts the component. This can be used to simulate a component going through\n   * and unmount/mount lifecycle.\n   *\n   * @returns {ReactWrapper}\n   */\n  unmount() {\n    if (this[ROOT] !== this) {\n      throw new Error('ReactWrapper::unmount() can only be called on the root');\n    }\n    this.single('unmount', () => {\n      this[RENDERER].unmount();\n      this.update();\n    });\n    return this;\n  }\n\n  /**\n   * A method that re-mounts the component, if it is not currently mounted.\n   * This can be used to simulate a component going through\n   * an unmount/mount lifecycle.\n   *\n   * @returns {ReactWrapper}\n   */\n  mount() {\n    if (this[ROOT] !== this) {\n      throw new Error('ReactWrapper::mount() can only be called on the root');\n    }\n    this[RENDERER].render(this[UNRENDERED], this[OPTIONS].context, () => this.update());\n    return this;\n  }\n\n  /**\n   * A method that sets the props of the root component, and re-renders. Useful for when you are\n   * wanting to test how the component behaves over time with changing props. Calling this, for\n   * instance, will call the `componentWillReceiveProps` lifecycle method.\n   *\n   * Similar to `setState`, this method accepts a props object and will merge it in with the already\n   * existing props.\n   *\n   * NOTE: can only be called on a wrapper instance that is also the root instance.\n   *\n   * @param {Object} props object\n   * @param {Function} cb - callback function\n   * @returns {ReactWrapper}\n   */\n  setProps(props, callback = undefined) {\n    if (this[ROOT] !== this) {\n      throw new Error('ReactWrapper::setProps() can only be called on the root');\n    }\n    if (arguments.length > 1 && typeof callback !== 'function') {\n      throw new TypeError('ReactWrapper::setProps() expects a function as its second argument');\n    }\n    const adapter = getAdapter(this[OPTIONS]);\n    this[UNRENDERED] = cloneElement(adapter, this[UNRENDERED], props);\n    this[RENDERER].render(this[UNRENDERED], null, () => {\n      this.update();\n      if (callback) {\n        callback();\n      }\n    });\n    return this;\n  }\n\n  /**\n   * A method to invoke `setState` on the root component instance similar to how you might in the\n   * definition of the component, and re-renders.  This method is useful for testing your component\n   * in hard to achieve states, however should be used sparingly. If possible, you should utilize\n   * your component's external API in order to get it into whatever state you want to test, in order\n   * to be as accurate of a test as possible. This is not always practical, however.\n   *\n   * NOTE: can only be called on a wrapper instance that is also the root instance.\n   *\n   * @param {Object} state to merge\n   * @param {Function} cb - callback function\n   * @returns {ReactWrapper}\n   */\n  setState(state, callback = undefined) {\n    if (this.instance() === null || this.getNodeInternal().nodeType !== 'class') {\n      throw new Error('ReactWrapper::setState() can only be called on class components');\n    }\n    if (arguments.length > 1 && typeof callback !== 'function') {\n      throw new TypeError('ReactWrapper::setState() expects a function as its second argument');\n    }\n    this.instance().setState(state, () => {\n      this.update();\n      if (callback) {\n        const adapter = getAdapter(this[OPTIONS]);\n        const instance = this.instance();\n        if (adapter.invokeSetStateCallback) {\n          adapter.invokeSetStateCallback(instance, callback);\n        } else {\n          callback.call(instance);\n        }\n      }\n    });\n    return this;\n  }\n\n  /**\n   * A method that sets the context of the root component, and re-renders. Useful for when you are\n   * wanting to test how the component behaves over time with changing contexts.\n   *\n   * NOTE: can only be called on a wrapper instance that is also the root instance.\n   *\n   * @param {Object} context object\n   * @returns {ReactWrapper}\n   */\n  setContext(context) {\n    if (this[ROOT] !== this) {\n      throw new Error('ReactWrapper::setContext() can only be called on the root');\n    }\n    if (!this[OPTIONS].context) {\n      throw new Error('ReactWrapper::setContext() can only be called on a wrapper that was originally passed a context option');\n    }\n    this[RENDERER].render(this[UNRENDERED], context, () => this.update());\n    return this;\n  }\n\n  /**\n   * Whether or not a given react element exists in the mount render tree.\n   *\n   * Example:\n   * ```\n   * const wrapper = mount(<MyComponent />);\n   * expect(wrapper.contains(<div className=\"foo bar\" />)).to.equal(true);\n   * ```\n   *\n   * @param {ReactElement|Array<ReactElement>} nodeOrNodes\n   * @returns {Boolean}\n   */\n  contains(nodeOrNodes) {\n    const adapter = getAdapter(this[OPTIONS]);\n\n    const predicate = Array.isArray(nodeOrNodes)\n      ? (other) => containsChildrenSubArray(\n        nodeEqual,\n        other,\n        nodeOrNodes.map((node) => adapter.elementToNode(node)),\n      )\n      : (other) => nodeEqual(adapter.elementToNode(nodeOrNodes), other);\n\n    return findWhereUnwrapped(this, predicate).length > 0;\n  }\n\n  /**\n   * Whether or not a given react element exists in the current render tree.\n   * It will determine if one of the wrappers element \"looks like\" the expected\n   * element by checking if all props of the expected element are present\n   * on the wrappers element and equals to each other.\n   *\n   * Example:\n   * ```\n   * // MyComponent outputs <div><div class=\"foo\">Hello</div></div>\n   * const wrapper = mount(<MyComponent />);\n   * expect(wrapper.containsMatchingElement(<div>Hello</div>)).to.equal(true);\n   * ```\n   *\n   * @param {ReactElement} node\n   * @returns {Boolean}\n   */\n  containsMatchingElement(node) {\n    const rstNode = getAdapter(this[OPTIONS]).elementToNode(node);\n    const predicate = (other) => nodeMatches(rstNode, other, (a, b) => a <= b);\n    return findWhereUnwrapped(this, predicate).length > 0;\n  }\n\n  /**\n   * Whether or not all the given react elements exist in the current render tree.\n   * It will determine if one of the wrappers element \"looks like\" the expected\n   * element by checking if all props of the expected element are present\n   * on the wrappers element and equals to each other.\n   *\n   * Example:\n   * ```\n   * const wrapper = mount(<MyComponent />);\n   * expect(wrapper.containsAllMatchingElements([\n   *   <div>Hello</div>,\n   *   <div>Goodbye</div>,\n   * ])).to.equal(true);\n   * ```\n   *\n   * @param {Array<ReactElement>} nodes\n   * @returns {Boolean}\n   */\n  containsAllMatchingElements(nodes) {\n    if (!Array.isArray(nodes)) {\n      throw new TypeError('nodes should be an Array');\n    }\n\n    return nodes.every((node) => this.containsMatchingElement(node));\n  }\n\n  /**\n   * Whether or not one of the given react elements exists in the current render tree.\n   * It will determine if one of the wrappers element \"looks like\" the expected\n   * element by checking if all props of the expected element are present\n   * on the wrappers element and equals to each other.\n   *\n   * Example:\n   * ```\n   * const wrapper = mount(<MyComponent />);\n   * expect(wrapper.containsAnyMatchingElements([\n   *   <div>Hello</div>,\n   *   <div>Goodbye</div>,\n   * ])).to.equal(true);\n   * ```\n   *\n   * @param {Array<ReactElement>} nodes\n   * @returns {Boolean}\n   */\n  containsAnyMatchingElements(nodes) {\n    return Array.isArray(nodes) && nodes.some((node) => this.containsMatchingElement(node));\n  }\n\n  /**\n   * Whether or not a given react element exists in the render tree.\n   *\n   * Example:\n   * ```\n   * const wrapper = mount(<MyComponent />);\n   * expect(wrapper.contains(<div className=\"foo bar\" />)).to.equal(true);\n   * ```\n   *\n   * @param {ReactElement} node\n   * @returns {Boolean}\n   */\n  equals(node) {\n    return this.single('equals', () => nodeEqual(this.getNodeInternal(), node));\n  }\n\n  /**\n   * Whether or not a given react element matches the render tree.\n   * Match is based on the expected element and not on wrapper root node.\n   * It will determine if the wrapper root node \"looks like\" the expected\n   * element by checking if all props of the expected element are present\n   * on the wrapper root node and equals to each other.\n   *\n   * Example:\n   * ```\n   * // MyComponent outputs <div class=\"foo\">Hello</div>\n   * const wrapper = mount(<MyComponent />);\n   * expect(wrapper.matchesElement(<div>Hello</div>)).to.equal(true);\n   * ```\n   *\n   * @param {ReactElement} node\n   * @returns {Boolean}\n   */\n  matchesElement(node) {\n    return this.single('matchesElement', () => {\n      const adapter = getAdapter(this[OPTIONS]);\n      const rstNode = adapter.elementToNode(node);\n      return nodeMatches(rstNode, this.getNodeInternal(), (a, b) => a <= b);\n    });\n  }\n\n  /**\n   * Finds every node in the render tree of the current wrapper that matches the provided selector.\n   *\n   * @param {EnzymeSelector} selector\n   * @returns {ReactWrapper}\n   */\n  find(selector) {\n    return this.wrap(reduceTreesBySelector(selector, this.getNodesInternal()));\n  }\n\n  /**\n   * Returns whether or not current node matches a provided selector.\n   *\n   * NOTE: can only be called on a wrapper of a single node.\n   *\n   * @param {EnzymeSelector} selector\n   * @returns {boolean}\n   */\n  is(selector) {\n    const predicate = buildPredicate(selector);\n    return this.single('is', (n) => predicate(n));\n  }\n\n  /**\n   * Returns true if the component rendered nothing, i.e., null or false.\n   *\n   * @returns {boolean}\n   */\n  isEmptyRender() {\n    const nodes = this.getNodeInternal();\n\n    return renderedDive(nodes);\n  }\n\n  /**\n   * Returns a new wrapper instance with only the nodes of the current wrapper instance that match\n   * the provided predicate function.\n   *\n   * @param {Function} predicate\n   * @returns {ReactWrapper}\n   */\n  filterWhere(predicate) {\n    return filterWhereUnwrapped(this, (n) => predicate(this.wrap(n)));\n  }\n\n  /**\n   * Returns a new wrapper instance with only the nodes of the current wrapper instance that match\n   * the provided selector.\n   *\n   * @param {EnzymeSelector} selector\n   * @returns {ReactWrapper}\n   */\n  filter(selector) {\n    const predicate = buildPredicate(selector);\n    return filterWhereUnwrapped(this, predicate);\n  }\n\n  /**\n   * Returns a new wrapper instance with only the nodes of the current wrapper that did not match\n   * the provided selector. Essentially the inverse of `filter`.\n   *\n   * @param {EnzymeSelector} selector\n   * @returns {ReactWrapper}\n   */\n  not(selector) {\n    const predicate = buildPredicate(selector);\n    return filterWhereUnwrapped(this, (n) => !predicate(n));\n  }\n\n  /**\n   * Returns a string of the rendered text of the current render tree.  This function should be\n   * looked at with skepticism if being used to test what the actual HTML output of the component\n   * will be. If that is what you would like to test, use enzyme's `render` function instead.\n   *\n   * NOTE: can only be called on a wrapper of a single node.\n   *\n   * @returns {String}\n   */\n  text() {\n    const adapter = getAdapter(this[OPTIONS]);\n    return this.single('text', (n) => getTextFromHostNodes(n, adapter));\n  }\n\n  /**\n   * Returns the HTML of the node.\n   *\n   * NOTE: can only be called on a wrapper of a single node.\n   *\n   * @returns {String}\n   */\n  html() {\n    const adapter = getAdapter(this[OPTIONS]);\n    return this.single('html', (n) => getHTMLFromHostNodes(n, adapter));\n  }\n\n  /**\n   * Returns the current node rendered to HTML and wrapped in a CheerioWrapper.\n   *\n   * NOTE: can only be called on a wrapper of a single node.\n   *\n   * @returns {CheerioWrapper}\n   */\n  render() {\n    const html = this.html();\n    return loadCheerioRoot(html);\n  }\n\n  /**\n   * Used to simulate events. Pass an eventname and (optionally) event arguments. This method of\n   * testing events should be met with some skepticism.\n   *\n   * @param {String} event\n   * @param {Object} mock (optional)\n   * @returns {ReactWrapper}\n   */\n  simulate(event, mock = {}) {\n    return this.single('simulate', (n) => {\n      this[RENDERER].simulateEvent(n, event, mock);\n      this[ROOT].update();\n      return this;\n    });\n  }\n\n  /**\n   * Used to simulate throwing a rendering error. Pass an error to throw.\n   *\n   * @param {String} error\n   * @returns {ReactWrapper}\n   */\n  simulateError(error) {\n    if (this[ROOT] === this) {\n      throw new Error('ReactWrapper::simulateError() may not be called on the root');\n    }\n\n    return this.single('simulateError', (thisNode) => {\n      if (thisNode.nodeType === 'host') {\n        throw new Error('ReactWrapper::simulateError() can only be called on custom components');\n      }\n\n      const renderer = this[RENDERER];\n      if (typeof renderer.simulateError !== 'function') {\n        throw new TypeError('your adapter does not support `simulateError`. Try upgrading it!');\n      }\n\n      const rootNode = getRootNodeInternal(this);\n      const nodeHierarchy = [thisNode].concat(nodeParents(this, thisNode));\n      renderer.simulateError(nodeHierarchy, rootNode, error);\n\n      this[ROOT].update();\n      return this;\n    });\n  }\n\n  /**\n   * Returns the props hash for the root node of the wrapper.\n   *\n   * NOTE: can only be called on a wrapper of a single node.\n   *\n   * @returns {Object}\n   */\n  props() {\n    return this.single('props', propsOfNode);\n  }\n\n  /**\n   * Returns the state hash for the root node of the wrapper. Optionally pass in a prop name and it\n   * will return just that value.\n   *\n   * NOTE: can only be called on a wrapper of a single node.\n   *\n   * @param {String} name (optional)\n   * @returns {*}\n   */\n  state(name) {\n    const thisNode = this[ROOT] === this ? this[RENDERER].getNode() : this.getNodeInternal();\n    if (this.instance() === null || thisNode.nodeType !== 'class') {\n      throw new Error('ReactWrapper::state() can only be called on class components');\n    }\n    const _state = this.single('state', () => this.instance().state);\n    if (typeof name !== 'undefined') {\n      if (_state == null) {\n        throw new TypeError(`ReactWrapper::state(\"${name}\") requires that \\`state\\` not be \\`null\\` or \\`undefined\\``);\n      }\n      return _state[name];\n    }\n    return _state;\n  }\n\n  /**\n   * Returns the context hash for the root node of the wrapper.\n   * Optionally pass in a prop name and it will return just that value.\n   *\n   * NOTE: can only be called on a wrapper of a single node.\n   *\n   * @param {String} name (optional)\n   * @returns {*}\n   */\n  context(name) {\n    if (this[ROOT] !== this) {\n      throw new Error('ReactWrapper::context() can only be called on the root');\n    }\n    const instance = this.single('context', () => this.instance());\n    if (instance === null) {\n      throw new Error('ReactWrapper::context() can only be called on components with instances');\n    }\n    const _context = instance.context;\n    if (typeof name !== 'undefined') {\n      return _context[name];\n    }\n    return _context;\n  }\n\n  /**\n   * Returns a new wrapper with all of the children of the current wrapper.\n   *\n   * @param {EnzymeSelector} [selector]\n   * @returns {ReactWrapper}\n   */\n  children(selector) {\n    const allChildren = this.flatMap((n) => childrenOfNode(n.getNodeInternal()));\n    return selector ? allChildren.filter(selector) : allChildren;\n  }\n\n  /**\n   * Returns a new wrapper with a specific child\n   *\n   * @param {Number} [index]\n   * @returns {ReactWrapper}\n   */\n  childAt(index) {\n    return this.single('childAt', () => this.children().at(index));\n  }\n\n  /**\n   * Returns a wrapper around all of the parents/ancestors of the wrapper. Does not include the node\n   * in the current wrapper.\n   *\n   * NOTE: can only be called on a wrapper of a single node.\n   *\n   * @param {EnzymeSelector} [selector]\n   * @returns {ReactWrapper}\n   */\n  parents(selector) {\n    return this.single('parents', (n) => {\n      const allParents = this.wrap(nodeParents(this, n));\n      return selector ? allParents.filter(selector) : allParents;\n    });\n  }\n\n  /**\n   * Returns a wrapper around the immediate parent of the current node.\n   *\n   * @returns {ReactWrapper}\n   */\n  parent() {\n    return this.flatMap((n) => [n.parents().get(0)]);\n  }\n\n  /**\n   *\n   * @param {EnzymeSelector} selector\n   * @returns {ReactWrapper}\n   */\n  closest(selector) {\n    if (this.is(selector)) {\n      return this;\n    }\n    const matchingAncestors = this.parents().filter(selector);\n    return matchingAncestors.length > 0 ? matchingAncestors.first() : this.findWhere(() => false);\n  }\n\n  /**\n   * Returns the value of  prop with the given name of the root node.\n   *\n   * @param {String} propName\n   * @returns {*}\n   */\n  prop(propName) {\n    return this.props()[propName];\n  }\n\n  /**\n   * Used to invoke a function prop.\n   * Will invoke an function prop and return its value.\n   *\n   * @param {String} propName\n   * @returns {Any}\n   */\n  invoke(propName) {\n    return this.single('invoke', () => {\n      const handler = this.prop(propName);\n      if (typeof handler !== 'function') {\n        throw new TypeError('ReactWrapper::invoke() requires the name of a prop whose value is a function');\n      }\n      return (...args) => {\n        const response = typeof this[RENDERER].wrapInvoke === 'function'\n          ? this[RENDERER].wrapInvoke(() => handler(...args))\n          : handler(...args);\n        this[ROOT].update();\n        return response;\n      };\n    });\n  }\n\n  /**\n   * Returns a wrapper of the node rendered by the provided render prop.\n   *\n   * @param {String} propName\n   * @returns {Function}\n   */\n  renderProp(propName) {\n    const adapter = getAdapter(this[OPTIONS]);\n    if (typeof adapter.wrap !== 'function') {\n      throw new RangeError('your adapter does not support `wrap`. Try upgrading it!');\n    }\n\n    return this.single('renderProp', (n) => {\n      if (n.nodeType === 'host') {\n        throw new TypeError('ReactWrapper::renderProp() can only be called on custom components');\n      }\n      if (typeof propName !== 'string') {\n        throw new TypeError('ReactWrapper::renderProp(): `propName` must be a string');\n      }\n      const props = this.props();\n      if (!has(props, propName)) {\n        throw new Error(`ReactWrapper::renderProp(): no prop called “${propName}“ found`);\n      }\n      const propValue = props[propName];\n      if (typeof propValue !== 'function') {\n        throw new TypeError(`ReactWrapper::renderProp(): expected prop “${propName}“ to contain a function, but it holds “${typeof propValue}“`);\n      }\n\n      return (...args) => {\n        const element = propValue(...args);\n        const wrapped = adapter.wrap(element);\n        return this.wrap(wrapped, null, this[OPTIONS]);\n      };\n    });\n  }\n\n  /**\n   * Returns the key assigned to the current node.\n   *\n   * @returns {String}\n   */\n  key() {\n    return this.single('key', (n) => (n.key === undefined ? null : n.key));\n  }\n\n  /**\n   * Returns the type of the root node of this wrapper. If it's a composite component, this will be\n   * the component constructor. If it's native DOM node, it will be a string.\n   *\n   * @returns {String|Function}\n   */\n  type() {\n    return this.single('type', (n) => typeOfNode(n));\n  }\n\n  /**\n   * Returns the name of the root node of this wrapper.\n   *\n   * In order of precedence => type.displayName -> type.name -> type.\n   *\n   * @returns {String}\n   */\n  name() {\n    const adapter = getAdapter(this[OPTIONS]);\n    return this.single('name', (n) => (\n      adapter.displayNameOfNode ? adapter.displayNameOfNode(n) : displayNameOfNode(n)\n    ));\n  }\n\n  /**\n   * Returns whether or not the current root node has the given class name or not.\n   *\n   * NOTE: can only be called on a wrapper of a single node.\n   *\n   * @param {String} className\n   * @returns {Boolean}\n   */\n  hasClass(className) {\n    if (typeof className === 'string' && className.indexOf('.') !== -1) {\n      // eslint-disable-next-line no-console\n      console.warn('It looks like you\\'re calling `ReactWrapper::hasClass()` with a CSS selector. hasClass() expects a class name, not a CSS selector.');\n    }\n    return this.single('hasClass', (n) => hasClassName(n, className));\n  }\n\n  /**\n   * Iterates through each node of the current wrapper and executes the provided function with a\n   * wrapper around the corresponding node passed in as the first argument.\n   *\n   * @param {Function} fn\n   * @returns {ReactWrapper}\n   */\n  forEach(fn) {\n    this.getNodesInternal().forEach((n, i) => fn.call(this, this.wrap(n), i));\n    return this;\n  }\n\n  /**\n   * Maps the current array of nodes to another array. Each node is passed in as a `ReactWrapper`\n   * to the map function.\n   *\n   * @param {Function} fn\n   * @returns {Array}\n   */\n  map(fn) {\n    return this.getNodesInternal().map((n, i) => fn.call(this, this.wrap(n), i));\n  }\n\n  /**\n   * Reduces the current array of nodes to another array.\n   * Each node is passed in as a `ShallowWrapper` to the reducer function.\n   *\n   * @param {Function} fn - the reducer function\n   * @param {*} initialValue - the initial value\n   * @returns {*}\n   */\n  reduce(fn, initialValue = undefined) {\n    if (arguments.length > 1) {\n      return this.getNodesInternal().reduce(\n        (accum, n, i) => fn.call(this, accum, this.wrap(n), i),\n        initialValue,\n      );\n    }\n    return this.getNodesInternal().reduce((accum, n, i) => fn.call(\n      this,\n      i === 1 ? this.wrap(accum) : accum,\n      this.wrap(n),\n      i,\n    ));\n  }\n\n  /**\n   * Reduces the current array of nodes to another array, from right to left. Each node is passed\n   * in as a `ShallowWrapper` to the reducer function.\n   *\n   * @param {Function} fn - the reducer function\n   * @param {*} initialValue - the initial value\n   * @returns {*}\n   */\n  reduceRight(fn, initialValue = undefined) {\n    if (arguments.length > 1) {\n      return this.getNodesInternal().reduceRight(\n        (accum, n, i) => fn.call(this, accum, this.wrap(n), i),\n        initialValue,\n      );\n    }\n    return this.getNodesInternal().reduceRight((accum, n, i) => fn.call(\n      this,\n      i === 1 ? this.wrap(accum) : accum,\n      this.wrap(n),\n      i,\n    ));\n  }\n\n  /**\n   * Returns a new wrapper with a subset of the nodes of the original wrapper, according to the\n   * rules of `Array#slice`.\n   *\n   * @param {Number} begin\n   * @param {Number} end\n   * @returns {ShallowWrapper}\n   */\n  slice(begin, end) {\n    return this.wrap(this.getNodesInternal().slice(begin, end));\n  }\n\n  /**\n   * Returns whether or not any of the nodes in the wrapper match the provided selector.\n   *\n   * @param {EnzymeSelector} selector\n   * @returns {Boolean}\n   */\n  some(selector) {\n    if (this[ROOT] === this) {\n      throw new Error('ReactWrapper::some() can not be called on the root');\n    }\n    const predicate = buildPredicate(selector);\n    return this.getNodesInternal().some(predicate);\n  }\n\n  /**\n   * Returns whether or not any of the nodes in the wrapper pass the provided predicate function.\n   *\n   * @param {Function} predicate\n   * @returns {Boolean}\n   */\n  someWhere(predicate) {\n    return this.getNodesInternal().some((n, i) => predicate.call(this, this.wrap(n), i));\n  }\n\n  /**\n   * Returns whether or not all of the nodes in the wrapper match the provided selector.\n   *\n   * @param {EnzymeSelector} selector\n   * @returns {Boolean}\n   */\n  every(selector) {\n    const predicate = buildPredicate(selector);\n    return this.getNodesInternal().every(predicate);\n  }\n\n  /**\n   * Returns whether or not any of the nodes in the wrapper pass the provided predicate function.\n   *\n   * @param {Function} predicate\n   * @returns {Boolean}\n   */\n  everyWhere(predicate) {\n    return this.getNodesInternal().every((n, i) => predicate.call(this, this.wrap(n), i));\n  }\n\n  /**\n   * Utility method used to create new wrappers with a mapping function that returns an array of\n   * nodes in response to a single node wrapper. The returned wrapper is a single wrapper around\n   * all of the mapped nodes flattened (and de-duplicated).\n   *\n   * @param {Function} fn\n   * @returns {ReactWrapper}\n   */\n  flatMap(fn) {\n    const nodes = this.getNodesInternal().map((n, i) => fn.call(this, this.wrap(n), i));\n    const flattened = flat(nodes, 1);\n    return this.wrap(flattened.filter(Boolean));\n  }\n\n  /**\n   * Finds all nodes in the current wrapper nodes' render trees that match the provided predicate\n   * function.\n   *\n   * @param {Function} predicate\n   * @returns {ReactWrapper}\n   */\n  findWhere(predicate) {\n    return findWhereUnwrapped(this, (n) => {\n      const node = this.wrap(n);\n      return node.length > 0 && predicate(node);\n    });\n  }\n\n  /**\n   * Returns the node at a given index of the current wrapper.\n   *\n   * @param {Number} index\n   * @returns {ReactElement}\n   */\n  get(index) {\n    return this.getElements()[index];\n  }\n\n  /**\n   * Returns a wrapper around the node at a given index of the current wrapper.\n   *\n   * @param {Number} index\n   * @returns {ReactWrapper}\n   */\n  at(index) {\n    const nodes = this.getNodesInternal();\n    if (index < nodes.length) {\n      return this.wrap(nodes[index]);\n    }\n    return this.wrap([]);\n  }\n\n  /**\n   * Returns a wrapper around the first node of the current wrapper.\n   *\n   * @returns {ReactWrapper}\n   */\n  first() {\n    return this.at(0);\n  }\n\n  /**\n   * Returns a wrapper around the last node of the current wrapper.\n   *\n   * @returns {ReactWrapper}\n   */\n  last() {\n    return this.at(this.length - 1);\n  }\n\n  /**\n   * Delegates to exists()\n   *\n   * @returns {boolean}\n   */\n  isEmpty() {\n    // eslint-disable-next-line no-console\n    console.warn('Enzyme::Deprecated method isEmpty() called, use exists() instead.');\n    return !this.exists();\n  }\n\n  /**\n   * Returns true if the current wrapper has nodes. False otherwise.\n   * If called with a selector it returns `.find(selector).exists()` instead.\n   *\n   * @param {EnzymeSelector} selector (optional)\n   * @returns {boolean}\n   */\n  exists(selector = null) {\n    return arguments.length > 0 ? this.find(selector).exists() : this.length > 0;\n  }\n\n  /**\n   * Utility method that throws an error if the current instance has a length other than one.\n   * This is primarily used to enforce that certain methods are only run on a wrapper when it is\n   * wrapping a single node.\n   *\n   * @param {Function} fn\n   * @returns {*}\n   */\n  single(name, fn) {\n    const fnName = typeof name === 'string' ? name : 'unknown';\n    const callback = typeof fn === 'function' ? fn : name;\n    if (this.length !== 1) {\n      throw new Error(`Method “${fnName}” is meant to be run on 1 node. ${this.length} found instead.`);\n    }\n    return callback.call(this, this.getNodeInternal());\n  }\n\n  /**\n   * Helpful utility method to create a new wrapper with the same root as the current wrapper, with\n   * any nodes passed in as the first parameter automatically wrapped.\n   *\n   * @param {ReactWrapper|ReactElement|Array<ReactElement>} node\n   * @returns {ReactWrapper}\n   */\n  wrap(node, root = this[ROOT], ...args) {\n    if (node instanceof ReactWrapper) {\n      return node;\n    }\n    return new ReactWrapper(node, root, ...args);\n  }\n\n  /**\n   * Returns an HTML-like string of the shallow render for debugging purposes.\n   *\n   * @param {Object} [options] - Property bag of additional options.\n   * @param {boolean} [options.ignoreProps] - if true, props are omitted from the string.\n   * @param {boolean} [options.verbose] - if true, arrays and objects to be verbosely printed.\n   * @returns {String}\n   */\n  debug(options = {}) {\n    return debugNodes(this.getNodesInternal(), options);\n  }\n\n  /**\n   * Invokes intercepter and returns itself. intercepter is called with itself.\n   * This is helpful when debugging nodes in method chains.\n   * @param fn\n   * @returns {ReactWrapper}\n   */\n  tap(intercepter) {\n    intercepter(this);\n    return this;\n  }\n\n  /**\n   * Detaches the react tree from the DOM. Runs `ReactDOM.unmountComponentAtNode()` under the hood.\n   *\n   * This method will most commonly be used as a \"cleanup\" method if you decide to use the\n   * `attachTo` option in `mount(node, options)`.\n   *\n   * The method is intentionally not \"fluent\" (in that it doesn't return `this`) because you should\n   * not be doing anything with this wrapper after this method is called.\n   */\n  detach() {\n    if (this[ROOT] !== this) {\n      throw new Error('ReactWrapper::detach() can only be called on the root');\n    }\n    if (!this[OPTIONS].attachTo) {\n      throw new Error('ReactWrapper::detach() can only be called on when the `attachTo` option was passed into `mount()`.');\n    }\n    this[RENDERER].unmount();\n  }\n\n  /**\n   * Strips out all the not host-nodes from the list of nodes\n   *\n   * This method is useful if you want to check for the presence of host nodes\n   * (actually rendered HTML elements) ignoring the React nodes.\n   */\n  hostNodes() {\n    return this.filterWhere((n) => typeof n.type() === 'string');\n  }\n}\n\n/**\n * A *special* \"root\" wrapper that represents the component passed as `wrappingComponent`.\n * It is linked to the primary root such that updates to it will update the primary,\n * and vice versa.\n *\n * @class WrappingComponentWrapper\n */\nclass WrappingComponentWrapper extends ReactWrapper {\n  /* eslint-disable class-methods-use-this */\n  constructor(root, renderer) {\n    super(renderer.getNode(), root);\n\n    privateSet(this, ROOT, this);\n    privateSet(this, RENDERER, renderer);\n    this[LINKED_ROOTS].push(root);\n  }\n\n  getWrappingComponent() {\n    throw new TypeError('ReactWrapper::getWrappingComponent() can only be called on the root');\n  }\n}\n\nif (ITERATOR_SYMBOL) {\n  Object.defineProperty(ReactWrapper.prototype, ITERATOR_SYMBOL, {\n    configurable: true,\n    value: function iterator() {\n      const iter = this[NODES][ITERATOR_SYMBOL]();\n      const adapter = getAdapter(this[OPTIONS]);\n      return {\n        [ITERATOR_SYMBOL]() { return this; },\n        next() {\n          const next = iter.next();\n          if (next.done) {\n            return { done: true };\n          }\n          return {\n            done: false,\n            value: adapter.nodeToElement(next.value),\n          };\n        },\n      };\n    },\n  });\n}\n\nfunction privateWarning(prop, extraMessage) {\n  Object.defineProperty(ReactWrapper.prototype, prop, {\n    get() {\n      throw new Error(`\n        Attempted to access ReactWrapper::${prop}, which was previously a private property on\n        Enzyme ReactWrapper instances, but is no longer and should not be relied upon.\n        ${extraMessage}\n      `);\n    },\n    enumerable: false,\n    configurable: false,\n  });\n}\n\nprivateWarning('node', 'Consider using the getElement() method instead.');\nprivateWarning('nodes', 'Consider using the getElements() method instead.');\nprivateWarning('renderer', '');\nprivateWarning('options', '');\nprivateWarning('complexSelector', '');\n\nexport default ReactWrapper;\n"]},"metadata":{},"sourceType":"script"}