{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) {\n  return typeof obj;\n} : function (obj) {\n  return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n};\n\nvar _slicedToArray = function () {\n  function sliceIterator(arr, i) {\n    var _arr = [];\n    var _n = true;\n    var _d = false;\n    var _e = undefined;\n\n    try {\n      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n        _arr.push(_s.value);\n\n        if (i && _arr.length === i) break;\n      }\n    } catch (err) {\n      _d = true;\n      _e = err;\n    } finally {\n      try {\n        if (!_n && _i[\"return\"]) _i[\"return\"]();\n      } finally {\n        if (_d) throw _e;\n      }\n    }\n\n    return _arr;\n  }\n\n  return function (arr, i) {\n    if (Array.isArray(arr)) {\n      return arr;\n    } else if (Symbol.iterator in Object(arr)) {\n      return sliceIterator(arr, i);\n    } else {\n      throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n    }\n  };\n}();\n\nexports.buildPredicate = buildPredicate;\nexports.reduceTreeBySelector = reduceTreeBySelector;\nexports.reduceTreesBySelector = reduceTreesBySelector;\n\nvar _rstSelectorParser = require('rst-selector-parser');\n\nvar _object = require('object.values');\n\nvar _object2 = _interopRequireDefault(_object);\n\nvar _arrayPrototype = require('array.prototype.flat');\n\nvar _arrayPrototype2 = _interopRequireDefault(_arrayPrototype);\n\nvar _objectIs = require('object-is');\n\nvar _objectIs2 = _interopRequireDefault(_objectIs);\n\nvar _has = require('has');\n\nvar _has2 = _interopRequireDefault(_has);\n\nvar _byConstructor = require('html-element-map/byConstructor');\n\nvar _byConstructor2 = _interopRequireDefault(_byConstructor);\n\nvar _RSTTraversal = require('./RSTTraversal');\n\nvar _Utils = require('./Utils');\n\nvar _getAdapter = require('./getAdapter');\n\nvar _getAdapter2 = _interopRequireDefault(_getAdapter);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    'default': obj\n  };\n}\n\nfunction _toConsumableArray(arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {\n      arr2[i] = arr[i];\n    }\n\n    return arr2;\n  } else {\n    return Array.from(arr);\n  }\n} // our CSS selector parser instance\n\n\nvar parser = (0, _rstSelectorParser.createParser)(); // Combinators that allow you to chance selectors\n\nvar CHILD = 'childCombinator';\nvar ADJACENT_SIBLING = 'adjacentSiblingCombinator';\nvar GENERAL_SIBLING = 'generalSiblingCombinator';\nvar DESCENDANT = 'descendantCombinator'; // Selectors for targeting elements\n\nvar SELECTOR = 'selector';\nvar TYPE_SELECTOR = 'typeSelector';\nvar CLASS_SELECTOR = 'classSelector';\nvar ID_SELECTOR = 'idSelector';\nvar UNIVERSAL_SELECTOR = 'universalSelector';\nvar ATTRIBUTE_PRESENCE = 'attributePresenceSelector';\nvar ATTRIBUTE_VALUE = 'attributeValueSelector'; // @TODO we dont support these, throw if they are used\n\nvar PSEUDO_CLASS = 'pseudoClassSelector';\nvar PSEUDO_ELEMENT = 'pseudoElementSelector';\nvar EXACT_ATTRIBUTE_OPERATOR = '=';\nvar WHITELIST_ATTRIBUTE_OPERATOR = '~=';\nvar HYPHENATED_ATTRIBUTE_OPERATOR = '|=';\nvar PREFIX_ATTRIBUTE_OPERATOR = '^=';\nvar SUFFIX_ATTRIBUTE_OPERATOR = '$=';\nvar SUBSTRING_ATTRIBUTE_OPERATOR = '*=';\n\nfunction unique(arr) {\n  return [].concat(_toConsumableArray(new Set(arr)));\n}\n/**\n * Calls reduce on a array of nodes with the passed\n * function, returning only unique results.\n * @param {Function} fn\n * @param {Array<Node>} nodes\n */\n\n\nfunction uniqueReduce(fn, nodes) {\n  return unique(nodes.reduce(fn, []));\n}\n/**\n * Takes a CSS selector and returns a set of tokens parsed\n * by scalpel.\n * @param {String} selector\n */\n\n\nfunction safelyGenerateTokens(selector) {\n  try {\n    return parser.parse(selector);\n  } catch (err) {\n    throw new Error('Failed to parse selector: ' + String(selector));\n  }\n}\n\nfunction matchAttributeSelector(node, token) {\n  var operator = token.operator,\n      value = token.value,\n      name = token.name;\n  var nodeProps = (0, _Utils.propsOfNode)(node);\n  var descriptor = Object.getOwnPropertyDescriptor(nodeProps, name);\n\n  if (descriptor && descriptor.get) {\n    return false;\n  }\n\n  var nodePropValue = nodeProps[name];\n\n  if (typeof nodePropValue === 'undefined') {\n    return false;\n  }\n\n  if (token.type === ATTRIBUTE_PRESENCE) {\n    return (0, _has2['default'])(nodeProps, token.name);\n  } // Only the exact value operator (\"=\") can match non-strings\n\n\n  if (typeof nodePropValue !== 'string' || typeof value !== 'string') {\n    if (operator !== EXACT_ATTRIBUTE_OPERATOR) {\n      return false;\n    }\n  }\n\n  switch (operator) {\n    /**\n     * Represents an element with the att attribute whose value is exactly \"val\".\n     * @example\n     * [attr=\"val\"] matches attr=\"val\"\n     */\n    case EXACT_ATTRIBUTE_OPERATOR:\n      return (0, _objectIs2['default'])(nodePropValue, value);\n\n    /**\n     * Represents an element with the att attribute whose value is a whitespace-separated\n     * list of words, one of which is exactly\n     * @example\n     *  [rel~=\"copyright\"] matches rel=\"copyright other\"\n     */\n\n    case WHITELIST_ATTRIBUTE_OPERATOR:\n      return nodePropValue.split(' ').indexOf(value) !== -1;\n\n    /**\n     * Represents an element with the att attribute, its value either being exactly the\n     * value or beginning with the value immediately followed by \"-\"\n     * @example\n     * [hreflang|=\"en\"] matches hreflang=\"en-US\"\n     */\n\n    case HYPHENATED_ATTRIBUTE_OPERATOR:\n      return nodePropValue === value || nodePropValue.startsWith(String(value) + '-');\n\n    /**\n     * Represents an element with the att attribute whose value begins with the prefix value.\n     * If the value is the empty string then the selector does not represent anything.\n     * @example\n     * [type^=\"image\"] matches type=\"imageobject\"\n     */\n\n    case PREFIX_ATTRIBUTE_OPERATOR:\n      return value === '' ? false : nodePropValue.slice(0, value.length) === value;\n\n    /**\n     * Represents an element with the att attribute whose value ends with the suffix value.\n     * If the value is the empty string then the selector does not represent anything.\n     * @example\n     * [type$=\"image\"] matches type=\"imageobject\"\n     */\n\n    case SUFFIX_ATTRIBUTE_OPERATOR:\n      return value === '' ? false : nodePropValue.slice(-value.length) === value;\n\n    /**\n     * Represents an element with the att attribute whose value contains at least one\n     * instance of the value. If value is the empty string then the\n     * selector does not represent anything.\n     * @example\n     * [title*=\"hello\"] matches title=\"well hello there\"\n     */\n\n    case SUBSTRING_ATTRIBUTE_OPERATOR:\n      return value === '' ? false : nodePropValue.indexOf(value) !== -1;\n\n    default:\n      throw new Error('Enzyme::Selector: Unknown attribute selector operator \"' + String(operator) + '\"');\n  }\n}\n\nfunction matchPseudoSelector(node, token, root) {\n  var name = token.name,\n      parameters = token.parameters;\n\n  if (name === 'not') {\n    // eslint-disable-next-line no-use-before-define\n    return parameters.every(function (selector) {\n      return reduceTreeBySelector(selector, node).length === 0;\n    });\n  }\n\n  if (name === 'empty') {\n    return (0, _RSTTraversal.treeFilter)(node, function (n) {\n      return n !== node;\n    }).length === 0;\n  }\n\n  if (name === 'first-child') {\n    var _findParentNode = (0, _RSTTraversal.findParentNode)(root, node),\n        rendered = _findParentNode.rendered;\n\n    var _rendered = _slicedToArray(rendered, 1),\n        firstChild = _rendered[0];\n\n    return firstChild === node;\n  }\n\n  if (name === 'last-child') {\n    var _findParentNode2 = (0, _RSTTraversal.findParentNode)(root, node),\n        _rendered2 = _findParentNode2.rendered;\n\n    return _rendered2[_rendered2.length - 1] === node;\n  }\n\n  if (name === 'focus') {\n    if (typeof document === 'undefined') {\n      throw new Error('Enzyme::Selector does not support the \":focus\" pseudo-element without a global `document`.');\n    }\n\n    var adapter = (0, _getAdapter2['default'])();\n    /* eslint-env browser */\n\n    return document.activeElement && adapter.nodeToHostNode(node) === document.activeElement;\n  }\n\n  throw new TypeError('Enzyme::Selector does not support the \"' + String(token.name) + '\" pseudo-element or pseudo-class selectors.');\n}\n/**\n * Takes a node and a token and determines if the node\n * matches the predicate defined by the token.\n * @param {Node} node\n * @param {Token} token\n */\n\n\nfunction nodeMatchesToken(node, token, root) {\n  if (node === null || typeof node === 'string') {\n    return false;\n  }\n\n  switch (token.type) {\n    /**\n     * Match every node\n     * @example '*' matches every node\n     */\n    case UNIVERSAL_SELECTOR:\n      return true;\n\n    /**\n     * Match against the className prop\n     * @example '.active' matches <div className='active' />\n     */\n\n    case CLASS_SELECTOR:\n      return (0, _RSTTraversal.hasClassName)(node, token.name);\n\n    /**\n     * Simple type matching\n     * @example 'div' matches <div />\n     */\n\n    case TYPE_SELECTOR:\n      return (0, _Utils.nodeHasType)(node, token.name);\n\n    /**\n     * Match against the `id` prop\n     * @example '#nav' matches <ul id=\"nav\" />\n     */\n\n    case ID_SELECTOR:\n      return (0, _RSTTraversal.nodeHasId)(node, token.name);\n\n    /**\n     * Matches if an attribute is present, regardless\n     * of its value\n     * @example '[disabled]' matches <a disabled />\n     */\n\n    case ATTRIBUTE_PRESENCE:\n      return matchAttributeSelector(node, token);\n\n    /**\n     * Matches if an attribute is present with the\n     * provided value\n     * @example '[data-foo=foo]' matches <div data-foo=\"foo\" />\n     */\n\n    case ATTRIBUTE_VALUE:\n      return matchAttributeSelector(node, token);\n\n    case PSEUDO_ELEMENT:\n    case PSEUDO_CLASS:\n      return matchPseudoSelector(node, token, root);\n\n    default:\n      throw new Error('Unknown token type: ' + String(token.type));\n  }\n}\n/**\n * Returns a predicate function that checks if a\n * node matches every token in the body of a selector\n * token.\n * @param {Token} token\n */\n\n\nfunction buildPredicateFromToken(token, root) {\n  return function (node) {\n    return token.body.every(function (bodyToken) {\n      return nodeMatchesToken(node, bodyToken, root);\n    });\n  };\n}\n/**\n * Returns whether a parsed selector is a complex selector, which\n * is defined as a selector that contains combinators.\n * @param {Array<Token>} tokens\n */\n\n\nfunction isComplexSelector(tokens) {\n  return tokens.some(function (token) {\n    return token.type !== SELECTOR;\n  });\n}\n/**\n * Takes a component constructor, object, or string representing\n * a simple selector and returns a predicate function that can\n * be applied to a single node.\n * @param {EnzymeSelector} selector\n */\n\n\nfunction buildPredicate(selector) {\n  // If the selector is a string, parse it as a simple CSS selector\n  if (typeof selector === 'string') {\n    var tokens = safelyGenerateTokens(selector);\n\n    if (isComplexSelector(tokens)) {\n      throw new TypeError('This method does not support complex CSS selectors');\n    } // Simple selectors only have a single selector token\n\n\n    return buildPredicateFromToken(tokens[0]);\n  } // If the selector is an element type, check if the node's type matches\n\n\n  var adapter = (0, _getAdapter2['default'])();\n  var isElementType = adapter.isValidElementType ? adapter.isValidElementType(selector) : typeof selector === 'function';\n\n  if (isElementType) {\n    return function (node) {\n      return adapter.matchesElementType(node, selector);\n    };\n  } // If the selector is an non-empty object, treat the keys/values as props\n\n\n  if ((typeof selector === 'undefined' ? 'undefined' : _typeof(selector)) === 'object') {\n    if (!Array.isArray(selector) && selector !== null && Object.keys(selector).length > 0) {\n      var hasUndefinedValues = (0, _object2['default'])(selector).some(function (value) {\n        return typeof value === 'undefined';\n      });\n\n      if (hasUndefinedValues) {\n        throw new TypeError('Enzyme::Props can’t have `undefined` values. Try using ‘findWhere()’ instead.');\n      }\n\n      return function (node) {\n        return (0, _RSTTraversal.nodeMatchesObjectProps)(node, selector);\n      };\n    }\n\n    throw new TypeError('Enzyme::Selector does not support an array, null, or empty object as a selector');\n  }\n\n  throw new TypeError('Enzyme::Selector expects a string, object, or valid element type (Component Constructor)');\n}\n/**\n * Matches only nodes which are adjacent siblings (direct next sibling)\n * against a predicate, returning those that match.\n * @param {Array<Node>} nodes\n * @param {Function} predicate\n * @param {Node} root\n */\n\n\nfunction matchAdjacentSiblings(nodes, predicate, root) {\n  return nodes.reduce(function (matches, node) {\n    var parent = (0, _RSTTraversal.findParentNode)(root, node); // If there's no parent, there's no siblings\n\n    if (!parent) {\n      return matches;\n    }\n\n    var parentChildren = (0, _RSTTraversal.childrenOfNode)(parent);\n    var nodeIndex = parentChildren.indexOf(node);\n    var adjacentSibling = parentChildren[nodeIndex + 1]; // No sibling\n\n    if (!adjacentSibling) {\n      return matches;\n    }\n\n    if (predicate(adjacentSibling)) {\n      matches.push(adjacentSibling);\n    }\n\n    return matches;\n  }, []);\n}\n/**\n * Matches only nodes which are general siblings (any sibling *after*)\n * against a predicate, returning those that match.\n * @param {Array<Node>} nodes\n * @param {Function} predicate\n * @param {Node} root\n */\n\n\nfunction matchGeneralSibling(nodes, predicate, root) {\n  return uniqueReduce(function (matches, node) {\n    var parent = (0, _RSTTraversal.findParentNode)(root, node);\n\n    if (!parent) {\n      return matches;\n    }\n\n    var parentChildren = (0, _RSTTraversal.childrenOfNode)(parent);\n    var nodeIndex = parentChildren.indexOf(node);\n    var youngerSiblings = parentChildren.slice(nodeIndex + 1);\n    return matches.concat(youngerSiblings.filter(predicate));\n  }, nodes);\n}\n/**\n * Matches only nodes which are direct children (not grandchildren, etc.)\n * against a predicate, returning those that match.\n * @param {Array<Node>} nodes\n * @param {Function} predicate\n */\n\n\nfunction matchDirectChild(nodes, predicate) {\n  return uniqueReduce(function (matches, node) {\n    return matches.concat((0, _RSTTraversal.childrenOfNode)(node).filter(predicate));\n  }, nodes);\n}\n/**\n * Matches all descendant nodes against a predicate,\n * returning those that match.\n * @param {Array<Node>} nodes\n * @param {Function} predicate\n */\n\n\nfunction matchDescendant(nodes, predicate) {\n  return uniqueReduce(function (matches, node) {\n    return matches.concat((0, _RSTTraversal.treeFilter)(node, predicate));\n  }, (0, _arrayPrototype2['default'])(nodes.map(_RSTTraversal.childrenOfNode)));\n}\n/**\n * Takes an RST and reduces it to a set of nodes matching\n * the selector. The selector can be a simple selector, which\n * is handled by `buildPredicate`, or a complex CSS selector which\n * reduceTreeBySelector parses and reduces the tree based on the combinators.\n *\n * @param {EnzymeSelector} selector\n * @param {RSTNode} root\n */\n\n\nfunction reduceTreeBySelector(selector, root) {\n  if (typeof selector !== 'string') {\n    var elements = (0, _byConstructor2['default'])(selector);\n\n    if (elements.length > 0) {\n      return (0, _arrayPrototype2['default'])(elements.map(function (x) {\n        return reduceTreeBySelector(x.tag, root);\n      })); // when https://github.com/aweary/rst-selector-parser/issues/15 is resolved\n      // const htmlTagNames = elements.map(x => x.tag).join(', ');\n      // return reduceTreeBySelector(htmlTagNames, root);\n    }\n  }\n\n  if (typeof selector === 'function' || (typeof selector === 'undefined' ? 'undefined' : _typeof(selector)) === 'object') {\n    return (0, _RSTTraversal.treeFilter)(root, buildPredicate(selector));\n  }\n\n  var results = [];\n\n  if (typeof selector === 'string') {\n    var tokens = safelyGenerateTokens(selector);\n    var index = 0;\n\n    while (index < tokens.length) {\n      var token = tokens[index];\n      /**\n       * There are two types of tokens in a CSS selector:\n       *\n       * 1. Selector tokens. These target nodes directly, like\n       *    type or attribute selectors. These are easy to apply\n       *    because we can traverse the tree and return only\n       *    the nodes that match the predicate.\n       *\n       * 2. Combinator tokens. These tokens chain together\n       *    selector nodes. For example > for children, or +\n       *    for adjacent siblings. These are harder to match\n       *    as we have to track where in the tree we are\n       *    to determine if a selector node applies or not.\n       */\n\n      if (token.type === SELECTOR) {\n        var predicate = buildPredicateFromToken(token, root);\n        results = results.concat((0, _RSTTraversal.treeFilter)(root, predicate));\n      } else {\n        // We can assume there always all previously matched tokens since selectors\n        // cannot start with combinators.\n        var type = token.type; // We assume the next token is a selector, so move the index\n        // forward and build the predicate.\n\n        index += 1;\n\n        var _predicate = buildPredicateFromToken(tokens[index], root); // We match against only the nodes which have already been matched,\n        // since a combinator is meant to refine a previous selector.\n\n\n        switch (type) {\n          // The + combinator\n          case ADJACENT_SIBLING:\n            results = matchAdjacentSiblings(results, _predicate, root);\n            break;\n          // The ~ combinator\n\n          case GENERAL_SIBLING:\n            results = matchGeneralSibling(results, _predicate, root);\n            break;\n          // The > combinator\n\n          case CHILD:\n            results = matchDirectChild(results, _predicate);\n            break;\n          // The ' ' (whitespace) combinator\n\n          case DESCENDANT:\n            {\n              results = matchDescendant(results, _predicate);\n              break;\n            }\n\n          default:\n            throw new Error('Unknown combinator selector: ' + String(type));\n        }\n      }\n\n      index += 1;\n    }\n  } else {\n    throw new TypeError('Enzyme::Selector expects a string, object, or Component Constructor');\n  }\n\n  return results;\n}\n\nfunction reduceTreesBySelector(selector, roots) {\n  var results = roots.map(function (n) {\n    return reduceTreeBySelector(selector, n);\n  });\n  return unique((0, _arrayPrototype2['default'])(results, 1));\n} //# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9zZWxlY3RvcnMuanMiXSwibmFtZXMiOlsiYnVpbGRQcmVkaWNhdGUiLCJyZWR1Y2VUcmVlQnlTZWxlY3RvciIsInJlZHVjZVRyZWVzQnlTZWxlY3RvciIsInBhcnNlciIsIkNISUxEIiwiQURKQUNFTlRfU0lCTElORyIsIkdFTkVSQUxfU0lCTElORyIsIkRFU0NFTkRBTlQiLCJTRUxFQ1RPUiIsIlRZUEVfU0VMRUNUT1IiLCJDTEFTU19TRUxFQ1RPUiIsIklEX1NFTEVDVE9SIiwiVU5JVkVSU0FMX1NFTEVDVE9SIiwiQVRUUklCVVRFX1BSRVNFTkNFIiwiQVRUUklCVVRFX1ZBTFVFIiwiUFNFVURPX0NMQVNTIiwiUFNFVURPX0VMRU1FTlQiLCJFWEFDVF9BVFRSSUJVVEVfT1BFUkFUT1IiLCJXSElURUxJU1RfQVRUUklCVVRFX09QRVJBVE9SIiwiSFlQSEVOQVRFRF9BVFRSSUJVVEVfT1BFUkFUT1IiLCJQUkVGSVhfQVRUUklCVVRFX09QRVJBVE9SIiwiU1VGRklYX0FUVFJJQlVURV9PUEVSQVRPUiIsIlNVQlNUUklOR19BVFRSSUJVVEVfT1BFUkFUT1IiLCJ1bmlxdWUiLCJhcnIiLCJTZXQiLCJ1bmlxdWVSZWR1Y2UiLCJmbiIsIm5vZGVzIiwicmVkdWNlIiwic2FmZWx5R2VuZXJhdGVUb2tlbnMiLCJzZWxlY3RvciIsInBhcnNlIiwiZXJyIiwiRXJyb3IiLCJtYXRjaEF0dHJpYnV0ZVNlbGVjdG9yIiwibm9kZSIsInRva2VuIiwib3BlcmF0b3IiLCJ2YWx1ZSIsIm5hbWUiLCJub2RlUHJvcHMiLCJkZXNjcmlwdG9yIiwiT2JqZWN0IiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIiwiZ2V0Iiwibm9kZVByb3BWYWx1ZSIsInR5cGUiLCJzcGxpdCIsImluZGV4T2YiLCJzdGFydHNXaXRoIiwic2xpY2UiLCJsZW5ndGgiLCJtYXRjaFBzZXVkb1NlbGVjdG9yIiwicm9vdCIsInBhcmFtZXRlcnMiLCJldmVyeSIsIm4iLCJyZW5kZXJlZCIsImZpcnN0Q2hpbGQiLCJkb2N1bWVudCIsImFkYXB0ZXIiLCJhY3RpdmVFbGVtZW50Iiwibm9kZVRvSG9zdE5vZGUiLCJUeXBlRXJyb3IiLCJub2RlTWF0Y2hlc1Rva2VuIiwiYnVpbGRQcmVkaWNhdGVGcm9tVG9rZW4iLCJib2R5IiwiYm9keVRva2VuIiwiaXNDb21wbGV4U2VsZWN0b3IiLCJ0b2tlbnMiLCJzb21lIiwiaXNFbGVtZW50VHlwZSIsImlzVmFsaWRFbGVtZW50VHlwZSIsIm1hdGNoZXNFbGVtZW50VHlwZSIsIkFycmF5IiwiaXNBcnJheSIsImtleXMiLCJoYXNVbmRlZmluZWRWYWx1ZXMiLCJtYXRjaEFkamFjZW50U2libGluZ3MiLCJwcmVkaWNhdGUiLCJtYXRjaGVzIiwicGFyZW50IiwicGFyZW50Q2hpbGRyZW4iLCJub2RlSW5kZXgiLCJhZGphY2VudFNpYmxpbmciLCJwdXNoIiwibWF0Y2hHZW5lcmFsU2libGluZyIsInlvdW5nZXJTaWJsaW5ncyIsImNvbmNhdCIsImZpbHRlciIsIm1hdGNoRGlyZWN0Q2hpbGQiLCJtYXRjaERlc2NlbmRhbnQiLCJtYXAiLCJjaGlsZHJlbk9mTm9kZSIsImVsZW1lbnRzIiwieCIsInRhZyIsInJlc3VsdHMiLCJpbmRleCIsInJvb3RzIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O1FBbVFnQkEsYyxHQUFBQSxjO1FBcUhBQyxvQixHQUFBQSxvQjtRQStFQUMscUIsR0FBQUEscUI7O0FBdmNoQjs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7O0FBUUE7O0FBQ0E7Ozs7Ozs7O0FBQ0E7QUFDQSxJQUFNQyxTQUFTLHNDQUFmOztBQUVBO0FBQ0EsSUFBTUMsUUFBUSxpQkFBZDtBQUNBLElBQU1DLG1CQUFtQiwyQkFBekI7QUFDQSxJQUFNQyxrQkFBa0IsMEJBQXhCO0FBQ0EsSUFBTUMsYUFBYSxzQkFBbkI7O0FBRUE7QUFDQSxJQUFNQyxXQUFXLFVBQWpCO0FBQ0EsSUFBTUMsZ0JBQWdCLGNBQXRCO0FBQ0EsSUFBTUMsaUJB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QUNEb0QsZUFBUyxDQUFUO0FBQ0Q7QUFDRixHQXhERCxNQXdETztBQUNMLFVBQU0sSUFBSW5DLFNBQUosQ0FBYyxxRUFBZCxDQUFOO0FBQ0Q7QUFDRCxTQUFPa0MsT0FBUDtBQUNEOztBQUVNLFNBQVNoRyxxQkFBVCxDQUErQjZCLFFBQS9CLEVBQXlDcUUsS0FBekMsRUFBZ0Q7QUFDckQsTUFBTUYsVUFBVUUsTUFBTVAsR0FBTixDQUFVLFVBQUNwQyxDQUFEO0FBQUEsV0FBT3hELHFCQUFxQjhCLFFBQXJCLEVBQStCMEIsQ0FBL0IsQ0FBUDtBQUFBLEdBQVYsQ0FBaEI7QUFDQSxTQUFPbEMsT0FBTyxpQ0FBSzJFLE9BQUwsRUFBYyxDQUFkLENBQVAsQ0FBUDtBQUNEIiwiZmlsZSI6InNlbGVjdG9ycy5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGNyZWF0ZVBhcnNlciB9IGZyb20gJ3JzdC1zZWxlY3Rvci1wYXJzZXInO1xuaW1wb3J0IHZhbHVlcyBmcm9tICdvYmplY3QudmFsdWVzJztcbmltcG9ydCBmbGF0IGZyb20gJ2FycmF5LnByb3RvdHlwZS5mbGF0JztcbmltcG9ydCBpcyBmcm9tICdvYmplY3QtaXMnO1xuaW1wb3J0IGhhcyBmcm9tICdoYXMnO1xuaW1wb3J0IGVsZW1lbnRzQnlDb25zdHJ1Y3RvciBmcm9tICdodG1sLWVsZW1lbnQtbWFwL2J5Q29uc3RydWN0b3InO1xuaW1wb3J0IHtcbiAgdHJlZUZpbHRlcixcbiAgbm9kZUhhc0lkLFxuICBmaW5kUGFyZW50Tm9kZSxcbiAgbm9kZU1hdGNoZXNPYmplY3RQcm9wcyxcbiAgY2hpbGRyZW5PZk5vZGUsXG4gIGhhc0NsYXNzTmFtZSxcbn0gZnJvbSAnLi9SU1RUcmF2ZXJzYWwnO1xuaW1wb3J0IHsgbm9kZUhhc1R5cGUsIHByb3BzT2ZOb2RlIH0gZnJvbSAnLi9VdGlscyc7XG5pbXBvcnQgZ2V0QWRhcHRlciBmcm9tICcuL2dldEFkYXB0ZXInO1xuLy8gb3VyIENTUyBzZWxlY3RvciBwYXJzZXIgaW5zdGFuY2VcbmNvbnN0IHBhcnNlciA9IGNyZWF0ZVBhcnNlcigpO1xuXG4vLyBDb21iaW5hdG9ycyB0aGF0IGFsbG93IHlvdSB0byBjaGFuY2Ugc2VsZWN0b3JzXG5jb25zdCBDSElMRCA9ICdjaGlsZENvbWJpbmF0b3InO1xuY29uc3QgQURKQUNFTlRfU0lCTElORyA9ICdhZGphY2VudFNpYmxpbmdDb21iaW5hdG9yJztcbmNvbnN0IEdFTkVSQUxfU0lCTElORyA9ICdnZW5lcmFsU2libGluZ0NvbWJpbmF0b3InO1xuY29uc3QgREVTQ0VOREFOVCA9ICdkZXNjZW5kYW50Q29tYmluYXRvcic7XG5cbi8vIFNlbGVjdG9ycyBmb3IgdGFyZ2V0aW5nIGVsZW1lbnRzXG5jb25zdCBTRUxFQ1RPUiA9ICdzZWxlY3Rvcic7XG5jb25zdCBUWVBFX1NFTEVDVE9SID0gJ3R5cGVTZWxlY3Rvcic7XG5jb25zdCBDTEFTU19TRUxFQ1RPUiA9ICdjbGFzc1NlbGVjdG9yJztcbmNvbnN0IElEX1NFTEVDVE9SID0gJ2lkU2VsZWN0b3InO1xuY29uc3QgVU5JVkVSU0FMX1NFTEVDVE9SID0gJ3VuaXZlcnNhbFNlbGVjdG9yJztcbmNvbnN0IEFUVFJJQlVURV9QUkVTRU5DRSA9ICdhdHRyaWJ1dGVQcmVzZW5jZVNlbGVjdG9yJztcbmNvbnN0IEFUVFJJQlVURV9WQUxVRSA9ICdhdHRyaWJ1dGVWYWx1ZVNlbGVjdG9yJztcbi8vIEBUT0RPIHdlIGRvbnQgc3VwcG9ydCB0aGVzZSwgdGhyb3cgaWYgdGhleSBhcmUgdXNlZFxuY29uc3QgUFNFVURPX0NMQVNTID0gJ3BzZXVkb0NsYXNzU2VsZWN0b3InO1xuY29uc3QgUFNFVURPX0VMRU1FTlQgPSAncHNldWRvRWxlbWVudFNlbGVjdG9yJztcblxuY29uc3QgRVhBQ1RfQVRUUklCVVRFX09QRVJBVE9SID0gJz0nO1xuY29uc3QgV0hJVEVMSVNUX0FUVFJJQlVURV9PUEVSQVRPUiA9ICd+PSc7XG5jb25zdCBIWVBIRU5BVEVEX0FUVFJJQlVURV9PUEVSQVRPUiA9ICd8PSc7XG5jb25zdCBQUkVGSVhfQVRUUklCVVRFX09QRVJBVE9SID0gJ149JztcbmNvbnN0IFNVRkZJWF9BVFRSSUJVVEVfT1BFUkFUT1IgPSAnJD0nO1xuY29uc3QgU1VCU1RSSU5HX0FUVFJJQlVURV9PUEVSQVRPUiA9ICcqPSc7XG5cbmZ1bmN0aW9uIHVuaXF1ZShhcnIpIHtcbiAgcmV0dXJuIFsuLi5uZXcgU2V0KGFycildO1xufVxuXG4vKipcbiAqIENhbGxzIHJlZHVjZSBvbiBhIGFycmF5IG9mIG5vZGVzIHdpdGggdGhlIHBhc3NlZFxuICogZnVuY3Rpb24sIHJldHVybmluZyBvbmx5IHVuaXF1ZSByZXN1bHRzLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cbiAqIEBwYXJhbSB7QXJyYXk8Tm9kZT59IG5vZGVzXG4gKi9cbmZ1bmN0aW9uIHVuaXF1ZVJlZHVjZShmbiwgbm9kZXMpIHtcbiAgcmV0dXJuIHVuaXF1ZShub2Rlcy5yZWR1Y2UoZm4sIFtdKSk7XG59XG5cbi8qKlxuICogVGFrZXMgYSBDU1Mgc2VsZWN0b3IgYW5kIHJldHVybnMgYSBzZXQgb2YgdG9rZW5zIHBhcnNlZFxuICogYnkgc2NhbHBlbC5cbiAqIEBwYXJhbSB7U3RyaW5nfSBzZWxlY3RvclxuICovXG5mdW5jdGlvbiBzYWZlbHlHZW5lcmF0ZVRva2VucyhzZWxlY3Rvcikge1xuICB0cnkge1xuICAgIHJldHVybiBwYXJzZXIucGFyc2Uoc2VsZWN0b3IpO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBwYXJzZSBzZWxlY3RvcjogJHtzZWxlY3Rvcn1gKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBtYXRjaEF0dHJpYnV0ZVNlbGVjdG9yKG5vZGUsIHRva2VuKSB7XG4gIGNvbnN0IHsgb3BlcmF0b3IsIHZhbHVlLCBuYW1lIH0gPSB0b2tlbjtcbiAgY29uc3Qgbm9kZVByb3BzID0gcHJvcHNPZk5vZGUobm9kZSk7XG4gIGNvbnN0IGRlc2NyaXB0b3IgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG5vZGVQcm9wcywgbmFtZSk7XG4gIGlmIChkZXNjcmlwdG9yICYmIGRlc2NyaXB0b3IuZ2V0KSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGNvbnN0IG5vZGVQcm9wVmFsdWUgPSBub2RlUHJvcHNbbmFtZV07XG4gIGlmICh0eXBlb2Ygbm9kZVByb3BWYWx1ZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKHRva2VuLnR5cGUgPT09IEFUVFJJQlVURV9QUkVTRU5DRSkge1xuICAgIHJldHVybiBoYXMobm9kZVByb3BzLCB0b2tlbi5uYW1lKTtcbiAgfVxuICAvLyBPbmx5IHRoZSBleGFjdCB2YWx1ZSBvcGVyYXRvciAoXCI9XCIpIGNhbiBtYXRjaCBub24tc3RyaW5nc1xuICBpZiAodHlwZW9mIG5vZGVQcm9wVmFsdWUgIT09ICdzdHJpbmcnIHx8IHR5cGVvZiB2YWx1ZSAhPT0gJ3N0cmluZycpIHtcbiAgICBpZiAob3BlcmF0b3IgIT09IEVYQUNUX0FUVFJJQlVURV9PUEVSQVRPUikge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICBzd2l0Y2ggKG9wZXJhdG9yKSB7XG4gICAgLyoqXG4gICAgICogUmVwcmVzZW50cyBhbiBlbGVtZW50IHdpdGggdGhlIGF0dCBhdHRyaWJ1dGUgd2hvc2UgdmFsdWUgaXMgZXhhY3RseSBcInZhbFwiLlxuICAgICAqIEBleGFtcGxlXG4gICAgICogW2F0dHI9XCJ2YWxcIl0gbWF0Y2hlcyBhdHRyPVwidmFsXCJcbiAgICAgKi9cbiAgICBjYXNlIEVYQUNUX0FUVFJJQlVURV9PUEVSQVRPUjpcbiAgICAgIHJldHVybiBpcyhub2RlUHJvcFZhbHVlLCB2YWx1ZSk7XG4gICAgLyoqXG4gICAgICogUmVwcmVzZW50cyBhbiBlbGVtZW50IHdpdGggdGhlIGF0dCBhdHRyaWJ1dGUgd2hvc2UgdmFsdWUgaXMgYSB3aGl0ZXNwYWNlLXNlcGFyYXRlZFxuICAgICAqIGxpc3Qgb2Ygd29yZHMsIG9uZSBvZiB3aGljaCBpcyBleGFjdGx5XG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAgW3JlbH49XCJjb3B5cmlnaHRcIl0gbWF0Y2hlcyByZWw9XCJjb3B5cmlnaHQgb3RoZXJcIlxuICAgICAqL1xuICAgIGNhc2UgV0hJVEVMSVNUX0FUVFJJQlVURV9PUEVSQVRPUjpcbiAgICAgIHJldHVybiBub2RlUHJvcFZhbHVlLnNwbGl0KCcgJykuaW5kZXhPZih2YWx1ZSkgIT09IC0xO1xuICAgIC8qKlxuICAgICAqIFJlcHJlc2VudHMgYW4gZWxlbWVudCB3aXRoIHRoZSBhdHQgYXR0cmlidXRlLCBpdHMgdmFsdWUgZWl0aGVyIGJlaW5nIGV4YWN0bHkgdGhlXG4gICAgICogdmFsdWUgb3IgYmVnaW5uaW5nIHdpdGggdGhlIHZhbHVlIGltbWVkaWF0ZWx5IGZvbGxvd2VkIGJ5IFwiLVwiXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBbaHJlZmxhbmd8PVwiZW5cIl0gbWF0Y2hlcyBocmVmbGFuZz1cImVuLVVTXCJcbiAgICAgKi9cbiAgICBjYXNlIEhZUEhFTkFURURfQVRUUklCVVRFX09QRVJBVE9SOlxuICAgICAgcmV0dXJuIG5vZGVQcm9wVmFsdWUgPT09IHZhbHVlIHx8IG5vZGVQcm9wVmFsdWUuc3RhcnRzV2l0aChgJHt2YWx1ZX0tYCk7XG4gICAgLyoqXG4gICAgICogUmVwcmVzZW50cyBhbiBlbGVtZW50IHdpdGggdGhlIGF0dCBhdHRyaWJ1dGUgd2hvc2UgdmFsdWUgYmVnaW5zIHdpdGggdGhlIHByZWZpeCB2YWx1ZS5cbiAgICAgKiBJZiB0aGUgdmFsdWUgaXMgdGhlIGVtcHR5IHN0cmluZyB0aGVuIHRoZSBzZWxlY3RvciBkb2VzIG5vdCByZXByZXNlbnQgYW55dGhpbmcuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBbdHlwZV49XCJpbWFnZVwiXSBtYXRjaGVzIHR5cGU9XCJpbWFnZW9iamVjdFwiXG4gICAgICovXG4gICAgY2FzZSBQUkVGSVhfQVRUUklCVVRFX09QRVJBVE9SOlxuICAgICAgcmV0dXJuIHZhbHVlID09PSAnJyA/IGZhbHNlIDogbm9kZVByb3BWYWx1ZS5zbGljZSgwLCB2YWx1ZS5sZW5ndGgpID09PSB2YWx1ZTtcbiAgICAvKipcbiAgICAgKiBSZXByZXNlbnRzIGFuIGVsZW1lbnQgd2l0aCB0aGUgYXR0IGF0dHJpYnV0ZSB3aG9zZSB2YWx1ZSBlbmRzIHdpdGggdGhlIHN1ZmZpeCB2YWx1ZS5cbiAgICAgKiBJZiB0aGUgdmFsdWUgaXMgdGhlIGVtcHR5IHN0cmluZyB0aGVuIHRoZSBzZWxlY3RvciBkb2VzIG5vdCByZXByZXNlbnQgYW55dGhpbmcuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBbdHlwZSQ9XCJpbWFnZVwiXSBtYXRjaGVzIHR5cGU9XCJpbWFnZW9iamVjdFwiXG4gICAgICovXG4gICAgY2FzZSBTVUZGSVhfQVRUUklCVVRFX09QRVJBVE9SOlxuICAgICAgcmV0dXJuIHZhbHVlID09PSAnJyA/IGZhbHNlIDogbm9kZVByb3BWYWx1ZS5zbGljZSgtdmFsdWUubGVuZ3RoKSA9PT0gdmFsdWU7XG4gICAgLyoqXG4gICAgICogUmVwcmVzZW50cyBhbiBlbGVtZW50IHdpdGggdGhlIGF0dCBhdHRyaWJ1dGUgd2hvc2UgdmFsdWUgY29udGFpbnMgYXQgbGVhc3Qgb25lXG4gICAgICogaW5zdGFuY2Ugb2YgdGhlIHZhbHVlLiBJZiB2YWx1ZSBpcyB0aGUgZW1wdHkgc3RyaW5nIHRoZW4gdGhlXG4gICAgICogc2VsZWN0b3IgZG9lcyBub3QgcmVwcmVzZW50IGFueXRoaW5nLlxuICAgICAqIEBleGFtcGxlXG4gICAgICogW3RpdGxlKj1cImhlbGxvXCJdIG1hdGNoZXMgdGl0bGU9XCJ3ZWxsIGhlbGxvIHRoZXJlXCJcbiAgICAgKi9cbiAgICBjYXNlIFNVQlNUUklOR19BVFRSSUJVVEVfT1BFUkFUT1I6XG4gICAgICByZXR1cm4gdmFsdWUgPT09ICcnID8gZmFsc2UgOiBub2RlUHJvcFZhbHVlLmluZGV4T2YodmFsdWUpICE9PSAtMTtcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBFbnp5bWU6OlNlbGVjdG9yOiBVbmtub3duIGF0dHJpYnV0ZSBzZWxlY3RvciBvcGVyYXRvciBcIiR7b3BlcmF0b3J9XCJgKTtcbiAgfVxufVxuXG5cbmZ1bmN0aW9uIG1hdGNoUHNldWRvU2VsZWN0b3Iobm9kZSwgdG9rZW4sIHJvb3QpIHtcbiAgY29uc3QgeyBuYW1lLCBwYXJhbWV0ZXJzIH0gPSB0b2tlbjtcbiAgaWYgKG5hbWUgPT09ICdub3QnKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVzZS1iZWZvcmUtZGVmaW5lXG4gICAgcmV0dXJuIHBhcmFtZXRlcnMuZXZlcnkoKHNlbGVjdG9yKSA9PiByZWR1Y2VUcmVlQnlTZWxlY3RvcihzZWxlY3Rvciwgbm9kZSkubGVuZ3RoID09PSAwKTtcbiAgfVxuICBpZiAobmFtZSA9PT0gJ2VtcHR5Jykge1xuICAgIHJldHVybiB0cmVlRmlsdGVyKG5vZGUsIChuKSA9PiBuICE9PSBub2RlKS5sZW5ndGggPT09IDA7XG4gIH1cbiAgaWYgKG5hbWUgPT09ICdmaXJzdC1jaGlsZCcpIHtcbiAgICBjb25zdCB7IHJlbmRlcmVkIH0gPSBmaW5kUGFyZW50Tm9kZShyb290LCBub2RlKTtcbiAgICBjb25zdCBbZmlyc3RDaGlsZF0gPSByZW5kZXJlZDtcbiAgICByZXR1cm4gZmlyc3RDaGlsZCA9PT0gbm9kZTtcbiAgfVxuICBpZiAobmFtZSA9PT0gJ2xhc3QtY2hpbGQnKSB7XG4gICAgY29uc3QgeyByZW5kZXJlZCB9ID0gZmluZFBhcmVudE5vZGUocm9vdCwgbm9kZSk7XG4gICAgcmV0dXJuIHJlbmRlcmVkW3JlbmRlcmVkLmxlbmd0aCAtIDFdID09PSBub2RlO1xuICB9XG4gIGlmIChuYW1lID09PSAnZm9jdXMnKSB7XG4gICAgaWYgKHR5cGVvZiBkb2N1bWVudCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignRW56eW1lOjpTZWxlY3RvciBkb2VzIG5vdCBzdXBwb3J0IHRoZSBcIjpmb2N1c1wiIHBzZXVkby1lbGVtZW50IHdpdGhvdXQgYSBnbG9iYWwgYGRvY3VtZW50YC4nKTtcbiAgICB9XG4gICAgY29uc3QgYWRhcHRlciA9IGdldEFkYXB0ZXIoKTtcbiAgICAvKiBlc2xpbnQtZW52IGJyb3dzZXIgKi9cbiAgICByZXR1cm4gZG9jdW1lbnQuYWN0aXZlRWxlbWVudCAmJiBhZGFwdGVyLm5vZGVUb0hvc3ROb2RlKG5vZGUpID09PSBkb2N1bWVudC5hY3RpdmVFbGVtZW50O1xuICB9XG5cbiAgdGhyb3cgbmV3IFR5cGVFcnJvcihgRW56eW1lOjpTZWxlY3RvciBkb2VzIG5vdCBzdXBwb3J0IHRoZSBcIiR7dG9rZW4ubmFtZX1cIiBwc2V1ZG8tZWxlbWVudCBvciBwc2V1ZG8tY2xhc3Mgc2VsZWN0b3JzLmApO1xufVxuXG4vKipcbiAqIFRha2VzIGEgbm9kZSBhbmQgYSB0b2tlbiBhbmQgZGV0ZXJtaW5lcyBpZiB0aGUgbm9kZVxuICogbWF0Y2hlcyB0aGUgcHJlZGljYXRlIGRlZmluZWQgYnkgdGhlIHRva2VuLlxuICogQHBhcmFtIHtOb2RlfSBub2RlXG4gKiBAcGFyYW0ge1Rva2VufSB0b2tlblxuICovXG5mdW5jdGlvbiBub2RlTWF0Y2hlc1Rva2VuKG5vZGUsIHRva2VuLCByb290KSB7XG4gIGlmIChub2RlID09PSBudWxsIHx8IHR5cGVvZiBub2RlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBzd2l0Y2ggKHRva2VuLnR5cGUpIHtcbiAgICAvKipcbiAgICAgKiBNYXRjaCBldmVyeSBub2RlXG4gICAgICogQGV4YW1wbGUgJyonIG1hdGNoZXMgZXZlcnkgbm9kZVxuICAgICAqL1xuICAgIGNhc2UgVU5JVkVSU0FMX1NFTEVDVE9SOlxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgLyoqXG4gICAgICogTWF0Y2ggYWdhaW5zdCB0aGUgY2xhc3NOYW1lIHByb3BcbiAgICAgKiBAZXhhbXBsZSAnLmFjdGl2ZScgbWF0Y2hlcyA8ZGl2IGNsYXNzTmFtZT0nYWN0aXZlJyAvPlxuICAgICAqL1xuICAgIGNhc2UgQ0xBU1NfU0VMRUNUT1I6XG4gICAgICByZXR1cm4gaGFzQ2xhc3NOYW1lKG5vZGUsIHRva2VuLm5hbWUpO1xuICAgIC8qKlxuICAgICAqIFNpbXBsZSB0eXBlIG1hdGNoaW5nXG4gICAgICogQGV4YW1wbGUgJ2RpdicgbWF0Y2hlcyA8ZGl2IC8+XG4gICAgICovXG4gICAgY2FzZSBUWVBFX1NFTEVDVE9SOlxuICAgICAgcmV0dXJuIG5vZGVIYXNUeXBlKG5vZGUsIHRva2VuLm5hbWUpO1xuICAgIC8qKlxuICAgICAqIE1hdGNoIGFnYWluc3QgdGhlIGBpZGAgcHJvcFxuICAgICAqIEBleGFtcGxlICcjbmF2JyBtYXRjaGVzIDx1bCBpZD1cIm5hdlwiIC8+XG4gICAgICovXG4gICAgY2FzZSBJRF9TRUxFQ1RPUjpcbiAgICAgIHJldHVybiBub2RlSGFzSWQobm9kZSwgdG9rZW4ubmFtZSk7XG4gICAgLyoqXG4gICAgICogTWF0Y2hlcyBpZiBhbiBhdHRyaWJ1dGUgaXMgcHJlc2VudCwgcmVnYXJkbGVzc1xuICAgICAqIG9mIGl0cyB2YWx1ZVxuICAgICAqIEBleGFtcGxlICdbZGlzYWJsZWRdJyBtYXRjaGVzIDxhIGRpc2FibGVkIC8+XG4gICAgICovXG4gICAgY2FzZSBBVFRSSUJVVEVfUFJFU0VOQ0U6XG4gICAgICByZXR1cm4gbWF0Y2hBdHRyaWJ1dGVTZWxlY3Rvcihub2RlLCB0b2tlbik7XG4gICAgLyoqXG4gICAgICogTWF0Y2hlcyBpZiBhbiBhdHRyaWJ1dGUgaXMgcHJlc2VudCB3aXRoIHRoZVxuICAgICAqIHByb3ZpZGVkIHZhbHVlXG4gICAgICogQGV4YW1wbGUgJ1tkYXRhLWZvbz1mb29dJyBtYXRjaGVzIDxkaXYgZGF0YS1mb289XCJmb29cIiAvPlxuICAgICAqL1xuICAgIGNhc2UgQVRUUklCVVRFX1ZBTFVFOlxuICAgICAgcmV0dXJuIG1hdGNoQXR0cmlidXRlU2VsZWN0b3Iobm9kZSwgdG9rZW4pO1xuICAgIGNhc2UgUFNFVURPX0VMRU1FTlQ6XG4gICAgY2FzZSBQU0VVRE9fQ0xBU1M6XG4gICAgICByZXR1cm4gbWF0Y2hQc2V1ZG9TZWxlY3Rvcihub2RlLCB0b2tlbiwgcm9vdCk7XG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVW5rbm93biB0b2tlbiB0eXBlOiAke3Rva2VuLnR5cGV9YCk7XG4gIH1cbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgcHJlZGljYXRlIGZ1bmN0aW9uIHRoYXQgY2hlY2tzIGlmIGFcbiAqIG5vZGUgbWF0Y2hlcyBldmVyeSB0b2tlbiBpbiB0aGUgYm9keSBvZiBhIHNlbGVjdG9yXG4gKiB0b2tlbi5cbiAqIEBwYXJhbSB7VG9rZW59IHRva2VuXG4gKi9cbmZ1bmN0aW9uIGJ1aWxkUHJlZGljYXRlRnJvbVRva2VuKHRva2VuLCByb290KSB7XG4gIHJldHVybiAobm9kZSkgPT4gdG9rZW4uYm9keS5ldmVyeSgoYm9keVRva2VuKSA9PiBub2RlTWF0Y2hlc1Rva2VuKG5vZGUsIGJvZHlUb2tlbiwgcm9vdCkpO1xufVxuXG4vKipcbiAqIFJldHVybnMgd2hldGhlciBhIHBhcnNlZCBzZWxlY3RvciBpcyBhIGNvbXBsZXggc2VsZWN0b3IsIHdoaWNoXG4gKiBpcyBkZWZpbmVkIGFzIGEgc2VsZWN0b3IgdGhhdCBjb250YWlucyBjb21iaW5hdG9ycy5cbiAqIEBwYXJhbSB7QXJyYXk8VG9rZW4+fSB0b2tlbnNcbiAqL1xuZnVuY3Rpb24gaXNDb21wbGV4U2VsZWN0b3IodG9rZW5zKSB7XG4gIHJldHVybiB0b2tlbnMuc29tZSgodG9rZW4pID0+IHRva2VuLnR5cGUgIT09IFNFTEVDVE9SKTtcbn1cblxuXG4vKipcbiAqIFRha2VzIGEgY29tcG9uZW50IGNvbnN0cnVjdG9yLCBvYmplY3QsIG9yIHN0cmluZyByZXByZXNlbnRpbmdcbiAqIGEgc2ltcGxlIHNlbGVjdG9yIGFuZCByZXR1cm5zIGEgcHJlZGljYXRlIGZ1bmN0aW9uIHRoYXQgY2FuXG4gKiBiZSBhcHBsaWVkIHRvIGEgc2luZ2xlIG5vZGUuXG4gKiBAcGFyYW0ge0VuenltZVNlbGVjdG9yfSBzZWxlY3RvclxuICovXG5leHBvcnQgZnVuY3Rpb24gYnVpbGRQcmVkaWNhdGUoc2VsZWN0b3IpIHtcbiAgLy8gSWYgdGhlIHNlbGVjdG9yIGlzIGEgc3RyaW5nLCBwYXJzZSBpdCBhcyBhIHNpbXBsZSBDU1Mgc2VsZWN0b3JcbiAgaWYgKHR5cGVvZiBzZWxlY3RvciA9PT0gJ3N0cmluZycpIHtcbiAgICBjb25zdCB0b2tlbnMgPSBzYWZlbHlHZW5lcmF0ZVRva2VucyhzZWxlY3Rvcik7XG4gICAgaWYgKGlzQ29tcGxleFNlbGVjdG9yKHRva2VucykpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoaXMgbWV0aG9kIGRvZXMgbm90IHN1cHBvcnQgY29tcGxleCBDU1Mgc2VsZWN0b3JzJyk7XG4gICAgfVxuICAgIC8vIFNpbXBsZSBzZWxlY3RvcnMgb25seSBoYXZlIGEgc2luZ2xlIHNlbGVjdG9yIHRva2VuXG4gICAgcmV0dXJuIGJ1aWxkUHJlZGljYXRlRnJvbVRva2VuKHRva2Vuc1swXSk7XG4gIH1cblxuICAvLyBJZiB0aGUgc2VsZWN0b3IgaXMgYW4gZWxlbWVudCB0eXBlLCBjaGVjayBpZiB0aGUgbm9kZSdzIHR5cGUgbWF0Y2hlc1xuICBjb25zdCBhZGFwdGVyID0gZ2V0QWRhcHRlcigpO1xuICBjb25zdCBpc0VsZW1lbnRUeXBlID0gYWRhcHRlci5pc1ZhbGlkRWxlbWVudFR5cGVcbiAgICA/IGFkYXB0ZXIuaXNWYWxpZEVsZW1lbnRUeXBlKHNlbGVjdG9yKVxuICAgIDogdHlwZW9mIHNlbGVjdG9yID09PSAnZnVuY3Rpb24nO1xuICBpZiAoaXNFbGVtZW50VHlwZSkge1xuICAgIHJldHVybiAobm9kZSkgPT4gYWRhcHRlci5tYXRjaGVzRWxlbWVudFR5cGUobm9kZSwgc2VsZWN0b3IpO1xuICB9XG4gIC8vIElmIHRoZSBzZWxlY3RvciBpcyBhbiBub24tZW1wdHkgb2JqZWN0LCB0cmVhdCB0aGUga2V5cy92YWx1ZXMgYXMgcHJvcHNcbiAgaWYgKHR5cGVvZiBzZWxlY3RvciA9PT0gJ29iamVjdCcpIHtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoc2VsZWN0b3IpICYmIHNlbGVjdG9yICE9PSBudWxsICYmIE9iamVjdC5rZXlzKHNlbGVjdG9yKS5sZW5ndGggPiAwKSB7XG4gICAgICBjb25zdCBoYXNVbmRlZmluZWRWYWx1ZXMgPSB2YWx1ZXMoc2VsZWN0b3IpLnNvbWUoKHZhbHVlKSA9PiB0eXBlb2YgdmFsdWUgPT09ICd1bmRlZmluZWQnKTtcbiAgICAgIGlmIChoYXNVbmRlZmluZWRWYWx1ZXMpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignRW56eW1lOjpQcm9wcyBjYW7igJl0IGhhdmUgYHVuZGVmaW5lZGAgdmFsdWVzLiBUcnkgdXNpbmcg4oCYZmluZFdoZXJlKCnigJkgaW5zdGVhZC4nKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiAobm9kZSkgPT4gbm9kZU1hdGNoZXNPYmplY3RQcm9wcyhub2RlLCBzZWxlY3Rvcik7XG4gICAgfVxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0VuenltZTo6U2VsZWN0b3IgZG9lcyBub3Qgc3VwcG9ydCBhbiBhcnJheSwgbnVsbCwgb3IgZW1wdHkgb2JqZWN0IGFzIGEgc2VsZWN0b3InKTtcbiAgfVxuXG4gIHRocm93IG5ldyBUeXBlRXJyb3IoJ0VuenltZTo6U2VsZWN0b3IgZXhwZWN0cyBhIHN0cmluZywgb2JqZWN0LCBvciB2YWxpZCBlbGVtZW50IHR5cGUgKENvbXBvbmVudCBDb25zdHJ1Y3RvciknKTtcbn1cblxuLyoqXG4gKiBNYXRjaGVzIG9ubHkgbm9kZXMgd2hpY2ggYXJlIGFkamFjZW50IHNpYmxpbmdzIChkaXJlY3QgbmV4dCBzaWJsaW5nKVxuICogYWdhaW5zdCBhIHByZWRpY2F0ZSwgcmV0dXJuaW5nIHRob3NlIHRoYXQgbWF0Y2guXG4gKiBAcGFyYW0ge0FycmF5PE5vZGU+fSBub2Rlc1xuICogQHBhcmFtIHtGdW5jdGlvbn0gcHJlZGljYXRlXG4gKiBAcGFyYW0ge05vZGV9IHJvb3RcbiAqL1xuZnVuY3Rpb24gbWF0Y2hBZGphY2VudFNpYmxpbmdzKG5vZGVzLCBwcmVkaWNhdGUsIHJvb3QpIHtcbiAgcmV0dXJuIG5vZGVzLnJlZHVjZSgobWF0Y2hlcywgbm9kZSkgPT4ge1xuICAgIGNvbnN0IHBhcmVudCA9IGZpbmRQYXJlbnROb2RlKHJvb3QsIG5vZGUpO1xuICAgIC8vIElmIHRoZXJlJ3Mgbm8gcGFyZW50LCB0aGVyZSdzIG5vIHNpYmxpbmdzXG4gICAgaWYgKCFwYXJlbnQpIHtcbiAgICAgIHJldHVybiBtYXRjaGVzO1xuICAgIH1cbiAgICBjb25zdCBwYXJlbnRDaGlsZHJlbiA9IGNoaWxkcmVuT2ZOb2RlKHBhcmVudCk7XG4gICAgY29uc3Qgbm9kZUluZGV4ID0gcGFyZW50Q2hpbGRyZW4uaW5kZXhPZihub2RlKTtcbiAgICBjb25zdCBhZGphY2VudFNpYmxpbmcgPSBwYXJlbnRDaGlsZHJlbltub2RlSW5kZXggKyAxXTtcbiAgICAvLyBObyBzaWJsaW5nXG4gICAgaWYgKCFhZGphY2VudFNpYmxpbmcpIHtcbiAgICAgIHJldHVybiBtYXRjaGVzO1xuICAgIH1cbiAgICBpZiAocHJlZGljYXRlKGFkamFjZW50U2libGluZykpIHtcbiAgICAgIG1hdGNoZXMucHVzaChhZGphY2VudFNpYmxpbmcpO1xuICAgIH1cbiAgICByZXR1cm4gbWF0Y2hlcztcbiAgfSwgW10pO1xufVxuXG4vKipcbiAqIE1hdGNoZXMgb25seSBub2RlcyB3aGljaCBhcmUgZ2VuZXJhbCBzaWJsaW5ncyAoYW55IHNpYmxpbmcgKmFmdGVyKilcbiAqIGFnYWluc3QgYSBwcmVkaWNhdGUsIHJldHVybmluZyB0aG9zZSB0aGF0IG1hdGNoLlxuICogQHBhcmFtIHtBcnJheTxOb2RlPn0gbm9kZXNcbiAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWRpY2F0ZVxuICogQHBhcmFtIHtOb2RlfSByb290XG4gKi9cbmZ1bmN0aW9uIG1hdGNoR2VuZXJhbFNpYmxpbmcobm9kZXMsIHByZWRpY2F0ZSwgcm9vdCkge1xuICByZXR1cm4gdW5pcXVlUmVkdWNlKChtYXRjaGVzLCBub2RlKSA9PiB7XG4gICAgY29uc3QgcGFyZW50ID0gZmluZFBhcmVudE5vZGUocm9vdCwgbm9kZSk7XG4gICAgaWYgKCFwYXJlbnQpIHtcbiAgICAgIHJldHVybiBtYXRjaGVzO1xuICAgIH1cbiAgICBjb25zdCBwYXJlbnRDaGlsZHJlbiA9IGNoaWxkcmVuT2ZOb2RlKHBhcmVudCk7XG4gICAgY29uc3Qgbm9kZUluZGV4ID0gcGFyZW50Q2hpbGRyZW4uaW5kZXhPZihub2RlKTtcbiAgICBjb25zdCB5b3VuZ2VyU2libGluZ3MgPSBwYXJlbnRDaGlsZHJlbi5zbGljZShub2RlSW5kZXggKyAxKTtcbiAgICByZXR1cm4gbWF0Y2hlcy5jb25jYXQoeW91bmdlclNpYmxpbmdzLmZpbHRlcihwcmVkaWNhdGUpKTtcbiAgfSwgbm9kZXMpO1xufVxuXG4vKipcbiAqIE1hdGNoZXMgb25seSBub2RlcyB3aGljaCBhcmUgZGlyZWN0IGNoaWxkcmVuIChub3QgZ3JhbmRjaGlsZHJlbiwgZXRjLilcbiAqIGFnYWluc3QgYSBwcmVkaWNhdGUsIHJldHVybmluZyB0aG9zZSB0aGF0IG1hdGNoLlxuICogQHBhcmFtIHtBcnJheTxOb2RlPn0gbm9kZXNcbiAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWRpY2F0ZVxuICovXG5mdW5jdGlvbiBtYXRjaERpcmVjdENoaWxkKG5vZGVzLCBwcmVkaWNhdGUpIHtcbiAgcmV0dXJuIHVuaXF1ZVJlZHVjZShcbiAgICAobWF0Y2hlcywgbm9kZSkgPT4gbWF0Y2hlcy5jb25jYXQoY2hpbGRyZW5PZk5vZGUobm9kZSkuZmlsdGVyKHByZWRpY2F0ZSkpLFxuICAgIG5vZGVzLFxuICApO1xufVxuXG4vKipcbiAqIE1hdGNoZXMgYWxsIGRlc2NlbmRhbnQgbm9kZXMgYWdhaW5zdCBhIHByZWRpY2F0ZSxcbiAqIHJldHVybmluZyB0aG9zZSB0aGF0IG1hdGNoLlxuICogQHBhcmFtIHtBcnJheTxOb2RlPn0gbm9kZXNcbiAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWRpY2F0ZVxuICovXG5mdW5jdGlvbiBtYXRjaERlc2NlbmRhbnQobm9kZXMsIHByZWRpY2F0ZSkge1xuICByZXR1cm4gdW5pcXVlUmVkdWNlKFxuICAgIChtYXRjaGVzLCBub2RlKSA9PiBtYXRjaGVzLmNvbmNhdCh0cmVlRmlsdGVyKG5vZGUsIHByZWRpY2F0ZSkpLFxuICAgIGZsYXQobm9kZXMubWFwKGNoaWxkcmVuT2ZOb2RlKSksXG4gICk7XG59XG5cbi8qKlxuICogVGFrZXMgYW4gUlNUIGFuZCByZWR1Y2VzIGl0IHRvIGEgc2V0IG9mIG5vZGVzIG1hdGNoaW5nXG4gKiB0aGUgc2VsZWN0b3IuIFRoZSBzZWxlY3RvciBjYW4gYmUgYSBzaW1wbGUgc2VsZWN0b3IsIHdoaWNoXG4gKiBpcyBoYW5kbGVkIGJ5IGBidWlsZFByZWRpY2F0ZWAsIG9yIGEgY29tcGxleCBDU1Mgc2VsZWN0b3Igd2hpY2hcbiAqIHJlZHVjZVRyZWVCeVNlbGVjdG9yIHBhcnNlcyBhbmQgcmVkdWNlcyB0aGUgdHJlZSBiYXNlZCBvbiB0aGUgY29tYmluYXRvcnMuXG4gKlxuICogQHBhcmFtIHtFbnp5bWVTZWxlY3Rvcn0gc2VsZWN0b3JcbiAqIEBwYXJhbSB7UlNUTm9kZX0gcm9vdFxuICovXG5leHBvcnQgZnVuY3Rpb24gcmVkdWNlVHJlZUJ5U2VsZWN0b3Ioc2VsZWN0b3IsIHJvb3QpIHtcbiAgaWYgKHR5cGVvZiBzZWxlY3RvciAhPT0gJ3N0cmluZycpIHtcbiAgICBjb25zdCBlbGVtZW50cyA9IGVsZW1lbnRzQnlDb25zdHJ1Y3RvcihzZWxlY3Rvcik7XG4gICAgaWYgKGVsZW1lbnRzLmxlbmd0aCA+IDApIHtcbiAgICAgIHJldHVybiBmbGF0KGVsZW1lbnRzLm1hcCgoeCkgPT4gcmVkdWNlVHJlZUJ5U2VsZWN0b3IoeC50YWcsIHJvb3QpKSk7XG5cbiAgICAgIC8vIHdoZW4gaHR0cHM6Ly9naXRodWIuY29tL2F3ZWFyeS9yc3Qtc2VsZWN0b3ItcGFyc2VyL2lzc3Vlcy8xNSBpcyByZXNvbHZlZFxuICAgICAgLy8gY29uc3QgaHRtbFRhZ05hbWVzID0gZWxlbWVudHMubWFwKHggPT4geC50YWcpLmpvaW4oJywgJyk7XG4gICAgICAvLyByZXR1cm4gcmVkdWNlVHJlZUJ5U2VsZWN0b3IoaHRtbFRhZ05hbWVzLCByb290KTtcbiAgICB9XG4gIH1cblxuICBpZiAodHlwZW9mIHNlbGVjdG9yID09PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiBzZWxlY3RvciA9PT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm4gdHJlZUZpbHRlcihyb290LCBidWlsZFByZWRpY2F0ZShzZWxlY3RvcikpO1xuICB9XG5cbiAgbGV0IHJlc3VsdHMgPSBbXTtcbiAgaWYgKHR5cGVvZiBzZWxlY3RvciA9PT0gJ3N0cmluZycpIHtcbiAgICBjb25zdCB0b2tlbnMgPSBzYWZlbHlHZW5lcmF0ZVRva2VucyhzZWxlY3Rvcik7XG4gICAgbGV0IGluZGV4ID0gMDtcbiAgICB3aGlsZSAoaW5kZXggPCB0b2tlbnMubGVuZ3RoKSB7XG4gICAgICBjb25zdCB0b2tlbiA9IHRva2Vuc1tpbmRleF07XG4gICAgICAvKipcbiAgICAgICAqIFRoZXJlIGFyZSB0d28gdHlwZXMgb2YgdG9rZW5zIGluIGEgQ1NTIHNlbGVjdG9yOlxuICAgICAgICpcbiAgICAgICAqIDEuIFNlbGVjdG9yIHRva2Vucy4gVGhlc2UgdGFyZ2V0IG5vZGVzIGRpcmVjdGx5LCBsaWtlXG4gICAgICAgKiAgICB0eXBlIG9yIGF0dHJpYnV0ZSBzZWxlY3RvcnMuIFRoZXNlIGFyZSBlYXN5IHRvIGFwcGx5XG4gICAgICAgKiAgICBiZWNhdXNlIHdlIGNhbiB0cmF2ZXJzZSB0aGUgdHJlZSBhbmQgcmV0dXJuIG9ubHlcbiAgICAgICAqICAgIHRoZSBub2RlcyB0aGF0IG1hdGNoIHRoZSBwcmVkaWNhdGUuXG4gICAgICAgKlxuICAgICAgICogMi4gQ29tYmluYXRvciB0b2tlbnMuIFRoZXNlIHRva2VucyBjaGFpbiB0b2dldGhlclxuICAgICAgICogICAgc2VsZWN0b3Igbm9kZXMuIEZvciBleGFtcGxlID4gZm9yIGNoaWxkcmVuLCBvciArXG4gICAgICAgKiAgICBmb3IgYWRqYWNlbnQgc2libGluZ3MuIFRoZXNlIGFyZSBoYXJkZXIgdG8gbWF0Y2hcbiAgICAgICAqICAgIGFzIHdlIGhhdmUgdG8gdHJhY2sgd2hlcmUgaW4gdGhlIHRyZWUgd2UgYXJlXG4gICAgICAgKiAgICB0byBkZXRlcm1pbmUgaWYgYSBzZWxlY3RvciBub2RlIGFwcGxpZXMgb3Igbm90LlxuICAgICAgICovXG4gICAgICBpZiAodG9rZW4udHlwZSA9PT0gU0VMRUNUT1IpIHtcbiAgICAgICAgY29uc3QgcHJlZGljYXRlID0gYnVpbGRQcmVkaWNhdGVGcm9tVG9rZW4odG9rZW4sIHJvb3QpO1xuICAgICAgICByZXN1bHRzID0gcmVzdWx0cy5jb25jYXQodHJlZUZpbHRlcihyb290LCBwcmVkaWNhdGUpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFdlIGNhbiBhc3N1bWUgdGhlcmUgYWx3YXlzIGFsbCBwcmV2aW91c2x5IG1hdGNoZWQgdG9rZW5zIHNpbmNlIHNlbGVjdG9yc1xuICAgICAgICAvLyBjYW5ub3Qgc3RhcnQgd2l0aCBjb21iaW5hdG9ycy5cbiAgICAgICAgY29uc3QgeyB0eXBlIH0gPSB0b2tlbjtcbiAgICAgICAgLy8gV2UgYXNzdW1lIHRoZSBuZXh0IHRva2VuIGlzIGEgc2VsZWN0b3IsIHNvIG1vdmUgdGhlIGluZGV4XG4gICAgICAgIC8vIGZvcndhcmQgYW5kIGJ1aWxkIHRoZSBwcmVkaWNhdGUuXG4gICAgICAgIGluZGV4ICs9IDE7XG4gICAgICAgIGNvbnN0IHByZWRpY2F0ZSA9IGJ1aWxkUHJlZGljYXRlRnJvbVRva2VuKHRva2Vuc1tpbmRleF0sIHJvb3QpO1xuICAgICAgICAvLyBXZSBtYXRjaCBhZ2FpbnN0IG9ubHkgdGhlIG5vZGVzIHdoaWNoIGhhdmUgYWxyZWFkeSBiZWVuIG1hdGNoZWQsXG4gICAgICAgIC8vIHNpbmNlIGEgY29tYmluYXRvciBpcyBtZWFudCB0byByZWZpbmUgYSBwcmV2aW91cyBzZWxlY3Rvci5cbiAgICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgICAgLy8gVGhlICsgY29tYmluYXRvclxuICAgICAgICAgIGNhc2UgQURKQUNFTlRfU0lCTElORzpcbiAgICAgICAgICAgIHJlc3VsdHMgPSBtYXRjaEFkamFjZW50U2libGluZ3MocmVzdWx0cywgcHJlZGljYXRlLCByb290KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIC8vIFRoZSB+IGNvbWJpbmF0b3JcbiAgICAgICAgICBjYXNlIEdFTkVSQUxfU0lCTElORzpcbiAgICAgICAgICAgIHJlc3VsdHMgPSBtYXRjaEdlbmVyYWxTaWJsaW5nKHJlc3VsdHMsIHByZWRpY2F0ZSwgcm9vdCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAvLyBUaGUgPiBjb21iaW5hdG9yXG4gICAgICAgICAgY2FzZSBDSElMRDpcbiAgICAgICAgICAgIHJlc3VsdHMgPSBtYXRjaERpcmVjdENoaWxkKHJlc3VsdHMsIHByZWRpY2F0ZSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAvLyBUaGUgJyAnICh3aGl0ZXNwYWNlKSBjb21iaW5hdG9yXG4gICAgICAgICAgY2FzZSBERVNDRU5EQU5UOiB7XG4gICAgICAgICAgICByZXN1bHRzID0gbWF0Y2hEZXNjZW5kYW50KHJlc3VsdHMsIHByZWRpY2F0ZSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5rbm93biBjb21iaW5hdG9yIHNlbGVjdG9yOiAke3R5cGV9YCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGluZGV4ICs9IDE7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0VuenltZTo6U2VsZWN0b3IgZXhwZWN0cyBhIHN0cmluZywgb2JqZWN0LCBvciBDb21wb25lbnQgQ29uc3RydWN0b3InKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0cztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJlZHVjZVRyZWVzQnlTZWxlY3RvcihzZWxlY3Rvciwgcm9vdHMpIHtcbiAgY29uc3QgcmVzdWx0cyA9IHJvb3RzLm1hcCgobikgPT4gcmVkdWNlVHJlZUJ5U2VsZWN0b3Ioc2VsZWN0b3IsIG4pKTtcbiAgcmV0dXJuIHVuaXF1ZShmbGF0KHJlc3VsdHMsIDEpKTtcbn1cbiJdfQ==","map":{"version":3,"mappings":"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","names":["buildPredicate","reduceTreeBySelector","reduceTreesBySelector","parser","CHILD","ADJACENT_SIBLING","GENERAL_SIBLING","DESCENDANT","SELECTOR","TYPE_SELECTOR","CLASS_SELECTOR","ID_SELECTOR","UNIVERSAL_SELECTOR","ATTRIBUTE_PRESENCE","ATTRIBUTE_VALUE","PSEUDO_CLASS","PSEUDO_ELEMENT","EXACT_ATTRIBUTE_OPERATOR","WHITELIST_ATTRIBUTE_OPERATOR","HYPHENATED_ATTRIBUTE_OPERATOR","PREFIX_ATTRIBUTE_OPERATOR","SUFFIX_ATTRIBUTE_OPERATOR","SUBSTRING_ATTRIBUTE_OPERATOR","unique","arr","Set","uniqueReduce","fn","nodes","reduce","safelyGenerateTokens","selector","parse","err","Error","matchAttributeSelector","node","token","operator","value","name","nodeProps","descriptor","Object","getOwnPropertyDescriptor","get","nodePropValue","type","split","indexOf","startsWith","slice","length","matchPseudoSelector","root","parameters","every","n","rendered","firstChild","document","adapter","activeElement","nodeToHostNode","TypeError","nodeMatchesToken","buildPredicateFromToken","body","bodyToken","isComplexSelector","tokens","some","isElementType","isValidElementType","matchesElementType","Array","isArray","keys","hasUndefinedValues","matchAdjacentSiblings","predicate","matches","parent","parentChildren","nodeIndex","adjacentSibling","push","matchGeneralSibling","youngerSiblings","concat","filter","matchDirectChild","matchDescendant","map","childrenOfNode","elements","x","tag","results","index","roots"],"sources":["/Users/sebas/Desktop/robofriends-testing/node_modules/enzyme/src/selectors.js"],"sourcesContent":["import { createParser } from 'rst-selector-parser';\nimport values from 'object.values';\nimport flat from 'array.prototype.flat';\nimport is from 'object-is';\nimport has from 'has';\nimport elementsByConstructor from 'html-element-map/byConstructor';\nimport {\n  treeFilter,\n  nodeHasId,\n  findParentNode,\n  nodeMatchesObjectProps,\n  childrenOfNode,\n  hasClassName,\n} from './RSTTraversal';\nimport { nodeHasType, propsOfNode } from './Utils';\nimport getAdapter from './getAdapter';\n// our CSS selector parser instance\nconst parser = createParser();\n\n// Combinators that allow you to chance selectors\nconst CHILD = 'childCombinator';\nconst ADJACENT_SIBLING = 'adjacentSiblingCombinator';\nconst GENERAL_SIBLING = 'generalSiblingCombinator';\nconst DESCENDANT = 'descendantCombinator';\n\n// Selectors for targeting elements\nconst SELECTOR = 'selector';\nconst TYPE_SELECTOR = 'typeSelector';\nconst CLASS_SELECTOR = 'classSelector';\nconst ID_SELECTOR = 'idSelector';\nconst UNIVERSAL_SELECTOR = 'universalSelector';\nconst ATTRIBUTE_PRESENCE = 'attributePresenceSelector';\nconst ATTRIBUTE_VALUE = 'attributeValueSelector';\n// @TODO we dont support these, throw if they are used\nconst PSEUDO_CLASS = 'pseudoClassSelector';\nconst PSEUDO_ELEMENT = 'pseudoElementSelector';\n\nconst EXACT_ATTRIBUTE_OPERATOR = '=';\nconst WHITELIST_ATTRIBUTE_OPERATOR = '~=';\nconst HYPHENATED_ATTRIBUTE_OPERATOR = '|=';\nconst PREFIX_ATTRIBUTE_OPERATOR = '^=';\nconst SUFFIX_ATTRIBUTE_OPERATOR = '$=';\nconst SUBSTRING_ATTRIBUTE_OPERATOR = '*=';\n\nfunction unique(arr) {\n  return [...new Set(arr)];\n}\n\n/**\n * Calls reduce on a array of nodes with the passed\n * function, returning only unique results.\n * @param {Function} fn\n * @param {Array<Node>} nodes\n */\nfunction uniqueReduce(fn, nodes) {\n  return unique(nodes.reduce(fn, []));\n}\n\n/**\n * Takes a CSS selector and returns a set of tokens parsed\n * by scalpel.\n * @param {String} selector\n */\nfunction safelyGenerateTokens(selector) {\n  try {\n    return parser.parse(selector);\n  } catch (err) {\n    throw new Error(`Failed to parse selector: ${selector}`);\n  }\n}\n\nfunction matchAttributeSelector(node, token) {\n  const { operator, value, name } = token;\n  const nodeProps = propsOfNode(node);\n  const descriptor = Object.getOwnPropertyDescriptor(nodeProps, name);\n  if (descriptor && descriptor.get) {\n    return false;\n  }\n  const nodePropValue = nodeProps[name];\n  if (typeof nodePropValue === 'undefined') {\n    return false;\n  }\n  if (token.type === ATTRIBUTE_PRESENCE) {\n    return has(nodeProps, token.name);\n  }\n  // Only the exact value operator (\"=\") can match non-strings\n  if (typeof nodePropValue !== 'string' || typeof value !== 'string') {\n    if (operator !== EXACT_ATTRIBUTE_OPERATOR) {\n      return false;\n    }\n  }\n  switch (operator) {\n    /**\n     * Represents an element with the att attribute whose value is exactly \"val\".\n     * @example\n     * [attr=\"val\"] matches attr=\"val\"\n     */\n    case EXACT_ATTRIBUTE_OPERATOR:\n      return is(nodePropValue, value);\n    /**\n     * Represents an element with the att attribute whose value is a whitespace-separated\n     * list of words, one of which is exactly\n     * @example\n     *  [rel~=\"copyright\"] matches rel=\"copyright other\"\n     */\n    case WHITELIST_ATTRIBUTE_OPERATOR:\n      return nodePropValue.split(' ').indexOf(value) !== -1;\n    /**\n     * Represents an element with the att attribute, its value either being exactly the\n     * value or beginning with the value immediately followed by \"-\"\n     * @example\n     * [hreflang|=\"en\"] matches hreflang=\"en-US\"\n     */\n    case HYPHENATED_ATTRIBUTE_OPERATOR:\n      return nodePropValue === value || nodePropValue.startsWith(`${value}-`);\n    /**\n     * Represents an element with the att attribute whose value begins with the prefix value.\n     * If the value is the empty string then the selector does not represent anything.\n     * @example\n     * [type^=\"image\"] matches type=\"imageobject\"\n     */\n    case PREFIX_ATTRIBUTE_OPERATOR:\n      return value === '' ? false : nodePropValue.slice(0, value.length) === value;\n    /**\n     * Represents an element with the att attribute whose value ends with the suffix value.\n     * If the value is the empty string then the selector does not represent anything.\n     * @example\n     * [type$=\"image\"] matches type=\"imageobject\"\n     */\n    case SUFFIX_ATTRIBUTE_OPERATOR:\n      return value === '' ? false : nodePropValue.slice(-value.length) === value;\n    /**\n     * Represents an element with the att attribute whose value contains at least one\n     * instance of the value. If value is the empty string then the\n     * selector does not represent anything.\n     * @example\n     * [title*=\"hello\"] matches title=\"well hello there\"\n     */\n    case SUBSTRING_ATTRIBUTE_OPERATOR:\n      return value === '' ? false : nodePropValue.indexOf(value) !== -1;\n    default:\n      throw new Error(`Enzyme::Selector: Unknown attribute selector operator \"${operator}\"`);\n  }\n}\n\n\nfunction matchPseudoSelector(node, token, root) {\n  const { name, parameters } = token;\n  if (name === 'not') {\n    // eslint-disable-next-line no-use-before-define\n    return parameters.every((selector) => reduceTreeBySelector(selector, node).length === 0);\n  }\n  if (name === 'empty') {\n    return treeFilter(node, (n) => n !== node).length === 0;\n  }\n  if (name === 'first-child') {\n    const { rendered } = findParentNode(root, node);\n    const [firstChild] = rendered;\n    return firstChild === node;\n  }\n  if (name === 'last-child') {\n    const { rendered } = findParentNode(root, node);\n    return rendered[rendered.length - 1] === node;\n  }\n  if (name === 'focus') {\n    if (typeof document === 'undefined') {\n      throw new Error('Enzyme::Selector does not support the \":focus\" pseudo-element without a global `document`.');\n    }\n    const adapter = getAdapter();\n    /* eslint-env browser */\n    return document.activeElement && adapter.nodeToHostNode(node) === document.activeElement;\n  }\n\n  throw new TypeError(`Enzyme::Selector does not support the \"${token.name}\" pseudo-element or pseudo-class selectors.`);\n}\n\n/**\n * Takes a node and a token and determines if the node\n * matches the predicate defined by the token.\n * @param {Node} node\n * @param {Token} token\n */\nfunction nodeMatchesToken(node, token, root) {\n  if (node === null || typeof node === 'string') {\n    return false;\n  }\n  switch (token.type) {\n    /**\n     * Match every node\n     * @example '*' matches every node\n     */\n    case UNIVERSAL_SELECTOR:\n      return true;\n    /**\n     * Match against the className prop\n     * @example '.active' matches <div className='active' />\n     */\n    case CLASS_SELECTOR:\n      return hasClassName(node, token.name);\n    /**\n     * Simple type matching\n     * @example 'div' matches <div />\n     */\n    case TYPE_SELECTOR:\n      return nodeHasType(node, token.name);\n    /**\n     * Match against the `id` prop\n     * @example '#nav' matches <ul id=\"nav\" />\n     */\n    case ID_SELECTOR:\n      return nodeHasId(node, token.name);\n    /**\n     * Matches if an attribute is present, regardless\n     * of its value\n     * @example '[disabled]' matches <a disabled />\n     */\n    case ATTRIBUTE_PRESENCE:\n      return matchAttributeSelector(node, token);\n    /**\n     * Matches if an attribute is present with the\n     * provided value\n     * @example '[data-foo=foo]' matches <div data-foo=\"foo\" />\n     */\n    case ATTRIBUTE_VALUE:\n      return matchAttributeSelector(node, token);\n    case PSEUDO_ELEMENT:\n    case PSEUDO_CLASS:\n      return matchPseudoSelector(node, token, root);\n    default:\n      throw new Error(`Unknown token type: ${token.type}`);\n  }\n}\n\n/**\n * Returns a predicate function that checks if a\n * node matches every token in the body of a selector\n * token.\n * @param {Token} token\n */\nfunction buildPredicateFromToken(token, root) {\n  return (node) => token.body.every((bodyToken) => nodeMatchesToken(node, bodyToken, root));\n}\n\n/**\n * Returns whether a parsed selector is a complex selector, which\n * is defined as a selector that contains combinators.\n * @param {Array<Token>} tokens\n */\nfunction isComplexSelector(tokens) {\n  return tokens.some((token) => token.type !== SELECTOR);\n}\n\n\n/**\n * Takes a component constructor, object, or string representing\n * a simple selector and returns a predicate function that can\n * be applied to a single node.\n * @param {EnzymeSelector} selector\n */\nexport function buildPredicate(selector) {\n  // If the selector is a string, parse it as a simple CSS selector\n  if (typeof selector === 'string') {\n    const tokens = safelyGenerateTokens(selector);\n    if (isComplexSelector(tokens)) {\n      throw new TypeError('This method does not support complex CSS selectors');\n    }\n    // Simple selectors only have a single selector token\n    return buildPredicateFromToken(tokens[0]);\n  }\n\n  // If the selector is an element type, check if the node's type matches\n  const adapter = getAdapter();\n  const isElementType = adapter.isValidElementType\n    ? adapter.isValidElementType(selector)\n    : typeof selector === 'function';\n  if (isElementType) {\n    return (node) => adapter.matchesElementType(node, selector);\n  }\n  // If the selector is an non-empty object, treat the keys/values as props\n  if (typeof selector === 'object') {\n    if (!Array.isArray(selector) && selector !== null && Object.keys(selector).length > 0) {\n      const hasUndefinedValues = values(selector).some((value) => typeof value === 'undefined');\n      if (hasUndefinedValues) {\n        throw new TypeError('Enzyme::Props can’t have `undefined` values. Try using ‘findWhere()’ instead.');\n      }\n      return (node) => nodeMatchesObjectProps(node, selector);\n    }\n    throw new TypeError('Enzyme::Selector does not support an array, null, or empty object as a selector');\n  }\n\n  throw new TypeError('Enzyme::Selector expects a string, object, or valid element type (Component Constructor)');\n}\n\n/**\n * Matches only nodes which are adjacent siblings (direct next sibling)\n * against a predicate, returning those that match.\n * @param {Array<Node>} nodes\n * @param {Function} predicate\n * @param {Node} root\n */\nfunction matchAdjacentSiblings(nodes, predicate, root) {\n  return nodes.reduce((matches, node) => {\n    const parent = findParentNode(root, node);\n    // If there's no parent, there's no siblings\n    if (!parent) {\n      return matches;\n    }\n    const parentChildren = childrenOfNode(parent);\n    const nodeIndex = parentChildren.indexOf(node);\n    const adjacentSibling = parentChildren[nodeIndex + 1];\n    // No sibling\n    if (!adjacentSibling) {\n      return matches;\n    }\n    if (predicate(adjacentSibling)) {\n      matches.push(adjacentSibling);\n    }\n    return matches;\n  }, []);\n}\n\n/**\n * Matches only nodes which are general siblings (any sibling *after*)\n * against a predicate, returning those that match.\n * @param {Array<Node>} nodes\n * @param {Function} predicate\n * @param {Node} root\n */\nfunction matchGeneralSibling(nodes, predicate, root) {\n  return uniqueReduce((matches, node) => {\n    const parent = findParentNode(root, node);\n    if (!parent) {\n      return matches;\n    }\n    const parentChildren = childrenOfNode(parent);\n    const nodeIndex = parentChildren.indexOf(node);\n    const youngerSiblings = parentChildren.slice(nodeIndex + 1);\n    return matches.concat(youngerSiblings.filter(predicate));\n  }, nodes);\n}\n\n/**\n * Matches only nodes which are direct children (not grandchildren, etc.)\n * against a predicate, returning those that match.\n * @param {Array<Node>} nodes\n * @param {Function} predicate\n */\nfunction matchDirectChild(nodes, predicate) {\n  return uniqueReduce(\n    (matches, node) => matches.concat(childrenOfNode(node).filter(predicate)),\n    nodes,\n  );\n}\n\n/**\n * Matches all descendant nodes against a predicate,\n * returning those that match.\n * @param {Array<Node>} nodes\n * @param {Function} predicate\n */\nfunction matchDescendant(nodes, predicate) {\n  return uniqueReduce(\n    (matches, node) => matches.concat(treeFilter(node, predicate)),\n    flat(nodes.map(childrenOfNode)),\n  );\n}\n\n/**\n * Takes an RST and reduces it to a set of nodes matching\n * the selector. The selector can be a simple selector, which\n * is handled by `buildPredicate`, or a complex CSS selector which\n * reduceTreeBySelector parses and reduces the tree based on the combinators.\n *\n * @param {EnzymeSelector} selector\n * @param {RSTNode} root\n */\nexport function reduceTreeBySelector(selector, root) {\n  if (typeof selector !== 'string') {\n    const elements = elementsByConstructor(selector);\n    if (elements.length > 0) {\n      return flat(elements.map((x) => reduceTreeBySelector(x.tag, root)));\n\n      // when https://github.com/aweary/rst-selector-parser/issues/15 is resolved\n      // const htmlTagNames = elements.map(x => x.tag).join(', ');\n      // return reduceTreeBySelector(htmlTagNames, root);\n    }\n  }\n\n  if (typeof selector === 'function' || typeof selector === 'object') {\n    return treeFilter(root, buildPredicate(selector));\n  }\n\n  let results = [];\n  if (typeof selector === 'string') {\n    const tokens = safelyGenerateTokens(selector);\n    let index = 0;\n    while (index < tokens.length) {\n      const token = tokens[index];\n      /**\n       * There are two types of tokens in a CSS selector:\n       *\n       * 1. Selector tokens. These target nodes directly, like\n       *    type or attribute selectors. These are easy to apply\n       *    because we can traverse the tree and return only\n       *    the nodes that match the predicate.\n       *\n       * 2. Combinator tokens. These tokens chain together\n       *    selector nodes. For example > for children, or +\n       *    for adjacent siblings. These are harder to match\n       *    as we have to track where in the tree we are\n       *    to determine if a selector node applies or not.\n       */\n      if (token.type === SELECTOR) {\n        const predicate = buildPredicateFromToken(token, root);\n        results = results.concat(treeFilter(root, predicate));\n      } else {\n        // We can assume there always all previously matched tokens since selectors\n        // cannot start with combinators.\n        const { type } = token;\n        // We assume the next token is a selector, so move the index\n        // forward and build the predicate.\n        index += 1;\n        const predicate = buildPredicateFromToken(tokens[index], root);\n        // We match against only the nodes which have already been matched,\n        // since a combinator is meant to refine a previous selector.\n        switch (type) {\n          // The + combinator\n          case ADJACENT_SIBLING:\n            results = matchAdjacentSiblings(results, predicate, root);\n            break;\n          // The ~ combinator\n          case GENERAL_SIBLING:\n            results = matchGeneralSibling(results, predicate, root);\n            break;\n          // The > combinator\n          case CHILD:\n            results = matchDirectChild(results, predicate);\n            break;\n          // The ' ' (whitespace) combinator\n          case DESCENDANT: {\n            results = matchDescendant(results, predicate);\n            break;\n          }\n          default:\n            throw new Error(`Unknown combinator selector: ${type}`);\n        }\n      }\n      index += 1;\n    }\n  } else {\n    throw new TypeError('Enzyme::Selector expects a string, object, or Component Constructor');\n  }\n  return results;\n}\n\nexport function reduceTreesBySelector(selector, roots) {\n  const results = roots.map((n) => reduceTreeBySelector(selector, n));\n  return unique(flat(results, 1));\n}\n"]},"metadata":{},"sourceType":"script"}